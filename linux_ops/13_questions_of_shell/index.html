<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="linux,ops,shell," />





  <link rel="alternate" href="/atom.xml" title="赵光建的个人站点" type="application/atom+xml" />






<meta name="description" content="shell十五问之1: 何为shell？ 在我们回答 shell是什么东西之前，不妨让我们重新审视使用者和计算机系统的关系： 我们知道计算机的运作不能离开硬件，但使用者却无法直接操作硬件，硬件的驱动只能通过一种称为“操作系统(OS，Opertating System)”的软件来管控。事实上，我们每天所谈的“linux”，严格来说只是一个操作系统(OS),我们称之为“内核(kernel)”。 然而，">
<meta name="keywords" content="linux,ops,shell">
<meta property="og:type" content="article">
<meta property="og:title" content="shell十五问--shell教程">
<meta property="og:url" content="https://linux7788.com/linux_ops/13_questions_of_shell/index.html">
<meta property="og:site_name" content="赵光建的个人站点">
<meta property="og:description" content="shell十五问之1: 何为shell？ 在我们回答 shell是什么东西之前，不妨让我们重新审视使用者和计算机系统的关系： 我们知道计算机的运作不能离开硬件，但使用者却无法直接操作硬件，硬件的驱动只能通过一种称为“操作系统(OS，Opertating System)”的软件来管控。事实上，我们每天所谈的“linux”，严格来说只是一个操作系统(OS),我们称之为“内核(kernel)”。 然而，">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://linux7788.com/images/posts/kernel_shell.jpg">
<meta property="og:image" content="https://linux7788.com/images/posts/shell_fork.jpg">
<meta property="og:image" content="https://linux7788.com/images/posts/fork_bomb.png">
<meta property="og:updated_time" content="2018-05-18T15:32:59.011Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shell十五问--shell教程">
<meta name="twitter:description" content="shell十五问之1: 何为shell？ 在我们回答 shell是什么东西之前，不妨让我们重新审视使用者和计算机系统的关系： 我们知道计算机的运作不能离开硬件，但使用者却无法直接操作硬件，硬件的驱动只能通过一种称为“操作系统(OS，Opertating System)”的软件来管控。事实上，我们每天所谈的“linux”，严格来说只是一个操作系统(OS),我们称之为“内核(kernel)”。 然而，">
<meta name="twitter:image" content="https://linux7788.com/images/posts/kernel_shell.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://linux7788.com/linux_ops/13_questions_of_shell/"/>





  <title>shell十五问--shell教程 | 赵光建的个人站点</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3e19b46404548192d1448e7c09e36aad";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <script type="text/javascript">
      var host = "linux7788.com";
      if ((host == window.location.host) && (window.location.protocol != "https:"))
          window.location.protocol = "https";
  </script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赵光建的个人站点</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  
    
  

  <article class="post post-type-normal post-sticky" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://linux7788.com/linux_ops/13_questions_of_shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵光建">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵光建的个人站点">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">shell十五问--shell教程</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-14T10:38:25+08:00">
                2018-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程技能/" itemprop="url" rel="index">
                    <span itemprop="name">编程技能</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程技能/Shell/" itemprop="url" rel="index">
                    <span itemprop="name">Shell</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="shell十五问之1-何为shell？"><a href="#shell十五问之1-何为shell？" class="headerlink" title="shell十五问之1: 何为shell？"></a>shell十五问之1: 何为shell？</h2><hr>
<p>在我们回答 <code>shell</code>是什么东西之前，不妨让我们重新审视<code>使用者</code>和<code>计算机系统</code>的关系：</p>
<p>我们知道计算机的运作不能离开硬件，但使用者却无法直接操作硬件，硬件的驱动只能通过一种称为“<code>操作系统</code>(<code>OS</code>，<code>Opertating System</code>)”的软件来管控。<br>事实上，我们每天所谈的“<code>linux</code>”，严格来说只是一个<code>操作系统</code>(<code>OS</code>),我们称之为“<code>内核</code>(<code>kernel</code>)”。</p>
<p>然而，从使用者的角度来说，使用者没有办法直接操作一个<code>kernel</code>，而是通过<code>kernel</code>的“外壳”程序，也就是所谓的<code>shell</code>，来与<code>kernel</code>沟通。<br>这也正是<code>kernel</code>跟<code>shell</code>的形象命名的的关系。如图：<br><img src="https://linux7788.com/images/posts/kernel_shell.jpg" alt="image"></p>
<p>从技术的角度来说，<code>shell</code>是一个使用者与系统的<code>交互界面(interface)</code>,只能让使用者通过<code>命令行</code>(<code>command line</code>)来使用系统来完成工作。<br>因此，<code>shell</code>最简单的定义就是<code>命令解释器</code>( <code>Command Interpreter</code>):</p>
<ul>
<li>将使用者的命令翻译给kernel来处理；</li>
<li>同时，将kernel的处理结果翻译给使用者。</li>
</ul>
<p>每次当我们完成<code>系统登入</code>(<code>login</code>), 我们就取得一个交互模式的shell，也称之为<code>login shell</code> 或者 <code>primary shell</code>。<br>若从<code>进程</code>(<code>process</code>)的角度来说，我们在shell所下达的命令，均是shell所产生的<code>子进程</code>。<br>这种现象，我暂可称之为<code>fork</code>。<br>如果是执行<code>shell脚本</code>(<code>shell script</code>)的话，脚本中命令则是由另一个非交互模式的<code>子shell</code>(<code>sub shell</code>)来执行的。<br>也就是<code>primary shell</code>产生<code>sub shell</code>的进程，而该<code>sub shell</code>进程再产生<code>script</code>中所有命令的进程。<br> (关于进程，我们日后有机会在补充)<br>这里， 我们必须知道：<code>kernel</code> 与 <code>shell</code> 是不同的两套软件，而且都是可以被替换的：</p>
<ul>
<li>不同的<code>OS</code>使用不同的<code>kernel</code>;</li>
<li>同一个kernel之上，也可以使用不同的<code>shell</code>;</li>
</ul>
<p>在<code>Linux</code>的预设系统中，通常可以找到好几种不同的<code>shell</code>,且通常会被记录在如下文件中：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/shells</span><br></pre></td></tr></table></figure></p>
<p>不同的<code>shell</code>有着不同的功能，且彼此各异，或者说“大同小异”。<br>常见的<code>shell</code>主要分为两大主流：</p>
<ol>
<li>sh：<ul>
<li>burne shell (sh)</li>
<li>burne again shell (bash)</li>
</ul>
</li>
<li>csh：<ul>
<li>c shell (csh)</li>
<li>tc shell (tcsh)</li>
<li>korn shell (ksh)<br>(FIXME)</li>
</ul>
</li>
</ol>
<p>大部分的<code>Linux</code>操作系统的预设<code>shell</code>都是<code>bash</code>，其原因大致如下两种：</p>
<ul>
<li>自由软件</li>
<li>功能强大</li>
</ul>
<p><code>bash</code>是<code>gnu project</code>最成功的产品之一，自推出以来深受广大<code>Unix</code>用户的喜爱，且也逐渐成为不少组织的系统标准。</p>
<a id="more"></a>
<h2 id="shell十五问之2：shell-prompt-PS1-与Carriage-Return-CR-关系"><a href="#shell十五问之2：shell-prompt-PS1-与Carriage-Return-CR-关系" class="headerlink" title="shell十五问之2：shell prompt(PS1)与Carriage Return(CR)关系"></a>shell十五问之2：shell prompt(PS1)与Carriage Return(CR)关系</h2><hr>
<p>当你成功登陆一个<code>shell</code>终端的文字界面之后，大部分的情形下，你会在屏幕上看到一个不断闪烁的方块或者底线(视不同的版本而别)，我们称之为<code>游标</code>(<code>cursor</code>)。<br><code>cursor</code>作用就是告诉你接下来你从键盘输入的按键所插入的位置，且每输入一个键，<code>cursor</code>便向右移动一个格子，如果连续输入太多的话，则自动接在下一行输入。</p>
<p>假如你刚完成登陆，还没有输入任何按键之前，你所看到的<code>cursor</code>所在的位置的同一行的左边部分，我们称之为<code>提示符</code>(<code>prompt</code>)。</p>
<p>提示符的格式或因不同的版本而各有不同，在<code>Linux</code>上，只需留意最接近<code>游标</code>的一个提示符号，通常是如下两者之一：</p>
<ul>
<li>$: 给一般用户账号使用;</li>
<li>#: 给root(管理员)账号使用;</li>
</ul>
<p>事实上，<code>shell prompt</code>的意思很简单：<br>告诉<code>shell</code>使用者，您现在可以输入命令行了。</p>
<p>我们可以说，使用者只有在得到shell prompt才能打命令行，而<code>cursor</code>是指示键盘在命令行的输入位置，使用者每输入一个键，<code>cursor</code>就往后移动一个格，直到碰到命令行读进<code>CR</code>(<code>Carriage Return</code>, 由<code>Enter</code>键产生)字符为止。<br> <code>CR</code>的意思也很简单：<br>使用者告诉<code>shell</code>：老兄，你可以执行的我命令行了。<br>严格来说：<br>所谓的命令行， 就是在<code>shell prompt</code>与<code>CR</code>之间所输入的文字。</p>
<p>(<strong>question：为何我们这里坚持使用<code>CR</code>字符而不说<code>Enter</code>按键呢？答案在后面的学习中给出</strong>)。</p>
<p>不同的命令可以接受的命令的格式各有不同，一般情况下，一个标准的命令行格式为如下所列：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command-name options argument</span><br></pre></td></tr></table></figure></p>
<p>若从技术的细节上来看，<code>shell</code>会依据<code>IFS</code>(<code>Internal Field Seperator</code>) 将 <code>command line</code>所输入的文字给拆解为<code>字段</code>(<code>word</code>)。<br>然后在针对特殊的<code>字符</code>(<code>meta</code>)先做处理，最后在重组整行<code>command line</code>。</p>
<p>(<strong>注意：请务必理解以上两句的意思，我们日后的学习中常回到这里思考</strong>。)</p>
<p>其中<code>IFS</code>是<code>shell</code>预设使用的字段位分隔符号，可以由一个及多个如下按键组成：</p>
<ul>
<li>空白键(White Space)</li>
<li>表格键(Tab)</li>
<li>回车键(Enter)</li>
</ul>
<p>系统可以接受的命令的名称(command-name)可以从如下途径获得：</p>
<ul>
<li>确的路径所指定的外部命令</li>
<li>命令的别名(alias)</li>
<li>shell内建命令(built-in)</li>
<li>$PATH之下的外部命令</li>
</ul>
<p>每一个命令行均必须包含命令的名称，这是不能缺少的。</p>
<h2 id="shell十五问之3：别人echo、你也echo，是问echo知多少？"><a href="#shell十五问之3：别人echo、你也echo，是问echo知多少？" class="headerlink" title="shell十五问之3：别人echo、你也echo，是问echo知多少？"></a>shell十五问之3：别人echo、你也echo，是问echo知多少？</h2><hr>
<p>承接上一章介绍的<code>command line</code>, 这里我们用<code>echo</code>这个命令加以进一步说明。</p>
<blockquote>
<p> <strong>温习</strong><br> 标准的<code>command line</code>三个组成部分：<code>command_name</code> <code>option</code> <code>argument</code></p>
</blockquote>
<p><code>echo</code>是一个非常简单、直接的<code>Linux</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> argument</span></span><br></pre></td></tr></table></figure>
<p><code>echo</code>将<code>argument</code>送出到标准输出(stdout),通常是在监视器(monitor)上输出。</p>
<blockquote>
<p><strong>Note：</strong></p>
</blockquote>
<blockquote>
<p>在linux系统中任何一个进程默认打开三个文件：stdin、stdout、stderr.</p>
</blockquote>
<blockquote>
<p>stdin  标准输入</p>
</blockquote>
<blockquote>
<p>stdout 标准输出</p>
</blockquote>
<blockquote>
<p>stderr 标准错误输出</p>
</blockquote>
<p>为了更好理解，不如先让我们先跑一下<code>echo</code>命令好了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p>
<p>你会发现只有一个空白行，然后又回到了<code>shell prompt</code>上了。<br>这是因为<code>echo</code>在预设上，在显示完<code>argument</code>之后，还会送出以一个换行符号(<code>new-line charactor</code>)。<br>但是上面的command <code>echo</code>并没有任何<code>argument</code>，那结果就只剩一个换行符号。<br>若你要取消这个换行符号， 可以利用<code>echo</code>的<code>-n</code> 选项:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> -n</span></span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p>
<p>不妨让我们回到<code>command line</code>的概念上来讨论上例的echo命令好了：<br><code>command line</code>只有command_name(<code>echo</code>)及option(<code>-n</code>),并没有显示任何<code>argument</code>。</p>
<p>要想看看<code>echo</code>的<code>argument</code>，那还不简单接下来，你可以试试如下的输入：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> first line</span></span><br><span class="line">first line</span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> -n first line</span></span><br><span class="line">first line $</span><br></pre></td></tr></table></figure></p>
<p>以上两个<code>echo</code>命令中，你会发现<code>argument</code>的部分显示在你的屏幕，而换行符则视 <code>-n</code> 选项的有无而别。<br>很明显的，第二个<code>echo</code>由于换行符被取消了，接下来的<code>shell prompt</code>就接在输出结果的同一行了… ^_^。</p>
<p>事实上，<code>echo</code>除了<code>-n</code> 选项之外，常用选项有：</p>
<ul>
<li>-e: 启用反斜杠控制字符的转换(参考下表)</li>
<li>-E: 关闭反斜杠控制字符的转换(预设如此)</li>
<li>-n: 取消行末的换行符号(与-e选项下的\c字符同意)</li>
</ul>
<p>关于<code>echo</code>命令所支持的反斜杠控制字符如下表：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>字符的意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>ALERT / BELL(从系统的喇叭送出铃声)</td>
</tr>
<tr>
<td>\b</td>
<td>BACKSPACE, 也就是向左退格键</td>
</tr>
<tr>
<td>\c</td>
<td>取消行末之换行符号</td>
</tr>
<tr>
<td>\E</td>
<td>ESCAPE, 脱字符键</td>
</tr>
<tr>
<td>\f</td>
<td>FORMFEED, 换页字符</td>
</tr>
<tr>
<td>\n</td>
<td>NEWLINE,  换行字符</td>
</tr>
<tr>
<td>\r</td>
<td>RETURN,  回车键</td>
</tr>
<tr>
<td>\t</td>
<td>TAB, 表格跳位键</td>
</tr>
<tr>
<td>\v</td>
<td>VERTICAL TAB, 垂直表格跳位键</td>
</tr>
<tr>
<td>\n</td>
<td>ASCII 八进制编码(以x开头的为十六进制)，此处的n为数字</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠本身</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Note：</strong><br>上述表格的资料来自O’Reilly出版社的<strong>Learning the Bash Shell, 2nd Ed</strong>.</p>
</blockquote>
<p>或许，我们可以通过实例来了解<code>echo</code>的选项及控制字符：</p>
<p>例一：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">"a\tb\tc\n\d\te\tf"</span></span></span><br><span class="line">a    b	c</span><br><span class="line">d	e	f</span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p>
<p>上例中，用<code>\t</code>来分割<code>abc</code>还有<code>def</code>，及用<code>\n</code>将<code>def</code>换至下一行。</p>
<p>例二：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> -e <span class="string">"\141\011\142\011\143\012\144\011\145\011\146"</span></span></span><br><span class="line">a	b	c</span><br><span class="line">d	e	f</span><br></pre></td></tr></table></figure></p>
<p>与例一中结果一样，只是使用<code>ASCII</code>八进制编码。</p>
<p>例三：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> -e <span class="string">"\x61\x09\x62\x09\x63\x0a\x64\x09\x65\x09\x66"</span></span></span><br><span class="line">a	b	c</span><br><span class="line">d	e	f</span><br></pre></td></tr></table></figure></p>
<p>与例二差不多，只是这次换用<code>ASCII</code>的十六进制编码。</p>
<p>例四：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> -ne <span class="string">"a\tb\tc\nd\te\bf\a"</span></span></span><br><span class="line">a       b       c</span><br><span class="line">d       f $</span><br></pre></td></tr></table></figure></p>
<p>因为<code>e</code>字母后面是退格键<code>(\b)</code>，因此输出结果就没有<code>e</code>了。<br>在结束的时听到一声铃响，是<code>\a</code>的杰作。<br>由于同时使用了<code>-n</code>选项，因此<code>shell prompt</code>紧接在第二行之后。<br>若你不用<code>-n</code>的话，那你在<code>\a</code>后再加个<code>\c</code>，也是同样的效果。</p>
<p>事实上，在日后的<code>shell</code>操作及<code>shell script</code>设计上，<br><code>echo</code>命令是最常被使用的命令之一。<br>比方说，使用<code>echo</code>来检查变量值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">B</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p> <strong>Note:</strong><br> 关于变量的概念，我们留到以下的两章跟大家说明。</p>
</blockquote>
<p>好了，更多的关于<code>command line</code>的格式， 以及<code>echo</code>命令的选项，请您自行多加练习、运用了。</p>
<h2 id="shell十五问之4：””-双引号-与’’-单引号-差在哪？"><a href="#shell十五问之4：””-双引号-与’’-单引号-差在哪？" class="headerlink" title="shell十五问之4：””(双引号)与’’(单引号)差在哪？"></a>shell十五问之4：””(双引号)与’’(单引号)差在哪？</h2><hr>
<p>还是回到我们的<code>command line</code>来吧。</p>
<p>经过前面两章的学习，应该很清楚当你在<code>shell prompt</code>后面敲打键盘,直到按下<code>Enter</code>键的时候，你输入的文字就是<code>command line</code>了，然后<code>shell</code>才会以进程的方式执行你所交给它的命令。<br>但是，你又可知道：你在<code>command line</code>中输入的每一个文字，对<code>shell</code>来说，是有类别之分的呢？</p>
<p>简单而言，(我不敢说精确的定义，<code>注1</code>),<code>command line</code>的每一个<code>charactor</code>, 分为如下两种：</p>
<ul>
<li>literal：也就是普通的纯文字，对<code>shell</code>来说没特殊功能；</li>
<li>meta: 对<code>shell</code>来说，具有特定功能的特殊保留元字符。</li>
</ul>
<blockquote>
<p><strong>Note:</strong></p>
</blockquote>
<blockquote>
<p>对于<code>bash shell</code>在处理<code>comamnd line</code>的顺序说明，请参考O’Reilly出版社的<strong>Learning the Bash Shell，2nd Edition</strong>，第177-180页的说明，尤其是178页的流程图：Figure 7-1。</p>
</blockquote>
<p><code>literal</code>没什么好谈的，像abcd、123456这些文字都是literal。(so easy? ^_^)<br>但meta却常使我们困惑。(confused?)<br>事实上，前两章，我们在<code>command line</code>中已碰到两个似乎每次都会碰到的meta：</p>
<ul>
<li><code>IFS</code>：有<code>space</code>或者<code>tab</code>或者<code>Enter</code>三者之一组成(我们常用space)</li>
<li><code>CR</code>： 由<code>Enter</code>产生；</li>
</ul>
<p><code>IFS</code>是用来拆解<code>command line</code>中每一个词(word)用的，因为<code>shell command line</code>是按词来处理的。<br>而<code>CR</code>则是用来结束<code>command line</code>用的，这也是为何我们敲<code>Enter</code>键，命令就会跑的原因。<br>除了常用的<code>IFS</code>与<code>CR</code>, 常用的meta还有：</p>
<table>
<thead>
<tr>
<th>meta字符</th>
<th>meta字符作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>设定变量</td>
</tr>
<tr>
<td>$</td>
<td>作变量或运算替换(请不要与<code>shell prompt</code>混淆)</td>
</tr>
<tr>
<td>&gt;</td>
<td>输出重定向(重定向stdout)</td>
</tr>
<tr>
<td>&lt;</td>
<td>输入重定向(重定向stdin)</td>
</tr>
<tr>
<td>&amp;</td>
<td>重定向file descriptor或将命令至于后台(bg)运行</td>
</tr>
<tr>
<td>()</td>
<td>将其内部的命令置于nested subshell执行，或用于运算或变量替换</td>
</tr>
<tr>
<td>{}</td>
<td>将期内的命令置于non-named function中执行，或用在变量替换的界定范围</td>
</tr>
<tr>
<td>;</td>
<td>在前一个命令执行结束时，而忽略其返回值，继续执行下一个命令</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>在前一个命令执行结束时，若返回值为true，继续执行下一个命令</td>
</tr>
<tr>
<td>!</td>
<td>执行histroy列表中的命令</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<blockquote>
<p>补充：<code>|</code>是命令管道，而<code>||</code>的意思是在前一个命令执行结束时，若返回值为false，继续执行下一个命令。</p>
</blockquote>
<p>假如我们需要在<code>command line</code>中将这些保留元字符的功能关闭的话，就需要quoting处理了。</p>
<p>在<code>bash</code>中，常用的quoting有以下三种方法：</p>
<ul>
<li>hard quote：’’(单引号)，凡在hard quote中的所有meta均被关闭；</li>
<li>soft quote：””(双引号)，凡在soft quote中大部分meta都会被关闭，但某些会保留(如$);</li>
<li>escape: \ (反斜杠)，只有在紧接在escape(跳脱字符)之后的单一meta才被关闭；</li>
</ul>
<blockquote>
<p><strong>Note:</strong></p>
</blockquote>
<blockquote>
<p> 在soft quote中被豁免的具体meta清单，我不完全知道，有待大家补充，或通过实践来发现并理解。</p>
</blockquote>
<p>下面的例子将有助于我们对quoting的了解：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B C <span class="comment">#空格键未被关掉，作为 IFS 处理。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> C：<span class="built_in">command</span> not found.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> A=<span class="string">"B C"</span> <span class="comment">#空格键已被关掉，仅作为空格键处理。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">B C</span><br></pre></td></tr></table></figure></p>
<p>在第一个给A变量赋值时，由于空白符没有被关闭，<code>command line</code> 将被解释为：</p>
<blockquote>
<p>A=B 然后碰到<code>&lt;IFS&gt;</code>，接着执行C命令</p>
</blockquote>
<p>在第二次给A变量赋值时，由于空白符被置于soft quote中，因此被关闭，不在作为<code>IFS</code>：</p>
<blockquote>
<p><code>A=B&lt;space&gt;C</code></p>
</blockquote>
<p>事实上，空白符无论在soft quote还是在hard quote中，均被关闭。Enter键字符亦然：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=`B</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$A</span>"</span></span></span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<p>在上例中，由于<code>enter</code>被置于hard quote当中，因此不再作为<code>CR</code>字符来处理。<br>这里的<code>enter</code>单纯只是一个<code>断行符号</code>(<code>new-line</code>)而已，由于<code>command line</code>并没得到<code>CR</code>字符，因此进入第二个<code>shell prompt</code>(<code>PS2</code>, 以&gt;符号表示)，<code>command line</code>并不会结束，直到第三行，我们输入的<code>enter</code>并不在hard quote里面，因此没有被关闭。<br>此时，<code>command line</code>碰到<code>CR</code>字符，于是结束，交给shell来处理。</p>
<p>上例的<code>Enter</code>要是被置于soft quote中的话，<code>CR</code>字符也会同样被关闭：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=<span class="string">"B</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">B C</span><br></pre></td></tr></table></figure>
<p>然而，由于 <code>echo $A</code>时的变量没有置于soft quote中，因此，当变量替换完成后，并作命令行重组时，<code>enter</code>被解释为<code>IFS</code>，而不是new-line字符。</p>
<p>同样的，用escape亦可关闭CR字符：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B\</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> C\</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">BC</span><br></pre></td></tr></table></figure></p>
<p>上例中的，第一个<code>enter</code>跟第二个<code>enter</code>均被escape字符关闭了，因此也不作为<code>CR</code>来处理，但第三个<code>enter</code>由于没有被escape，因此，作为<code>CR</code>结束<code>command line</code>。<br>但由于<code>enter</code>键本身在shell meta中特殊性，在 <code>\</code> escape字符后面仅仅取消其<code>CR</code>功能， 而不保留其IFS功能。</p>
<p>你或许发现光是一个<code>enter</code>键所产生的字符，就有可能是如下这些可能：</p>
<ul>
<li>CR</li>
<li>IFS</li>
<li>NL(New Line)</li>
<li>FF(Form Feed)</li>
<li>NULL</li>
<li>…</li>
</ul>
<p>至于，什么时候解释为什么字符，这个我就没法去挖掘了，或者留给读者君自行慢慢摸索了。</p>
<p>至于soft quote跟hard quote的不同，主要是对于某些meta的关闭与否，以<code>$</code>来做说明：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B\ C</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$A</span>"</span></span></span><br><span class="line">B C</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'$A'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">A</span></span><br></pre></td></tr></table></figure></p>
<p>在第一个<code>echo</code>命令行中，<code>$</code>被置于soft quote中，将不被关闭，因此继续处理变量替换，因此，<code>echo</code>将A的变量值输出到屏幕，也就是<code>B C</code>的结果。</p>
<p>在第二个<code>echo</code>命令行中，<code>$</code>被置于hard quote中，则被关闭，因此，<code>$</code>只是一个<code>$</code>符号，并不会用来做变量替换处理，因此结果是<code>$</code>符号后面接一个<code>A</code>字母：<code>$A</code>。</p>
<p><strong>练习与思考:</strong><br>如下结果为何不同？</p>
<blockquote>
<p>tips: 单引号和双引号，在quoting中均被关闭了。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B\ C</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'"$A"'</span>  <span class="comment">#最外面的是单引号</span></span></span><br><span class="line">"$A"</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"'<span class="variable">$A</span>'"</span>  <span class="comment">#最外面的是双引号</span></span></span><br><span class="line">'B C'</span><br></pre></td></tr></table></figure>
<p>比方说，若我们在<code>awk</code>或<code>sed</code>的命令参数中，调用之前设定的一些变量时，常会问及为何不能的问题。</p>
<p>要解决这些问题，关键点就是：<strong>区分出 shell meta 与 command meta</strong></p>
<p>前面我们提到的那些meta，都是在command line中有特殊用途的，比方说<code>{}</code>就是将一系列的command line置于不具名的函数中执行(可简单视为command block)。<br>但是，<code>awk</code>却需要用<code>{}</code>来区分出<code>awk</code>的命令<code>区段</code>(<code>BEGIN,MAIN,END</code>)。<br>若你在command line中如此输入：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk &#123;<span class="built_in">print</span> <span class="variable">$0</span>&#125; 1.txt</span></span><br></pre></td></tr></table></figure></p>
<p>由于<code>{}</code>在<code>shell</code>中并没有关闭，那<code>shell</code>就将<code>{print $0}</code>视为command block，但同时没有<code>;</code>符号作命令分隔，因此，就出现awk语法错误结果。</p>
<p>要解决之，可用hard quote:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $0&#125;' 1.txt</span><br></pre></td></tr></table></figure></p>
<p>上面的hard quote应好理解，就是将原来的<code>{、&lt;space&gt;、$、}</code>这几个shell meta关闭，避免掉在<code>shell</code>中遭到处理，而完整的成为<code>awk</code>的参数中command meta。</p>
<blockquote>
<p><strong>Note:</strong></p>
</blockquote>
<blockquote>
<p><code>awk</code>中使用的<code>$0</code>是<code>awk</code>中内建的field nubmer，而非<code>awk</code>的变量，<code>awk</code>自身的变量无需使用$。</p>
</blockquote>
<p>要是理解了hard quote的功能，在来理解soft quote与escape就不难：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk "&#123;print \$0&#125;" 1.txt</span><br><span class="line">awk \&#123;print \$0\&#125; 1.txt</span><br></pre></td></tr></table></figure></p>
<p>然而，若要你改变<code>awk</code>的<code>$0</code>的<code>0</code>值是从另一个<code>shell</code>变量中读进呢？<br>比方说：已有变量<code>$A</code>的值是<code>0</code>， 那如何在<code>command line</code>中解决awk的$$A呢？<br>你可以很直接否定掉hard quote的方案：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'&#123;print $$A&#125;'</span> 1.txt</span></span><br></pre></td></tr></table></figure></p>
<p>那是因为<code>$A</code>的<code>$</code>在hard quote中是不能替换变量的。</p>
<p>聪明的读者(如你！)，经过本章的学习，我想，你应该可以理解为何我们可以使用如下操作了吧：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A=0</span><br><span class="line">awk "&#123;print \$$A&#125;" 1.txt</span><br><span class="line">awk  \&#123;print\ \$$A\&#125; 1.txt</span><br><span class="line">awk '&#123;print $'$A'&#125;' 1.txt</span><br><span class="line">awk '&#123;print $'"$A"'&#125;' 1.txt</span><br></pre></td></tr></table></figure></p>
<p>或许，你能给出更多方案… ^_^</p>
<p>一个关于read命令的小问题：<br>很早以前觉得很奇怪：执行read命令，然后读取用户输入给变量赋值，但如果输入是以空格键开始的话，这空格会被忽略，比如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read a  #输入：    abc</span><br><span class="line">echo "$a" #只输出abc</span><br></pre></td></tr></table></figure></p>
<p>原因:<br>    变量a的值，从终端输入的值是以IFS开头，而这些IFS将被shell解释器忽略(trim)。<br>    应该与shell解释器分词的规则有关；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read a  #输入：\ \ \ abc</span><br><span class="line">echo "$a" #只输出abc</span><br></pre></td></tr></table></figure>
<p>需要将空格字符转义</p>
<blockquote>
<p><strong>Note:</strong> </p>
</blockquote>
<blockquote>
<p> IFS   Internal field separators, normally  space,  tab,  and newline (see Blank Interpretation section).<br> ……<br> Blank Interpretation<br>  After parameter and command  substitution,  the  results  of substitution<br>  are scanned for internal field separator characters (those found in IFS)<br>  and split  into  distinct  arguments  where  such characters are found.<br>  Explicit null arguments (“” or  ‘’)  are  retained.<br>  Implicit  null  arguments(those  resulting  from  parameters that have no values)<br>  are removed.<br>  (refre to: man sh)</p>
</blockquote>
<p>解决思路：</p>
<ol>
<li>shell command line 主要是将整行line给分解(break down)为每一个单词(word);</li>
<li>而词与词之间的分隔符就是IFS (Internal Field Seperator)。</li>
<li>shell会对command line作处理(如替换，quoting等), 然后再按词重组。(注：别忘了这个重组特性)</li>
<li>当你用IFS来事开头一个变量值，那shell会先整理出这个词，然后在重组command line。</li>
<li>然而，你将IFS换成其他，那shell将视你哪些space/tab为“词”，而不是IFS。那在重组时，可以得到这些词。</li>
</ol>
<p>若你还是不理解，那来验证一下下面这个例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=<span class="string">"  abc"</span> </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">abc</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$A</span>"</span> <span class="comment">#note1</span></span></span><br><span class="line">   abc</span><br><span class="line"><span class="meta">$</span><span class="bash"> old_IFS=<span class="variable">$IFS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> IFS=;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">   abc</span><br><span class="line"><span class="meta">$</span><span class="bash"> IFS=<span class="variable">$old_IFS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong></p>
</blockquote>
<blockquote>
<ol>
<li>这里是用 soft quoting 将里面的 space 关闭，使之不是 meta(IFS)，而是一个literal(white space);</li>
<li>IFS=<code>;</code> 意义是将IFS设置为空字符，因为<code>;</code>是shell的元字符(meta);</li>
</ol>
</blockquote>
<p>问题二：为什么多做了几个分号，我想知道为什么会出现空格呢？<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> a=<span class="string">";;;test"</span>                              </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> IFS=<span class="string">";"</span>                                  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$a</span>                                  </span></span><br><span class="line">   test                                                                         </span><br><span class="line"><span class="meta">$</span><span class="bash"> a=<span class="string">"   test"</span>                              </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$a</span>                                  </span></span><br><span class="line">   test                                                                         </span><br><span class="line"><span class="meta">$</span><span class="bash"> IFS=<span class="string">" "</span>                                  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$a</span>                                  </span></span><br><span class="line">test</span><br></pre></td></tr></table></figure></p>
<p>解答：</p>
<p>这个问题，出在<code>IFS=;</code>上。<br>因为这个<code>;</code>在问题一中的command line上是一个meta,并非<code>&quot;;&quot;</code>符号本身。<br>因此，<code>IFS=;</code>是将IFS设置为 null charactor(不是space、tab、newline)。</p>
<p>要不是试试下面这个代码片段：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> old_IFS=<span class="variable">$IFS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">read</span> A</span></span><br><span class="line">;a;b;c</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">;a;b;c</span><br><span class="line"><span class="meta">$</span><span class="bash"> IFS=<span class="string">";"</span>  <span class="comment">#Note2</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">a b c</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong></p>
</blockquote>
<blockquote>
<p>要关闭<code>;</code>可用<code>&quot;;&quot;</code>或者<code>&#39;;&#39;</code>或者<code>\;</code>。</p>
</blockquote>
<p>思考问题二：文本处理：读文件时，如何保证原汁原味。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat file | <span class="keyword">while</span> <span class="built_in">read</span> i</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>文件file的行中包含若干空，经过<code>read</code>只保留不重复的空格。<br>如何才能所见即所得。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat file | <span class="keyword">while</span> <span class="built_in">read</span> i</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"X<span class="variable">$&#123;i&#125;</span>X"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>从上面的输出，可以看出read，读入是按整行读入的，不能原汁原味的原因：</p>
<blockquote>
<ol>
<li>如果行的起始部分有IFS之类的字符，将被忽略;</li>
<li><code>echo $i</code>的解析过程中，首先将<code>$i</code>替换为字符串，然后对<code>echo</code>字符串中字符串分词，然后命令重组，输出结果;在分词，与命令重组时，可能导致多个相邻的IFS转化为一个;</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat file | <span class="keyword">while</span> <span class="built_in">read</span> i</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>以上代码可以解决原因2中的，command line的分词和重组导致meta字符丢失；但仍然解决不了原因1中<code>read</code>读取行时，忽略行起始的IFS meta字符。</p>
<p>回过头来看上面这个问题：为何要原汁原味呢？<br><code>cat</code>命令就是原汁原味的，只是<code>shell</code>的<code>read</code>、<code>echo</code>导致了某些<code>shell</code>的meta字符丢失;</p>
<p>如果只是IFS meta的丢失，可以采用如下方式：<br>将IFS设置为null，即<code>IFS=;</code>, 在此再次重申此处<code>;</code>是shell的meta字符，而不是literal字符;<br>因此要使用literal的<code>;</code>应该是<code>\;</code>或者关闭meta 的(soft/hard) quoting的<code>&quot;;&quot;</code>或者<code>&#39;;&#39;</code>。</p>
<p>因此上述的解决方案是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">old_IFS=<span class="variable">$IFS</span></span><br><span class="line">IFS=; <span class="comment">#将IFS设置为null</span></span><br><span class="line">cat file | <span class="keyword">while</span> <span class="built_in">read</span> i</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">IFS=old_IFS <span class="comment">#恢复IFS的原始值</span></span><br></pre></td></tr></table></figure></p>
<p>现在，回过头来看这个问题，为什么会有这个问题呢；其本源的问题应该是没有找到解决原始问题的最合适的方法，而是采取了一个迂回的方式来解决了问题；</p>
<p>因此，我们应该回到问题的本源，重新审视一下，问题的本质。如果要精准的获取文件的内容，应该使用od或者hexdump会更好些。</p>
<h2 id="shell十五问之5-问var-value-在export前后的差在哪"><a href="#shell十五问之5-问var-value-在export前后的差在哪" class="headerlink" title="shell十五问之5:问var=value 在export前后的差在哪?"></a>shell十五问之5:问var=value 在export前后的差在哪?</h2><hr>
<p>这次让我们暂时丢开<code>command line</code>, 先了解一下bash变量(variable)吧。</p>
<p>所谓的变量，就是利用一个固定的<code>名称(name)</code>,来存取一段可以变化的<code>值(value)</code>。</p>
<h3 id="1-变量设定-set"><a href="#1-变量设定-set" class="headerlink" title="1. 变量设定(set)"></a>1. 变量设定(set)</h3><p>在<code>bash</code>中， 你可以用<code>=</code>来设定或者重新定义变量的内容：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=value</span><br></pre></td></tr></table></figure></p>
<p>在设定变量的时候，得遵守如下规则：</p>
<ul>
<li>等号左右两边不能使用分隔符号(IFS),也应避免使用shell的保留元字符(meta charactor); </li>
<li>变量的名称(name)不能使用$符号;</li>
<li>变量的名称(name)的首字符不能是数字(number)。</li>
<li>变量的名称(name)的长度不可超过256个字符。</li>
<li>变量的名称(name)及变量的值的大小写是有区别的、敏感的(case sensitive，) </li>
</ul>
<p>如下是一些变量设定时常见的错误：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A= B #=号前后不能有IFS</span><br><span class="line">1A=B #变量名称不能以数字开头</span><br><span class="line"><span class="meta">$</span><span class="bash">A=B <span class="comment">#变量的名称里有$</span></span></span><br><span class="line">a=B  #这跟a=b是不同的,(这不是错误，提醒windows用户)</span><br></pre></td></tr></table></figure></p>
<p>如下则是可以接受的设定：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=" B" #IFS被关闭，参考前面的quoting章节</span><br><span class="line">A1=B   #并非以数字开头</span><br><span class="line">A=$B   #$可用在变量的值内</span><br><span class="line">This_Is_A_Long_Name=b #可用_连接较长的名称或值，且有大小区别；</span><br></pre></td></tr></table></figure></p>
<h3 id="2-变量替换-substitution"><a href="#2-变量替换-substitution" class="headerlink" title="2. 变量替换(substitution)"></a>2. 变量替换(substitution)</h3><p><code>shell</code>之所以强大，其中的一个因素是它可以在命令行中对变量作<code>替换</code>(<code>substitution</code>)处理。<br>在命令行中使用者可以使用<code>$</code>符号加上变量名称(除了用<code>=</code>定义变量名称之外)，<br>将变量值给替换出来，然后再重新组建命令行。</p>
<p>比方:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ A=ls</span><br><span class="line">$ B=la</span><br><span class="line">$ C=/tmp</span><br><span class="line">$ <span class="variable">$A</span> -<span class="variable">$B</span> <span class="variable">$C</span></span><br></pre></td></tr></table></figure></p>
<p>以上命令行的第一个<code>$</code>是<code>shell prompt</code>, 并不在命令行之内。<br>必须强调的是，我们所提的变量替换，只发生在command line上面。<br><strong>是的，请让我们再次回到命令行吧！</strong><br>仔细分析,最后那行command line,不难发现在被执行前(在输入<code>CR</code>字符之前)，<code>$</code>符号对每一个变量作替换处理(将变量的值替换出来再重组命令行),<br>最后会得出如下结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la /tmp</span><br></pre></td></tr></table></figure></p>
<p>还记得第二章，我请大家<strong>务必理解</strong>的那两句吗？<br>若你忘了，我这里重贴一遍：</p>
<blockquote>
<p><strong>Note:</strong></p>
</blockquote>
<blockquote>
<p>若从技术的细节来看，<code>shell</code>会依据<code>IFS</code>(<code>Internal Field Seperator</code>)<br>将command line所输入的文字拆解为字段(word/field)。<br>然后再针对特殊字符(meta)先作处理，最后重组整行command line。</p>
</blockquote>
<p>这里的<code>$</code>就是command line中最经典的meta之一了，就是作变量替换的。<br>在日常的shell操作中，我们常会使用<code>echo</code>命令来查看特定的变量的值。<br>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span> -<span class="variable">$B</span> <span class="variable">$C</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们已学过，<code>echo</code>命令只单纯将其argument送至标准输出(stdout, 通常是我们的屏幕)。<br>所以上面的命令会在屏幕上得到如下结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al /tmp</span><br></pre></td></tr></table></figure></p>
<p>这是由于<code>echo</code>命令在执行时，会先将<code>$A</code> (ls)、<code>$B</code> (la)跟<code>$C</code> (/tmp)给替换出来；利用shell对变量的替换处理能力，我们在设定变量时就更为灵活了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=B</span><br><span class="line">B=$A</span><br></pre></td></tr></table></figure></p>
<p>这样，B的变量值就可继承A变量<strong>当时</strong>的变量值了。<br>不过，不要以<strong>数学逻辑</strong>来套用变量的设定，比方说：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=B</span><br><span class="line">B=C</span><br></pre></td></tr></table></figure></p>
<p>这样，并不会让A的变量值变成C。再如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=B</span><br><span class="line">B=$A</span><br><span class="line">A=C</span><br></pre></td></tr></table></figure></p>
<p>同样也不会让B的值变成C。</p>
<p>上面是单纯定义了两个不同名称的变量：<br>A 与 B, 它们的取值分别是C与B。</p>
<p>若变量被重复定义的话，则原有旧值将被新值所取代。(这不正是可变的量吗？^_^)<br>当我们在设定变量的时候，请记住这点：<strong>用一个名称存储一个数值</strong>， 仅此而已。</p>
<p>此外， 我们也可以利用命令行的变量替换能力来<code>扩充</code>(<code>append</code>)变量的值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=B:C:D</span><br><span class="line">A=$A:E</span><br></pre></td></tr></table></figure></p>
<p>这样， 第一行我们设定A的值为<code>B:C:D</code>,<br>然后,第二行再将值扩充为<code>B:C:D:E</code>。</p>
<p>上面的扩充的范例，我们使用分隔符号(:)来达到扩充的目的，要是没有分隔符的话，如下是有问题的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=BCD</span><br><span class="line">B=$AE</span><br></pre></td></tr></table></figure></p>
<p>因为第二次是将A的值继承$AE的替换结果，而非$A再加E。<br>要解决此问题，我们可用更严谨的替换处理：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=BCD</span><br><span class="line">A=$&#123;A&#125;E</span><br></pre></td></tr></table></figure></p>
<p>上例中，我们使用<code>{}</code>将变量名称范围给明确定义出来，如此一来，我们就可以将A的变量值从BCD给扩充为BCDE。</p>
<blockquote>
<p><strong>Tips:</strong><br>关于${name}事实上还可以做到更多的变量处理能力，这些均属于比较进阶阶段的变量处理，现阶段暂不介绍了，请大家自行参考资料。</p>
</blockquote>
<h3 id="3-export-变量"><a href="#3-export-变量" class="headerlink" title="3. export 变量"></a>3. export 变量</h3><p>严格来说，我们在当前shell中所定义的变量，均属于<strong>本地变量(local variable)</strong>, 只有经过<code>export</code>命令的<strong>输出处理</strong>，才能成为<strong>环境变量(environment variable)</strong>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> A</span></span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> A=B</span></span><br></pre></td></tr></table></figure></p>
<p>经过<code>export</code>输出处理之后，变量A就能成为一个环境变量供其后的命令使用。在使用<code>export</code>的时候，请别忘记shell在命令行对变量的<strong>替换(substitution)处理</strong>。<br>比方说：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> B=C</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> <span class="variable">$A</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面的命令并未将A输出为<strong>环境变量</strong>，而是将B导出。<br>这是因为在这个命令行中，$A会首先被替换为B,然后在塞回作<code>export</code>的参数。</p>
<p>要理解这个<code>export</code>，事实上需要从<code>process</code>(<code>进程</code>)的角度来理解才能透彻。<br>我们将于下一章为大家说明<code>process</code>(<code>进程</code>)的概念，敬请留意。</p>
<h4 id="4-取消变量-unset"><a href="#4-取消变量-unset" class="headerlink" title="4. 取消变量(unset)"></a>4. 取消变量(unset)</h4><p>要取消一个变量，在bash中可使用<code>unset</code>命令来处理：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset A</span><br></pre></td></tr></table></figure></p>
<p>与<code>export</code>一样，<code>unset</code>命令行，也同样会作变量替换(这其实是shell的功能之一)，因此:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> B=C</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> <span class="variable">$A</span></span></span><br></pre></td></tr></table></figure></p>
<p>事实上，所取消的是变量B而不是A。</p>
<p>此外，变量一旦经过<code>unset</code>取消之后，其结果是将整个变量拿掉，而不是取消变量的值。</p>
<p>如下两行其实是很不一样的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br></pre></td></tr></table></figure></p>
<p>第一行只是将变量A设定为<strong>空值(null value)</strong>,但第二行则是让变量A不存在。<br>虽然用眼睛来看，这两种变量的状态在如下的命令结果中都是一样的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br></pre></td></tr></table></figure></p>
<p>请你务必能识别<code>null value</code>与<code>unset</code>的本质区别，这在一些进阶的变量处理上是很严格的。</p>
<p>比方说：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> str=    <span class="comment">#设为null</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> var=<span class="variable">$&#123;str=expr&#125;</span> <span class="comment">#定义var</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$var</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$str</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> str <span class="comment">#取消str</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> var=<span class="variable">$&#123;str=expr&#125;</span> <span class="comment">#定义var</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$var</span></span></span><br><span class="line">expr</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$str</span></span></span><br><span class="line">expr</span><br></pre></td></tr></table></figure></p>
<p>聪明的读者(yes, you!)，稍加思考的话，应该不难发现为何同样的<code>var=${str=expr}</code>在<code>str</code>为<code>null</code>与<code>unset</code>之下的不同吧？<br>若你看不出来，那可能是如下原因之一：</p>
<ul>
<li>你太笨了</li>
<li>不了解 var=${str=expr} 这个进阶处理</li>
<li>对本篇说明还没有来得及消化吸收</li>
<li>我讲得不好</li>
</ul>
<p>不知，您选哪个呢?</p>
<h2 id="shell十五问之6：exec跟source差在哪？"><a href="#shell十五问之6：exec跟source差在哪？" class="headerlink" title="shell十五问之6：exec跟source差在哪？"></a>shell十五问之6：exec跟source差在哪？</h2><hr>
<blockquote>
<p><strong>提问:</strong></p>
</blockquote>
<blockquote>
<p>执行命令<code>cd /etc/aa/bb/cc</code>可以执行并移动到<code>/etc/aa/bb/cc</code>目录，但是把这条命令放入<code>shell脚本</code>执行,却没移动<code>/etc/aa/bb/cc</code>目录！<br>这是什么原因？</p>
</blockquote>
<p>我当时如何回答暂时别去深究，先让我们了解一下<code>进程</code>(<code>process</code>)的概念好了。</p>
<p>首先，我们所执行的任何程序，都是<code>父进程</code>(<code>parent process</code>)产生的一个<code>子进程</code>(<code>child process</code>),子进程在结束后，将返回到父进程去。</p>
<p>此现象在<code>Linux</code>中被称为<code>fork</code>。</p>
<p>(为何要称为fork呢？ 嗯，画一下图或许比较好理解。^_^)<br><img src="https://linux7788.com/images/posts/shell_fork.jpg" alt="image"></p>
<p>当子进程被产生的时候，将会从父进程那里获得一定的资源分配、及<strong>更重要的是</strong>继承父进程的环境。</p>
<p>让我们回到上一章所谈到的环境变量吧：</p>
<blockquote>
<p>所谓环境变量其实就是那些会传给子进程的变量。<br>简单而言, 遗传性就是区分本地变量与环境变量的决定性指标。然而，从遗传的角度来看，我们不难发现环境变量的另一个重要特征：<br><strong>环境变量只能从父进程到子进程单向传递。换句话说：在子进程中环境如何变更，均不会影响父进程的环境。</strong></p>
</blockquote>
<p>接下来，在让我们了解一下<code>shell脚本</code>(<code>shell script</code>)的概念。<br>所谓<code>shell script</code>讲起来很简单，就是将你平时在shell prompt输入的多行command line, 依序输入到一个文件文件而已。</p>
<p>再结合以上两个概念(process + script)，那应该不难理解如下的这句话的意思了：</p>
<blockquote>
<p>正常来说，当我们执行一个<code>shell script</code>时，其实是先产生一个<code>sub-shell</code>的子进程，然后<code>sub-shell</code>再去产生命令行的子进程。</p>
</blockquote>
<p>现在让我们回到本章开始时所提到的例子再从新思考：</p>
<blockquote>
<p><strong>提问:</strong></p>
</blockquote>
<blockquote>
<p>执行命令<code>cd /etc/aa/bb/cc</code>可以执行并移动到<code>/etc/aa/bb/cc</code>目录，但是把这条命令放入<code>shell脚本</code>执行,却没移动<code>/etc/aa/bb/cc</code>目录！<br>这是什么原因？</p>
</blockquote>
<p>我当时的答案是这样的：</p>
<blockquote>
<p>因为，我们一般跑的<code>shell script</code>是用<code>sub-shell</code>去执行的。<br>从<code>process</code>的概念来看，是<code>parent process</code>产生一个<code>child process</code>去执行，当<code>child</code>结束后，返回<code>parent</code>, 但<code>parent</code>的环境是不会因<code>child</code>的改变而改变的。<br>所谓的环境变量元数很多，如<code>effective id(euid)</code>，<code>variable</code>, <code>working dir</code>等等…<br>其中的<code>working dir($PWD)</code> 正是楼主的疑问所在：<br>当用<code>sub-shell</code>来跑<code>script</code>的话，<code>sub-shell</code>的<code>$pwd</code>会因为<code>cd</code>而变更， 但返回<code>primary shell</code>时，<code>$PWD</code>是不会变更的。</p>
</blockquote>
<p>能够了解问题的原因及其原理是很好的，但是如何解决问题，恐怕是我们更应该感兴趣的是吧？</p>
<p>那好，接下来，再让我们了解一下<code>source</code>命令好了。<br>当你有了<code>fork</code>的概念之后，要理解<code>soruce</code>就不难：</p>
<p>所谓<code>source</code>，就是让<code>script</code>在当前<code>shell</code>内执行而不是产生一个<code>sub-shell</code>来执行。<br>由于所有执行结果均在当前<code>shell</code>内执行,而不是产生一个<code>sub-shell</code>来执行。</p>
<p>因此, 只要我们原本单独输入的<code>script</code>命令行，变成<code>source</code>命令的参数，就可轻而易举地解决前面提到的问题了。</p>
<p>比方说，原本我们是如此执行<code>script</code>的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./my_script.sh</span></span><br></pre></td></tr></table></figure></p>
<p>现在改成这样既可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ./my_script.sh</span></span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> . ./my_script.sh</span></span><br></pre></td></tr></table></figure></p>
<p>说到这里，我想，各位有兴趣看看<code>/etc</code>底下的众多设定的文件，应该不难理解它们被定义后，如何让其他<code>script</code>读取并继承了吧？</p>
<p>若然，日后，你有机会写自己的<code>script</code>，应也不难专门指定一个设定的文件以供不同的<code>script</code>一起共用了。</p>
<p>ok,到这里，若你搞懂<code>fork</code>与<code>source</code>的不同，那接下来再接受一个挑战：</p>
<blockquote>
<p>那<code>exec</code>又与<code>source</code>/<code>fork</code>有何不同呢？</p>
</blockquote>
<p>哦…要了解<code>exec</code>或许较为复杂，尤其是扯上<code>File Decscriptor</code>的话。<br>不过，简单来说：</p>
<blockquote>
<p><code>exec</code> 也是让<code>script</code>在同一个进程上执行，但是原有进程则被结束了。<br>简言之，原有进程能否终止，就是<code>exec</code>与<code>source</code>/<code>fork</code>的最大差异了。</p>
</blockquote>
<p>嗯，光是从理论去理解，或许没那么好消化，不如动手实践+思考来得印象深刻哦。</p>
<p>下面让我们为两个简单的<code>script</code>，分别命名为1.sh以及2.sh</p>
<p>1.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line">A=B </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID for 1.sh before exec/source/fork:$$"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> A</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1.sh: \$A is <span class="variable">$A</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">exec</span>)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"using exec..."</span></span><br><span class="line">                <span class="built_in">exec</span> ./2.sh ;;</span><br><span class="line">        <span class="built_in">source</span>)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"using source..."</span></span><br><span class="line">                . ./2.sh ;;</span><br><span class="line">        *)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"using fork by default..."</span></span><br><span class="line">                ./2.sh ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID for 1.sh after exec/source/fork:$$"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1.sh: \$A is <span class="variable">$A</span>"</span></span><br></pre></td></tr></table></figure>
<p>2.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID for 2.sh: $$"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2.sh get \$A=<span class="variable">$A</span> from 1.sh"</span></span><br><span class="line"></span><br><span class="line">A=C</span><br><span class="line"><span class="built_in">export</span> A</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2.sh: \$A is <span class="variable">$A</span>"</span></span><br></pre></td></tr></table></figure>
<p>然后分别跑如下参数来观察结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./1.sh fork</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./1.sh <span class="built_in">source</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./1.sh <span class="built_in">exec</span></span></span><br></pre></td></tr></table></figure></p>
<p>好了，别忘了仔细比较输出结果的不同及背后的原因哦。<br>若有疑问，欢迎提出来一起讨论讨论。</p>
<h2 id="shell十五问之7：-与-差在哪？"><a href="#shell十五问之7：-与-差在哪？" class="headerlink" title="shell十五问之7：()与{}差在哪？"></a>shell十五问之7：()与{}差在哪？</h2><hr>
<p>嗯，这次轻松一下，不讲太多… ^_^</p>
<p>先说一下，为何要用<code>()</code>或者<code>{}</code>好了。</p>
<p>许多时候，我们在<code>shell</code>操作上，需要在一定的条件下执行多个命令，也就是说，要么不执行，要么就全执行，而不是每次依序的判断是否要执行下一个命令。</p>
<p>或者，要从一些命令执行的先后次序中得到结果，如算术运算的<code>2*(3+4)</code>那样。</p>
<p>这时候，我们就可以引入<strong>命令群组(command group)</strong>的概念，将许多命令集中处理。</p>
<p>在<code>shell</code> command line中，一般人或许不太计较<code>()</code>与<code>{}</code>这两对符号的差异。<br>虽然两者都可以将多个命令当作群组处理，但若从技术细节上，却是很不一样的：</p>
<ul>
<li><code>()</code> 将command group置于sub-shell(子shell)中去执行，也称nested sub-shell。</li>
<li><code>{}</code> 则是在同一个shell内完成，也称non-named command group。</li>
</ul>
<p>若你对上一章的fork与source的概念还记得的话，那就不难理解两者的差异了。</p>
<p>要是在command group中扯上变量及其他环境的修改，我们可以根据不同的需求来使用<code>()</code>或<code>{}</code>。<br>通常而言, 若所作的修改是临时的，且不想影响原有或以后的设定，那我们就使用nested sub-shell, 即<code>()</code>;反之，则用non-named command group, 即<code>{}</code>。</p>
<p>是的，光从command line来看，<code>()</code> 与 <code>{}</code>差别就讲完了，够轻松吧。 ^_^</p>
<p>然而，这两个meta用在其他command meta或领域中(如Regular Expression)，还是有很多差别的。<br>只是，我不打算再去说明了，留给读者慢慢发掘好了。</p>
<p>我这里只想补充一个概念，就是function。<br>所谓function，就是用一个名字去命名一个command group, 然后再调用这个名字去执行command group。</p>
<p>从non-named command group来推断，大概你也可以推测到我要说的是<code>{}</code>了吧？(yes! 你真聪明 ^_^)</p>
<p>在bash中，function的定义方式有两种：</p>
<ul>
<li><p>方式一：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> function_name &#123;</span><br><span class="line">        command1</span><br><span class="line">        command2</span><br><span class="line">        command3</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">function_name</span></span> () &#123;</span><br><span class="line">        command1</span><br><span class="line">        command2</span><br><span class="line">        command3</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用哪一种方式无所谓，只是碰到所定义的名称与现有的命令或者别名冲突的话，方式二或许会失败。<br>但方式二起码可以少打个<code>function</code>这一串英文字符，对懒人来说(如我)，有何乐而不为呢？…^_^</p>
<p>function在一定程度上来说，也可以称为<strong>函数</strong>，但请不要与传统编程所使用的<strong>函数(library)</strong>搞混了，毕竟两者差异很大。<br>唯一相同的是，我们都可以随时用<strong>已定义的名称</strong>来调用它们。</p>
<p>若我们在shell操作中，需要不断地重复某些命令，我们首先想到的，或许是将命令写成shell脚本(shell script)。<br>不过，我们也可以写成function, 然后在command line中打上function_name就可当一般的shell script使用了。</p>
<p>若只是你在shell中定义的function, 除了用<code>unset function_name</code>取消外，一旦你退出shell， function也跟着消失。<br>然而，在script脚本中使用function却有许多好处，除了提高整体script的执行性能外(因为已经载入)，还可以节省许多重复的代码。</p>
<p>简单而言，若你会将多个命令写成script以供调用的话，那你可以将function看成script中script。… ^_^</p>
<p>而且通过上一章节介绍的<code>source</code>命令，我们可以自行定义许许多多好用的function，在集中写在特定文件中，然后，在其他的script中用<code>source</code>将它们载入，并反复执行。</p>
<p>若你是<code>RedHat Linux</code>的使用者，或许，已经猜出 <code>/etc/rc.d/init.d/functions</code>这个文件时啥作用了。 ^_^</p>
<p>ok，说要轻松点的嘛，那这次就暂时写到这吧。<br>祝大家学习愉快。</p>
<h2 id="shell十五问之8-与-还有-差在哪？"><a href="#shell十五问之8-与-还有-差在哪？" class="headerlink" title="shell十五问之8: $(())与$()还有${}差在哪？"></a>shell十五问之8: $(())与$()还有${}差在哪？</h2><hr>
<p>我们上一章介绍了<code>()</code>与<code>{}</code>的不同，这次让我们扩展一下，看看更多的变化：</p>
<blockquote>
<p><code>$()</code>与<code>${}</code>又是啥玩意儿呢？</p>
</blockquote>
<p>在bash shell中, $()与``(反引号)都是用来做<code>命令替换</code>(<code>command substitution</code>)的。<br>所谓的<strong>命令替换</strong>与我们第五章学过的变量替换差不多，都是用来<strong>重组命令行</strong>;完成 `` 或者$()里面的命令，将其结果替换出来，再重组命令行。</p>
<p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> the last sunday is $(date -d <span class="string">"last sunday"</span> +%Y-%m-%d)</span></span><br></pre></td></tr></table></figure></p>
<p>如此便可方便得到上一个星期天的日期了。^_^</p>
<p>在操作上， 用$()或``都无所谓,只是我个人比较喜欢用$(),理由是：</p>
<ul>
<li><p>``(反引号)很容易与’’(单引号)搞混乱，尤其对初学者来说。有时在一些奇怪的字形显示中，两种符号是一模一样的(只取两点)。当然了有经验的朋友还是一眼就能分辨两者。只是，若能更好的避免混乱，又何乐而不为呢？ ^_^</p>
</li>
<li><p>在多次的复合替换中， ``需要额外的转义(escape, )处理，而$()则比较直观。</p>
</li>
</ul>
<p>例如，一个错误的使用的例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 `command2 `command3` `</span><br></pre></td></tr></table></figure></p>
<p>原来的本意是要在command2 `command3` ,先将command3替换出来给command2处理，然后再将command2的处理结果，给command1来处理。<br>然而真正的结果在命令行中却是分成了`command2`与 ``。</p>
<p>正确的输入应该如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 `command2 \`command3\` `</span><br></pre></td></tr></table></figure></p>
<p> 要不然换成$()就没有问题了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 $(commmand2 $(command3))</span><br></pre></td></tr></table></figure>
<p>只要你喜欢，做多少层的替换都没有问题。<br>不过，$()并不是没有弊端的。<br>首先，``基本上可用在所有的unix shell中使用，若写成 shell script，其移植性比较高。<br>而$()并不是每一种shell都能使用，我只能说，若你用bash2的话，肯定没问题… ^_^</p>
<p>接下来，再让我们看看${}吧。<br>它其实就是用来做变量替换用的啦，一般情况下，$var与${var}并没有啥不一样。<br>但是用${}会比较精准的界定变量名称的范围，<br>比方说:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$AB</span></span></span><br></pre></td></tr></table></figure></p>
<p>原本是打算先将$A的结果替换出来，然后在其后补一个字母B；但命令行上，真正的结果却是替换变量名称为AB的值出来。<br>若使用${}就没有问题了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;A&#125;</span>B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> BB</span></span><br></pre></td></tr></table></figure></p>
<p>不过，假如你只看到${}只能用来界定变量名称的话，那你就实在太小看bash了。</p>
<p>为了完整起见，我这里再用一些例子加以说明${}的一些特异功能：<br>假设我们定义了一个变量file为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file=/dir1/dir2/dir3/my.file.txt</span><br></pre></td></tr></table></figure></p>
<p>我们可以用${}分别替换获得不同的值：</p>
<h3 id="1-shell字符串的非贪婪-最小匹配-左删除"><a href="#1-shell字符串的非贪婪-最小匹配-左删除" class="headerlink" title="1. shell字符串的非贪婪(最小匹配)左删除"></a>1. shell字符串的非贪婪(最小匹配)左删除</h3><hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file<span class="comment">#*/&#125;  #其值为：dir1/dir2/dir3/my.file.txt</span></span></span><br></pre></td></tr></table></figure>
<p>拿掉第一个<code>/</code>及其左边的字符串，其结果为：<code>dir1/dir2/dir3/my.file.txt</code> 。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file<span class="comment">#*.&#125;  #其值为：file.txt</span></span></span><br></pre></td></tr></table></figure></p>
<p>拿掉第一个<code>.</code>及其左边的字符串，其结果为：<code>file.txt</code> 。</p>
<h3 id="2-shell字符串的贪婪-最大匹配-左删除："><a href="#2-shell字符串的贪婪-最大匹配-左删除：" class="headerlink" title="2. shell字符串的贪婪(最大匹配)左删除："></a>2. shell字符串的贪婪(最大匹配)左删除：</h3><hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file<span class="comment">##*/&#125; #其值为：my.file.txt</span></span></span><br></pre></td></tr></table></figure>
<p>拿掉最后一个<code>/</code>及其左边的字符串，其结果为：<code>my.file.txt</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file<span class="comment">##*.&#125; #其值为：txt</span></span></span><br></pre></td></tr></table></figure>
<p>拿掉最后一个<code>.</code>及其左边的字符串，其结果为：<code>txt</code></p>
<h3 id="3-shell字符串的非贪婪-最小匹配-右删除："><a href="#3-shell字符串的非贪婪-最小匹配-右删除：" class="headerlink" title="3. shell字符串的非贪婪(最小匹配)右删除："></a>3. shell字符串的非贪婪(最小匹配)右删除：</h3><hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file%/*&#125;  <span class="comment">#其值为：/dir1/dir2/dir3</span></span></span><br></pre></td></tr></table></figure>
<p>拿掉最后一个<code>/</code>及其右边的字符串，其结果为：<code>/dir1/dir2/dir3</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file%.*&#125;  <span class="comment">#其值为：/dir1/dir2/dir3/my.file</span></span></span><br></pre></td></tr></table></figure>
<p>拿掉最后一个<code>.</code>及其右边的字符串，其结果为：<code>/dir1/dir2/dir3/my.file</code>。</p>
<h3 id="4-shell字符串的贪婪-最大匹配-右删除："><a href="#4-shell字符串的贪婪-最大匹配-右删除：" class="headerlink" title="4. shell字符串的贪婪(最大匹配)右删除："></a>4. shell字符串的贪婪(最大匹配)右删除：</h3><hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file%%/*&#125;  <span class="comment">#其值为：其值为空。</span></span></span><br></pre></td></tr></table></figure>
<p>拿掉第一个<code>/</code>及其右边的字符串，其结果为：空串。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file%%.*&#125;  <span class="comment">#其值为：/dir1/dir2/dir3/my。</span></span></span><br></pre></td></tr></table></figure>
<p>拿掉第一个<code>.</code>及其右边的字符串，其结果为：<code>/dir1/dir2/dir3/my</code>。</p>
<blockquote>
<p><strong>Tips:</strong></p>
</blockquote>
<blockquote>
<p>记忆方法：</p>
</blockquote>
<blockquote>
<p><code>#</code>是去掉左边(在键盘上<code>#</code>在<code>$</code>的左边);</p>
</blockquote>
<blockquote>
<p><code>%</code>是去掉右边(在键盘上<code>%</code>在<code>$</code>的右边);</p>
</blockquote>
<blockquote>
<p> 单个符号是最小匹配;</p>
</blockquote>
<blockquote>
<p> 两个符号是最大匹配;</p>
</blockquote>
<h3 id="5-shell字符串取子串："><a href="#5-shell字符串取子串：" class="headerlink" title="5. shell字符串取子串："></a>5. shell字符串取子串：</h3><hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file:0:5&#125; <span class="comment">#提取最左边的5个字符：/dir1</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;file:5:5&#125; <span class="comment">#提取第5个字符及其右边的5个字符:/dir2</span></span></span><br></pre></td></tr></table></figure>
<p>shell字符串取子串的格式：<code>${s:pos:length}</code>,取字符串s的子串：从pos位置开始的字符(包括该字符)的长度为length的的子串;<br>其中pos为子串的首字符，在s中位置；<br>length为子串的长度;</p>
<blockquote>
<p><strong>Note:</strong> 字符串中字符的起始编号为0。</p>
</blockquote>
<h3 id="6-shell字符串变量值的替换："><a href="#6-shell字符串变量值的替换：" class="headerlink" title="6. shell字符串变量值的替换："></a>6. shell字符串变量值的替换：</h3><hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file/dir/path&#125;  <span class="comment">#将第一个dir替换为path：/path1/dir2/dir3/my.file.txt</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;file//dir/path&#125; <span class="comment">#将全部的dir替换为path：/path1/path2/path3/my.file.txt</span></span></span><br></pre></td></tr></table></figure>
<p>shell字符串变量值的替换格式：</p>
<ul>
<li><p>首次替换：<br><code>${s/src_pattern/dst_pattern}</code> 将字符串s中的第一个src_pattern替换为dst_pattern。</p>
</li>
<li><p>全部替换：<br><code>${s//src_pattern/dst_pattern}</code> 将字符串s中的所有出现的src_pattern替换为dst_pattern。</p>
</li>
</ul>
<h3 id="7-还可针对变量的不同状态-没设定、空值、非空值-进行赋值："><a href="#7-还可针对变量的不同状态-没设定、空值、非空值-进行赋值：" class="headerlink" title="7. ${}还可针对变量的不同状态(没设定、空值、非空值)进行赋值："></a>7. ${}还可针对变量的不同状态(没设定、空值、非空值)进行赋值：</h3><hr>
<ul>
<li><p><code>${file-my.file.txt}</code> #如果file没有设定，则使用my.file.txt作为返回值,<br>否则返回${file};(空值及非空值时，不作处理。);</p>
</li>
<li><p><code>${file:-my.file.txt}</code> #如果file没有设定或者${file}为空值, 均使用my.file.txt作为其返回值，<br>否则，返回${file}.(${file} 为非空值时，不作处理);</p>
</li>
<li><p><code>${file+my.file.txt}</code> #如果file已设定(为空值或非空值), 则使用my.file.txt作为其返回值，<br>否则不作处理。(未设定时，不作处理);</p>
</li>
<li><p><code>${file:+my.file.txt}</code> #如果${file}为非空值, 则使用my.file.txt作为其返回值，<br>否则，(未设定或者为空值时)不作处理。</p>
</li>
<li><p><code>${file=my.file.txt}</code> #如果file为设定，则将file赋值为my.file.txt，同时将${file}作为其返回值；<br>否则，file已设定(为空值或非空值)，则返回${file}。</p>
</li>
<li><p><code>${file:=my.file.txt}</code> #如果file未设定或者${file}为空值, 则my.file.txt作为其返回值，同时，将${file}赋值为my.file.txt，<br>否则，(非空值时)不作处理。</p>
</li>
<li><p><code>${file?my.file.txt}</code> #如果file没有设定，则将my.file.txt输出至STDERR,<br>否侧，已设定(空值与非空值时)，不作处理。</p>
</li>
<li><p><code>${file:?my.file.txt}</code> #若果file未设定或者为空值，则将my.file.txt输出至STDERR，<br>否则，非空值时，不作任何处理。</p>
</li>
</ul>
<blockquote>
<p><strong>Tips:</strong></p>
</blockquote>
<blockquote>
<p>以上的理解在于，你一定要分清楚，<code>unset</code>与<code>null</code>以及non-null这三种状态的赋值；<br>一般而言，与null有关，若不带<code>:</code>, null不受影响；<br>若带 <code>:</code>, 则连null值也受影响。</p>
</blockquote>
<h3 id="8-计算shell字符串变量的长度："><a href="#8-计算shell字符串变量的长度：" class="headerlink" title="8. 计算shell字符串变量的长度："></a>8. 计算shell字符串变量的长度：</h3><hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#file&#125;  #其值为27, 因为/dir1/dir2/dir3/my.file.txt刚好为27个字符。</span></span></span><br></pre></td></tr></table></figure>
<h3 id="9-bash数组-array-的处理方法"><a href="#9-bash数组-array-的处理方法" class="headerlink" title="9. bash数组(array)的处理方法"></a>9. bash数组(array)的处理方法</h3><hr>
<p>接下来，为大家介绍一下bash的数组(array)的处理方法。<br>一般而言, <code>A=&quot;a b c def&quot;</code>这样的变量只是将<code>$A</code>替换为一个字符串，<br>但是改为 <code>A=(a b c def)</code>,则是将<code>$A</code>定义为数组。</p>
<h4 id="1-数组替换方法可参考如下方法："><a href="#1-数组替换方法可参考如下方法：" class="headerlink" title="1). 数组替换方法可参考如下方法："></a>1). 数组替换方法可参考如下方法：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;A[@]&#125; <span class="comment">#方法一</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;A[*]&#125; <span class="comment">#方法二</span></span></span><br></pre></td></tr></table></figure>
<p>以上两种方法均可以得到：a b c def, 即数组的全部元素。</p>
<h4 id="2-访问数组的成员"><a href="#2-访问数组的成员" class="headerlink" title="2). 访问数组的成员:"></a>2). 访问数组的成员:</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;A[0]&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>${A[0]}</code>可得到a, 即数组A的第一个元素，而 <code>${A[1]}</code>则为数组A的第二元素，依次类推。</p>
<h4 id="3-数组的长度："><a href="#3-数组的长度：" class="headerlink" title="3). 数组的长度："></a>3). 数组的长度：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#A[@]&#125; #方法一</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#A[*]&#125; #方法二</span></span></span><br></pre></td></tr></table></figure>
<p>以上两种方法均可以得到数组的长度: 4, 即数组的所有元素的个数。<br>我们同样可以将该方法应用于数组的成员:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#A[0]&#125; 可以得到：1，即数组A的第一个元素(a)的长度;</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#A[3]&#125; 可以得到：3, 即数组A的第4个元素(def)的长度。</span></span></span><br></pre></td></tr></table></figure>
<h4 id="4-数组元素的重新赋值："><a href="#4-数组元素的重新赋值：" class="headerlink" title="4). 数组元素的重新赋值："></a>4). 数组元素的重新赋值：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[3]=xyz</span><br></pre></td></tr></table></figure>
<p>将数组A的第四个元素重新定义为xyz。</p>
<blockquote>
<p><strong>Tips:</strong></p>
</blockquote>
<blockquote>
<p>诸如此类的…</p>
</blockquote>
<blockquote>
<p>能够善用bash的$()与${}可以大大提高及简化shell在变量上的处理能力哦 ^_^</p>
</blockquote>
<h3 id="10-作用"><a href="#10-作用" class="headerlink" title="10. $(())作用:"></a>10. $(())作用:</h3><hr>
<p>好了，最后为大家介绍<code>$(())</code>的用途吧：<br><code>$(())</code>是用来作整数运算的。</p>
<p>在bash中， <code>$(())</code>的整数运算符号大致有这些：</p>
<ul>
<li>+- *  /    #分别为”加、减、乘、除”。</li>
<li>%            #余数运算,(模数运算)</li>
<li>&amp; | ^ !      #分别为”AND、OR、XOR、NOT”运算。</li>
</ul>
<p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> a=5; b=7; c=2;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $(( a + b * c ))</span></span><br><span class="line">19</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $(( (a + b)/c ))</span></span><br><span class="line">6</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $(( (a * b) % c ))</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>在<code>$(())</code>中的变量名称, 可以在其前面加 <code>$</code>符号来替换，也可以不用，如：<br><code>$(( $a + $b * $c ))</code> 也可以得到19的结果。</p>
<p>此外，<code>$(())</code>还可作不同进制(如二进制、八进制、十六进制)的运算，只是输出结果均为十进制的。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(( 16#2a )) #输出结果为：42，(16进制的2a)</span><br></pre></td></tr></table></figure></p>
<p>以一个实用的例子来看看吧：<br>假如当前的umask是022,那么新建文件的权限即为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span> 022</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"obase=8; <span class="variable">$(( 8#666 &amp; (8#777 ^ 8#$(umask)</span>) ))"</span> | bc</span></span><br><span class="line">644</span><br></pre></td></tr></table></figure></p>
<p>事实上，单纯用<code>(())</code>也可以重定义变量值，或作testing：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=5; ((a++)) #可将$a 重定义为6</span><br><span class="line">a=5; ((a--)) #可将$a 重定义为4</span><br><span class="line">a=5; b=7; ((a&lt; b)) #会得到0 (true)返回值。</span><br></pre></td></tr></table></figure></p>
<p>常见的用于<code>(())</code>的测试符号有如下这些：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>符号名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>小于号</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于或等于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于或等于</td>
</tr>
<tr>
<td>==</td>
<td>等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Note:</strong></p>
</blockquote>
<blockquote>
<p>使用<code>(())</code>作整数测试时，请不要跟<code>[]</code>的整数测试搞混乱了。<br>更多的测试，我们将于第10章为大家介绍。</p>
</blockquote>
<p>怎样？ 好玩吧… ^_^ </p>
<p>ok,这次暂时说这么多。</p>
<p>上面的介绍，并没有详列每一种可用的状态，更多的，就请读者参考手册文件(man)吧。</p>
<h2 id="shell十五问之9：-与-差在哪？"><a href="#shell十五问之9：-与-差在哪？" class="headerlink" title="shell十五问之9：$@与$*差在哪？"></a>shell十五问之9：$@与$*差在哪？</h2><hr>
<p>要说<code>$@</code>与<code>$*</code>之前，需得先从shell script的positional parameter谈起。</p>
<p>我们都已经知道变量(variable)是如何定义和替换的，这个不再多讲了。</p>
<h3 id="1-shell-script的positional-parameter"><a href="#1-shell-script的positional-parameter" class="headerlink" title="1. shell script的positional parameter"></a>1. shell script的positional parameter</h3><p>但是，我们还需要知道有些变量是shell内定的，且其名称是我们不能随意修改的。<br>其中，就有positional parameter在内。</p>
<p>在shell script中，我们可用$0, $1, $2, $3 …<br>这样的变量分别提取命令行中的如下部分:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script_name parameter1 parameter2 parameter3 ...</span><br></pre></td></tr></table></figure></p>
<p>我们很容易就能猜出, <code>$0</code>就是代表 shell script名称(路径)本身，而<code>$1</code>就是其后的第一个参数，如此类推…</p>
<p>须得留意的是<code>IFS</code>的作用, 也就是<code>IFS</code>被quoting处理后，那么positional parameter也会改变。</p>
<p>如下例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my.sh p1 "p2 p3" p4</span><br></pre></td></tr></table></figure></p>
<p>由于p2与p3之间的空白键被soft quoting所关闭了，因此，my.sh的中$2是”p2 p3”,而$3则是p4…</p>
<p>还记得前两章，我们提到function时，我们不是说过，它是script中的script吗？^_^</p>
<p>是的，function一样可以读取自己的(有别于script的)positional parameter, 唯一例外的是<code>$0</code>而已。</p>
<p>举例而言：<br>假设my.sh里有一个函数(function)叫my_fun,若在script中跑<code>my_fun fp1 fp2 fp3</code>,那么，function内的$0就是my.sh，而$1是fp1而不是p1了。</p>
<p>不如写个简单的my.sh script 看看吧：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">my_fun() &#123;</span><br><span class="line">    echo '$0 inside function is '$0</span><br><span class="line">trueecho '$1 inside function is '$1</span><br><span class="line">trueecho '$2 inside function is '$2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo '$0 outside function is '$0</span><br><span class="line">echo '$1 outside function is '$1</span><br><span class="line">echo '$2 outside function is '$2</span><br><span class="line"></span><br><span class="line">my_fun fp1 "fp2 fp3"</span><br></pre></td></tr></table></figure></p>
<p>然后在command line中跑一下 script就知道了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 755 my.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./my.sh p1 <span class="string">"p2 p3"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">0 outside <span class="keyword">function</span> is ./my.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 outside <span class="keyword">function</span> is p1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 outside <span class="keyword">function</span> is p2 p3</span></span><br><span class="line"><span class="meta">$</span><span class="bash">0 inside <span class="keyword">function</span> is ./my.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 inside <span class="keyword">function</span> is fp1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 inside <span class="keyword">function</span> is fp2 fp3</span></span><br></pre></td></tr></table></figure></p>
<p>然而，在使用positional parameter的时候，我们要注意一些陷阱哦：</p>
<p><code>$10</code>不是替换第10个参数，而是替换第一个参数，然后在补一个0于其后;</p>
<p>也就是说， <code>my.sh one two three four five six seven eight nine ten</code>这样的command line, <code>my.sh</code>里的<code>$10</code>不是ten而是<code>one</code>（<code>1</code>）<code>0</code>哦。小心小心要抓到ten的话，有两种方法：</p>
<ul>
<li>方法一：使用我们上一章介绍的<code>${}</code>, 也就是用<code>${10}</code>即可。</li>
<li>方法二：就是shift了。</li>
</ul>
<p>用通俗的说法来说，<strong>所谓的shift就是取消positional parameter中最左边的参数(<code>$0</code>不受影响)</strong>。<br>其预设值为1，也就是shift 或shift 1 都是取消<code>$1</code>,而原本的<code>$2</code>则变成<code>$1</code>, <code>$3</code>则变成<code>$2</code>。<br>那亲爱的读者，你说要shift掉多少个参数，才可用<code>$1</code>取得到<code>${10}</code> 呢？ ^_^</p>
<p>ok，当我们对positional parameter有了基本的概念之后，那再让我们看看其他相关变量吧。</p>
<h3 id="2-shell-script的positional-parameter的number"><a href="#2-shell-script的positional-parameter的number" class="headerlink" title="2. shell script的positional parameter的number"></a>2. shell script的positional parameter的number</h3><p>先是<code>$#</code>, 它可抓出positional parameter的数量。<br>以前面的<code>my.sh p1 &quot;p2 p3&quot;</code>为例：<br>由于”p2 p3”之间的<code>IFS</code>是在soft quote中，因此，<code>$#</code>就可得到的值是2。但如果p2与p3没有置于quoting中话，那<code>$#</code>就可得到3的值了。<br>同样的规则，在function中也是一样。</p>
<p>因此，我们常在shell script里用如下方法，测试script是否有读进参数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ $# = 0 ]</span><br></pre></td></tr></table></figure></p>
<p>假如为<code>0</code>, 那就表示script没有参数，否则就是带有参数。</p>
<h3 id="3-shell-script中的-与"><a href="#3-shell-script中的-与" class="headerlink" title="3. shell script中的$@与$*"></a>3. shell script中的$@与$*</h3><p>接下来就是<code>$@</code>与<code>$*</code>:<br>精确来讲，两者只有在soft quote中才有差异，否则，都表示全部参数 (<code>$0</code>除外)。</p>
<p>若在comamnd line上， 跑<code>my.sh p1 &quot;p2 p3&quot; p4</code>的话，不管<code>$@</code>还是<code>$\*</code>, 都可得到 p1 p2 p3 p4就是了。</p>
<p>但是，如果置于soft quote中的话：</p>
<ul>
<li>“$@”则可得到 “p1” “p2 p3” “p4” 这三个不同字段(word);</li>
<li>“$*”则可得到 “p1 p2 p3 p4” 这一整个单一的字段。</li>
</ul>
<p>我们修改一下前面的my.sh，使之内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">my_fun</span></span>() &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$#</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'the number of parameter in "$@" is '</span> $(my_fun <span class="string">"<span class="variable">$@</span>"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'the number of parameter in "$*" is '</span> $(my_fun <span class="string">"$*"</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后再执行:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./my.sh p1 <span class="string">"p2 p3"</span> p4</span></span><br></pre></td></tr></table></figure></p>
<p>就知道，$@与$*差在哪了。</p>
<h2 id="shell十五问之10：-amp-amp-与-差在哪？"><a href="#shell十五问之10：-amp-amp-与-差在哪？" class="headerlink" title="shell十五问之10：&amp;&amp; 与 || 差在哪？"></a>shell十五问之10：&amp;&amp; 与 || 差在哪？</h2><hr>
<p>好不容易，进入了两位数的章节了。<br>一路走来，很辛苦吧？也很快乐吧？ ^_^</p>
<p>在解答本章题目之前，先让我们了解一个概念：</p>
<blockquote>
<p>return value。我们在shell下跑的每一个command或function，在结束的时候都会传回父进程一个值，称为 <code>return value</code>。</p>
</blockquote>
<p>在shell command line中可用<code>$?</code>，这个变量得到最新的一个<code>return value</code>，也就是刚刚结束的那个进程传回的值。</p>
<p><code>Return Value</code>(RV)的取值为0-255之间，由进程或者script的作者自行定义：</p>
<ul>
<li><p>若在script里，用exit RV 来指定其值;若没有指定, 在结束时，以最后一个命令的RV，为script的RV值。</p>
</li>
<li><p>若在function里，则用return RV 来代替exit RV即可。</p>
</li>
</ul>
<p><code>Return Value</code>的作用：用来判断进程的退出状态(exit status)。</p>
<p>进程的退出状态有两种：</p>
<ul>
<li>0值为”真”(true)</li>
<li>非0值为”假”(false)</li>
</ul>
<p>举个例子来说明好了：<br>假设当前目录内有一个my.file的文件， 而no.file是不存在的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch my.file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls my.file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $? <span class="comment">#first echo</span></span></span><br><span class="line">0</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls no.file</span></span><br><span class="line">ls: no.file: No such file or directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?     <span class="comment">#second echo</span></span></span><br><span class="line">1</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?     <span class="comment">#third echo</span></span></span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>上例的：</p>
<ul>
<li>第一个echo是关于<code>ls my.file</code>的RV，可得到0的值，因此为true。</li>
<li>第二个echo是关于<code>ls no.file</code>的RV，得到非0的值，因此为false。</li>
<li>第三个echo是关于<code>echo $?</code>的RV，得到0值， 因此为true。</li>
</ul>
<p>请记住：<br>每一个command在结束时，都会返回<code>return value</code>，不管你跑什么命令。<br>然而，有一个命令却是专门用来测试某一条而返回<code>return value</code>，以供true或false的判断， 它就是<code>test</code>命令。</p>
<p>若你用的是bash， 请在command line下，打<code>man test</code>，或者 <code>man bash</code> 来了解这个<code>test</code>的用法。<br>这是你可用作参考的最精准的文件了，别人说的，仅作参考就好。</p>
<p>下面，我只简单作一些辅助说明，其余的一律以 <code>man</code>为准：<br>首先，<code>test</code>的表达式，我们称为expression，其命令格式有两种：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test expression</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ expression ]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong></p>
</blockquote>
<blockquote>
<p>请务必注意 <code>[]</code> 之间的空白键!</p>
</blockquote>
<p>用哪一种格式无所谓，都是一样的效果。<br>(我个人比较喜欢后者…)</p>
<p>其次，bash的<code>test</code>目前支持的测试对象只有三种：</p>
<ul>
<li>string：字符串，也就是纯文字。</li>
<li>integer：整数(0或正整数、不含负数或小数)</li>
<li>file：文件</li>
</ul>
<p>请初学者，一定要搞清楚这三者的差异，因为<code>test</code>所使用的expression是不一样的。</p>
<p>以A=123这个变量为例：</p>
<ul>
<li><p><code>[ &quot;$A&quot; = 123 ]</code> #是字符串测试，测试$A是不是1、2、3这三个字符。</p>
</li>
<li><p><code>[ &quot;$A&quot; -eq 123 ]</code> #是整数测试，以测试$A是否等于123。</p>
</li>
<li><p><code>[ -e &quot;$A&quot; ]</code> #文件测试，测试123这份文件是否存在。</p>
</li>
</ul>
<p>第三，<br>当expression测试为“真”时， <code>test</code>就返回0(true)的<code>return value</code>;<br>否则，返回非0(false)。</p>
<p>若在 expression 之前加一个<code>!</code>(感叹号)，则在expression为假时，return value为<code>0</code>,否则, return value 为非<code>0</code>值。</p>
<p>同时，<code>test</code>也允许多重复合测试：</p>
<ul>
<li>expression1 -a expression2 #当两个expression都为true，返回<code>0</code>，否则，返回非<code>0</code>；</li>
<li>expression1 -o expression2 #当两个expression均为false时，返回非<code>0</code>，否则，返回<code>0</code>；</li>
</ul>
<p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -d "$file"  -a  -x "$file" ]</span><br></pre></td></tr></table></figure></p>
<p>表示当<code>$file</code>是一个目录，且同时具有<code>x</code>权限时，<code>test</code>才会为true。</p>
<p>第四，在command line中使用<code>test</code>时，请别忘记命令行的“重组”特性，也就是在碰到meta时，会先处理meta，在重新组建命令行。<br>(这个概念在第2章和第4章进行了反复强调)</p>
<p>比方说， 若<code>test</code>碰到变量或者命令替换时，若不能满足expression的格式时，将会得到语法错误的结果。</p>
<p>举例来说好了：</p>
<p>关于<code>[ string1 = string2 ]</code>这个test格式，在等号两边必须要有字符串，其中包括空串(null串,可用soft quote或者hard quote取得)。</p>
<p>假如$A目前没有定义，或被定义为空字符串的话，那如下的用法将会失败：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ <span class="variable">$A</span> = abc ]</span></span><br><span class="line">[: =: unary oprator expected</span><br></pre></td></tr></table></figure></p>
<p>这是因为命令行碰到<code>$</code>这个meta时，会替换<code>$A</code>的值，然后，再重组命令行，那就变成了<code>[ = abc ]</code>, 如此一来，<code>=</code>的左边就没有字符串存在了，因此，造成test的语法错误。<br>但是，下面这个写法则是成立的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> [ <span class="string">"<span class="variable">$A</span>"</span> = abc ]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>这是因为命令行重组后的结果为：<br><code>[ &quot;&quot; = abc ]</code>,<br>由于等号的左边我们用soft quote得到一个空串，而让test的语法得以通过。</p>
<p>读者诸君，请务必留意这些细节哦，因为稍一不慎，将会导致test的结果变了个样。<br>若您对test还不是很有经验的话，那在使用test时，不妨先采用如下这一个法则:</p>
<blockquote>
<p>若在<code>test</code>中碰到变量替换，用soft quote是最保险的。</p>
</blockquote>
<p>若你对quoting不熟的话，请重新温习第四章的内容吧…^<em>^<br>ok, 关于更多的<code>test</code>的用法，老话一句：请看其man page (<code>man test</code>)吧！^</em>^<br>虽然洋洋洒洒读了一大堆，或许你还在嘀咕…那…那个<code>return value</code>有啥用？</p>
<p>问得好:<br>告诉你：return value的作用可大了，若你想要你的shell变聪明的话，就全靠它了：<br>有了return value，我们可以让shell根据不同的状态做不同的事情。<br>这时候，才让我来揭晓本章的答案吧^_^</p>
<p><code>&amp;&amp;</code> 与 <code>||</code> 都是用来组建多个command line用的；</p>
<ul>
<li><code>command1 &amp;&amp; command2</code> # command2只有在command1的RV为0(true)的条件下执行。</li>
<li><code>command1 || command2</code> # command2 只有在command1的RV为非0(false)的条件下执行。</li>
</ul>
<p>以例子来说好了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"yes! it's true."</span></span></span><br><span class="line">yes! it's true.</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"yes! it's true."</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] || <span class="built_in">echo</span> <span class="string">"no, it's Not true."</span></span></span><br><span class="line">no, it's Not true</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong></p>
</blockquote>
<blockquote>
<p><code>[ -n string ]</code>是测试string长度大于0, 则为true。</p>
</blockquote>
<p>上例中，第一个<code>&amp;&amp;</code>命令之所以会执行其右边的<code>echo</code>命令，是因为上一个<code>test</code>返回了0的RV值；<br>但第二个，就不会执行，因为<code>test</code>返回了非0的结果。<br>同理，<code>||</code>右边的<code>echo</code>会被执行，却正是因为左边的<code>test</code>返回非0所引起的。</p>
<p>事实上，我们在同一个命令行中，可用多个<code>&amp;&amp;</code> 或 <code>||</code> 来组建呢。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"yes! it's true."</span> || <span class="built_in">echo</span> <span class="string">"no, it's Not ture."</span></span></span><br><span class="line">yes! it's true.</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"yes! it's true."</span> || <span class="built_in">echo</span> <span class="string">"no, it's Not ture."</span></span></span><br><span class="line">no, it's Not true</span><br></pre></td></tr></table></figure></p>
<p>怎样，从这一刻开始，你是否觉得我们的shell是“很聪明”的呢？ ^_^</p>
<p>好了，最后布置一道练习题给大家做做看：<br>下面的判断是：当$A被赋值时，在看看其是否小于100，否则输出too big！<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$A</span>"</span> -lt 100 ] || <span class="built_in">echo</span> <span class="string">'too big!'</span></span></span><br><span class="line">too big!</span><br></pre></td></tr></table></figure></p>
<p>若我取消A，照理说，应该不会输出文字啊，(因为第一个条件不成立)。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$A</span>"</span> -lt 100 ] || <span class="built_in">echo</span> <span class="string">'too big!'</span></span></span><br><span class="line">too big!</span><br></pre></td></tr></table></figure></p>
<p>为何上面的结果也可得到呢？输出了too big？又如何解决呢？</p>
<blockquote>
<p><strong>Tips:</strong></p>
</blockquote>
<blockquote>
<p>修改的方法有很多种，<br>其中一种方法可以利用第7章中介绍过 <code>command group</code>。</p>
</blockquote>
<p>快告诉我答案，其余免谈。</p>
<p>解决方法1：<code>sub-shell</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; ( [ <span class="string">"<span class="variable">$A</span>"</span> -lt 100 ] || <span class="built_in">echo</span> <span class="string">'too big!'</span> )</span></span><br></pre></td></tr></table></figure></p>
<p>解决方法二：<code>command group</code>:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; &#123; [ <span class="string">"<span class="variable">$A</span>"</span> -lt 100 ] || <span class="built_in">echo</span> <span class="string">'too big!'</span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="shell十五问之11：-gt-与-lt-差在哪？"><a href="#shell十五问之11：-gt-与-lt-差在哪？" class="headerlink" title="shell十五问之11：&gt;与&lt; 差在哪？"></a>shell十五问之11：&gt;与&lt; 差在哪？</h2><hr>
<h3 id="1-文件描述符-fd-File-Descriptor"><a href="#1-文件描述符-fd-File-Descriptor" class="headerlink" title="1. 文件描述符(fd, File Descriptor)"></a>1. 文件描述符(fd, File Descriptor)</h3><p>谈到<code>I/O redirection</code>,不妨先让我们认识一下<code>File Descriptor</code>(<code>fd</code>，文件描述符)。</p>
<p>进程的运算，在大部分情况下，都是进行数据(data)的处理，这些数据从哪里，读进来？又输出到哪里呢？<br>这就是file descriptor(fd)的功用了。</p>
<p>在shell的进程中，最常使用的<code>fd</code>大概有三个，分别为:</p>
<ul>
<li>0：standard Input (<code>STDIN</code>) </li>
<li>1: standard output(<code>STDOUT</code>)</li>
<li>2: standard Error output （<code>STDERR</code>）</li>
</ul>
<p>在标准情况下，这些fd分别跟如下设备(device)关联：</p>
<ul>
<li><code>stdin</code>(0): keyboard</li>
<li><code>stdout</code>(1): monitor</li>
<li><code>stderr</code>(2): monitor</li>
</ul>
<blockquote>
<p><strong>Tips:</strong><br>linux中的文件描述符(fd)用整数表示。<br>linux中任何一个进程都默认打开三个文件,<br>这三个文件对应的文件描述符分别是：0, 1, 2;<br>即stdin, stdout, stderr.</p>
</blockquote>
<p>我们可以用如下命令测试一下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mail -s <span class="built_in">test</span> root</span></span><br><span class="line">this is a test mail。</span><br><span class="line">please skip.</span><br><span class="line">^d (同时按下ctrl 跟d键)</span><br></pre></td></tr></table></figure></p>
<p>很明显，<code>mail</code>进程所读进的数据，就是从<code>stdin</code> 也就是keyboard读进的。<br>不过，不见得每个进程的<code>stdin</code>都跟<code>mail</code>一样从<code>keyboard</code>读进，<br>因为进程的作者可以从文件参数读进<code>stdin</code>，如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd</span></span><br></pre></td></tr></table></figure></p>
<p>但，要是<code>cat</code>之后没有文件参数则如何呢？<br>哦， 请你自己玩玩看…^_^<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Tips:</strong></p>
</blockquote>
<blockquote>
<p>请留意数据输出到哪里去了，<br>最后别忘了按<code>ctrl+d</code>(<code>^d</code>), 退出stdin输入。</p>
</blockquote>
<p>至于<code>stdout</code>与<code>stderr</code>，嗯…等我有空再续吧…^_^<br>还是，有哪位前辈来玩接龙呢？</p>
<p>相信，经过上一个练习后，你对<code>stdin</code>与<code>stdout</code>应该不难理解了吧？<br>然后，让我们看看<code>stderr</code>好了。</p>
<p>事实上，<code>stderr</code>没什么难理解的：<br>说白了就是“错误信息”要往哪里输出而已比方说, 若读进的文件参数不存在的，<br>那我们在monitor上就看到了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls no.such.file</span></span><br><span class="line">ls: no.such.file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>若同一个命令，同时成生<code>stdout</code>与<code>stderr</code>呢？那还不简单，都送到monitor来就好了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch my.file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls my.file on.such.file</span></span><br><span class="line">ls: no.such.file: No such file or directory</span><br><span class="line">my.file</span><br></pre></td></tr></table></figure></p>
<p>okay, 至此，关于fd及其名称、还有相关联的设备，相信你已经没问题了吧？</p>
<h3 id="2-I-O-重定向-I-O-Redirection"><a href="#2-I-O-重定向-I-O-Redirection" class="headerlink" title="2. I/O 重定向(I/O Redirection)"></a>2. I/O 重定向(I/O Redirection)</h3><hr>
<p>那好，接下来让我们看看如何改变这些fd的预设数据通道。</p>
<ul>
<li>用<code>&lt;</code> 来改变读进的数据通道(stdin),使之从指定的文件读进。</li>
<li>用<code>&gt;</code> 来改变输出的数据通道(stdout，stderr),使之输出到指定的文件。</li>
</ul>
<hr>
<h4 id="2-1-输入重定向-n-lt-input-redirection"><a href="#2-1-输入重定向-n-lt-input-redirection" class="headerlink" title="2.1 输入重定向 n &lt; (input redirection)"></a>2.1 输入重定向 n &lt; (input redirection)</h4><hr>
<p>比方说：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; my.file</span></span><br></pre></td></tr></table></figure></p>
<p>就是从my.file读入数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mail -s <span class="built_in">test</span> root &lt; /etc/passwd</span></span><br></pre></td></tr></table></figure>
<p>则是从<code>/etc/passwd</code>读入，这样一来，stdin将不再是从keyboard读入，而是从指定的文件读入了。</p>
<p>严格来说，<code>&lt;</code>符号之前需要指定一个fd的(之前不能有空白)，但因为0是<code>&lt;</code>的预设值，因此，<code>&lt;</code>与<code>0&lt;</code>是一样的。</p>
<p>ok，这样好理解了吧？</p>
<p>那要是用两个<code>&lt;</code>，即<code>&lt;&lt;</code>又是啥呢？<br>这是所谓的<code>here document</code>, 它可以让我们输入一段文本，直到读到<code>&lt;&lt;</code> 后指定的字符串。</p>
<p>比方说：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt;EOF</span></span><br><span class="line">first line here</span><br><span class="line">second line here</span><br><span class="line">third line here</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p>
<p>这样的话, <code>cat</code>会读入3个句子，而无需从keyboard读进数据且要等到(ctrl+d, ^d)结束输入。</p>
<hr>
<h4 id="2-2-重定向输出-gt-n-output-redirection"><a href="#2-2-重定向输出-gt-n-output-redirection" class="headerlink" title="2.2 重定向输出 &gt; n (output redirection)"></a>2.2 重定向输出 &gt; n (output redirection)</h4><hr>
<p>当你搞懂了<code>0&lt;</code> 原来就是改变<code>stdin</code>的数据输入通道之后，相信要理解如下两个redirection就不难了：</p>
<ul>
<li><code>1&gt;</code> #改变stdout的输出通道；</li>
<li><code>2&gt;</code> #改变stderr的输出通道；</li>
</ul>
<p>两者都是将原来输出到monitor的数据，重定向输出到指定的文件了。</p>
<p>由于1是<code>&gt;</code>的预设值，因此，<code>1&gt;</code>与<code>&gt;</code>是相同的，都是改变<code>stdout</code>。</p>
<p>用上次的ls的例子说明一下好了:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 1&gt;file.out</span></span><br><span class="line">ls: no.such.file: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>这样monitor的输出就只剩下<code>stderr</code>的输出了，因为<code>stdout</code>重定向输出到文件file.out去了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 2&gt;file.err</span></span><br><span class="line">my.file</span><br></pre></td></tr></table></figure>
<p>这样monitor就只剩下了<code>stdout</code>, 因为<code>stderr</code>重定向输出到文件file.err了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 1&gt;file.out 2&gt;file.err</span></span><br></pre></td></tr></table></figure>
<p>这样monitor就啥也没有了，因为<code>stdout</code>与<code>stderr</code>都重定向输出到文件了。</p>
<p>呵呵，看来要理解<code>&gt;</code>一点也不难啦是不？ 没骗你吧？ ^_^<br>不过有些地方还是要注意一下的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 1&gt;file.both 2&gt;file.both</span></span><br></pre></td></tr></table></figure>
<p>假如<code>stdout</code>(1)与<code>stderr</code>(2)都同时在写入file.both的话，则是采取覆盖的方式：后来写入覆盖前面的。</p>
<p>让我们假设一个<code>stdout</code>与<code>stderr</code>同时写入到file.out的情形好了；</p>
<ul>
<li>首先<code>stdout</code>写入10个字符</li>
<li>然后<code>stderr</code>写入6个字符</li>
</ul>
<p>那么，这时原本的<code>stdout</code>输出的10个字符，将被<code>stderr</code>输出的6个字符覆盖掉了。</p>
<p>那如何解决呢？所谓山不转路转，路不转人转嘛，我们可以换一个思维：<br>将<code>stderr</code>导进<code>stdout</code><br>或者将<code>stdout</code>导进到<code>stderr</code>，而不是大家在抢同一份文件，不就行了。<br>bingo就是这样啦：</p>
<ul>
<li>2&gt;&amp;1 #将<code>stderr</code>并进<code>stdout</code>输出</li>
<li>1&gt;&amp;2 或者 &gt;&amp;2 #将<code>stdout</code>并进<code>stderr</code>输出。</li>
</ul>
<p>于是，前面的错误操作可以改写为:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 1&gt;file.both 2&gt;&amp;1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 2&gt;file.both &gt;&amp;2</span></span><br></pre></td></tr></table></figure></p>
<p>这样，不就皆大欢喜了吗？ ^_^</p>
<p>不过，光解决了同时写入的问题还不够，我们还有其他技巧需要了解的。<br>故事还没有结束，别走开广告后，我们在回来….</p>
<hr>
<h4 id="2-3-I-O重定向与linux中的-dev-null"><a href="#2-3-I-O重定向与linux中的-dev-null" class="headerlink" title="2.3 I/O重定向与linux中的 /dev/null"></a>2.3 I/O重定向与linux中的 /dev/null</h4><hr>
<p>ok，这次不讲I/O Redirection, 请佛吧。</p>
<p>学佛的最高境界，就是<strong>四大皆空</strong>。<br>至于是空哪四大块，我也不知，因为我还没有到那个境界。<br>这个<strong>空</strong>字,却非常值得反复把玩：<strong>色即是空，空即是色</strong><br>好了，施主要是能够领会<strong>空</strong>的禅意，那离修成正果不远了。</p>
<p>在linux的文件系统中，有个设备文件: <code>/dev/null</code>，许多人都问过我，那是什么玩意儿？<br>我跟你说好了，那就是<strong>空</strong>啦。</p>
<p>没错空空如也的空就是null了，请问施主是否忽然有所顿悟了呢？<br>然则恭喜了。</p>
<p>这个null在 I/O Redirection中可有用的很呢？</p>
<ul>
<li>将fd <code>1</code>跟fd <code>2</code>重定向到/dev/null去，就可忽略stdout, stderr的输出。</li>
<li>将fd <code>0</code>重定向到/dev/null，那就是读进空(nothing).</li>
</ul>
<p>比方说，我们在执行一个进程时，会同时输出到stdout与stderr，假如你不想看到stderr(也不想存到文件)， 那就可以：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 2&gt;/dev/null</span></span><br><span class="line">my.file</span><br></pre></td></tr></table></figure></p>
<p>若要相反：只想看到stderr呢？<br>还不简单将stdout，重定向的/dev/null就行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file &gt;/dev/null</span></span><br><span class="line">ls: no.such.file: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>那接下来，假如单纯的只跑进程，而不想看到任何输出呢？<br>哦，这里留了一手，上次没讲的法子,专门赠与有缘人… ^_^<br>除了用 <code>&gt;/dev/null 2&gt;&amp;1</code>之外，你还可以如此：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file &amp;&gt;/dev/null</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Tips:</strong></p>
</blockquote>
<blockquote>
<p>将&amp;&gt;换成&gt;&amp;也行！</p>
</blockquote>
<hr>
<h4 id="2-4-重定向输出append-gt-gt"><a href="#2-4-重定向输出append-gt-gt" class="headerlink" title="2.4 重定向输出append (&gt;&gt;)"></a>2.4 重定向输出append (&gt;&gt;)</h4><hr>
<p>ok？ 请完佛，接下来，再让我们看看如下情况：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"1"</span> &gt; file.out</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file.out</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"2"</span> &gt; file.out</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file.out</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>看来，我们在重定向stdout或stderr进一个文件时，似乎永远只能获得最后一次的重定向的结果，那之前的内容呢？<br>呵呵，要解决这个问题，很简单啦，将<code>&gt;</code>换成<code>&gt;&gt;</code> 就好了；<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"3"</span> &gt;&gt; file.out</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file.out</span></span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>如此一来，被重定向的文件的之前的内容并不会丢失，而新的内容则一直追加在最后面去。so easy?</p>
<p>但是，只要你再次使用<code>&gt;</code>来重定向输出的话，那么，原来文件的内容被truncated(清洗掉)。<br>这是，你要如何避免呢？<br>备份， yes，我听到了，不过，还有更好的吗？<br>既然与施主这么有缘分，老衲就送你一个锦囊妙法吧：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> -o noclobber</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"4"</span> &gt; file.out</span></span><br><span class="line">-bash：file: cannot overwrite existing file.</span><br></pre></td></tr></table></figure></p>
<ul>
<li><blockquote>
<p>那，要如何取消这个限制呢?</p>
</blockquote>
</li>
<li><blockquote>
<p>哦，将<code>set -o</code>换成 <code>set +o</code>就行了：</p>
</blockquote>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> +o noclobber</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"5"</span> &gt; file.out</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file.out</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<ul>
<li><blockquote>
<p>再问：那有办法不取消而又临时改写目标文件吗？</p>
</blockquote>
</li>
<li><blockquote>
<p>哦，佛曰：不可告也。</p>
</blockquote>
</li>
<li><blockquote>
<p>啊，开玩笑的，开玩笑啦^_^，</p>
</blockquote>
</li>
<li><blockquote>
<p>哎，早就料到人心是不足的了</p>
</blockquote>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> -o noclobber</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"6"</span> &gt;| file.out</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file.out</span></span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>留意到没有：</p>
<blockquote>
<p>在<code>&gt;</code>后面加个<code>|</code>就好，注意： <code>&gt;</code>与<code>|</code>之间不能有空白哦。</p>
</blockquote>
<hr>
<h4 id="2-5-I-O-Redirection的优先级"><a href="#2-5-I-O-Redirection的优先级" class="headerlink" title="2.5 I/O Redirection的优先级"></a>2.5 I/O Redirection的优先级</h4><hr>
<p>呼….(深呼吸吐纳一下吧) ^_^ 再来还有一个难题要你去参透呢:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"some text here"</span> &gt;file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; file</span></span><br><span class="line">some text here</span><br><span class="line"><span class="meta">$</span><span class="bash">cat &lt; file &gt;file.bak</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cat &lt; file.bak</span></span><br><span class="line">some text here</span><br><span class="line"><span class="meta">$</span><span class="bash">cat &lt; file &gt;file</span></span><br></pre></td></tr></table></figure></p>
<p>嗯？注意到没有？<br>怎么最后那个cat命令看到file是空的呢？<br>why？ why？ why？</p>
<p>前面提到：<code>$cat &lt; file &gt; file</code>之后，原本有内容的文件，结果却被清空了。<br>要理解这个现象其实不难，这只是priority的问题而已：</p>
<blockquote>
<p>在IO Redirection中, stdout与stderr的管道先准备好，才会从stdin读入数据。<br>也就是说，在上例中，<code>&gt;file</code>会将file清空，然后才读入 <code>&lt; file</code>。<br>但这时候文件的内容已被清空了，因此就变成了读不进任何数据。</p>
</blockquote>
<p>哦，原来如此^_^<br>那…如下两例又如何呢？<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&gt; file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; file &gt;&gt;file</span></span><br></pre></td></tr></table></figure></p>
<p>嗯…同学们，这两个答案就当练习题喽，下课前交作业。</p>
<blockquote>
<p><strong>Tips:</strong><br>我们了解到<code>&gt;file</code>能够快速把文件file清空；<br>或者使用<code>:&gt;file</code>同样可以清空文件，<br><code>:&gt;file</code>与<code>&gt;file</code>的功能：<br>若文件file存在，则将file清空; 否则，创建空文件file (等效于<code>touch file</code>);<br>二者的差别在于<code>&gt;file</code>的方式不一定在所有的shell的都可用。</p>
</blockquote>
<blockquote>
<p><code>exec 5&lt;&gt;file; echo &quot;abcd&quot; &gt;&amp;5; cat &lt;&amp;5</code><br>将file文件的输入、输出定向到文件描述符5，<br>从而描述符5可以接管file的输入输出；<br>因此，<code>cat &lt;&gt;file</code>等价于<code>cat &lt; file</code>。</p>
<p>而<code>cat &lt; file &gt;&gt;file</code>则使file内容成几何级数增长。</p>
</blockquote>
<p>好了， I/O Redirection也快讲完了，<br>sorry,因为我也只知道这么多而已啦嘻^_^<br>不过，还有一样东东是一定要讲的，各位观众(请自行配乐~!#@$%):<br>就是<code>pipe line</code>也。</p>
<hr>
<h4 id="2-6-管道-pipe-line"><a href="#2-6-管道-pipe-line" class="headerlink" title="2.6 管道(pipe line)"></a>2.6 管道(pipe line)</h4><hr>
<p>谈到<code>pipe line</code>，我相信不少人都不会陌生：<br>我们在很多command line上常看到<code>|</code>符号就是pipe line了。</p>
<p>不过，pipe line究竟是什么东东呢？<br>别急别急…先查一下英文字典，看看pipe是什么意思？<br>没错他就是“水管”的意思…<br>那么，你能想象一下水管是怎样一个根接一根的吗？<br>又， 每根水管之间的input跟output又如何呢？<br>灵光一闪：原来pipe line的I/O跟水管的I/O是一模一样的：</p>
<blockquote>
<p>上一个命令的stdout接到下一个命令的stdin去了<br>的确如此。不管在command line上使用了多少个pipe line，前后两个command的I/O是彼此连接的(恭喜：你终于开放了 ^_^ )</p>
</blockquote>
<p>不过…然而…但是… …stderr呢？<br>好问题不过也容易理解：<br>若水管漏水怎么办？<br>也就是说：在pipe line之间, 前一个命令的stderr是不会接进下一个命令的stdin的，其输出，若不用2&gt;file的话，它还是送到monitor显示器上来。<br>这点请你在pipe line运用上务必要注意的。</p>
<p>那，或许你有会问:</p>
<ul>
<li><blockquote>
<p>有办法将stderr也喂进下一个命令的stdin吗？<br>(贪得无厌的家伙)，方法当然是有的，而且，你早已学习过了。<br>提示一下就好：请问你如何将stderr合并进stdout一同输出呢？<br>若你答不出来，下课后再来问我…(如果你脸皮足够厚的话…)</p>
</blockquote>
</li>
</ul>
<p>或许，你仍意犹未尽，或许，你曾经碰到过下面的问题：<br>在<code>cmd1 | cmd2 | cmd3 | ...</code>这段pipe line中如何将cmd2的输出保存到一个文件呢？</p>
<p>若你写成<code>cmd1 | cmd2 &gt;file | cmd3</code>的话，那你肯定会发现<code>cmd3</code>的stdin是空的，(当然了，你都将水管接到别的水池了)<br>聪明的你或许会如此解决：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd1 | cmd2 &gt;file; cmd3 &lt; file</span><br></pre></td></tr></table></figure></p>
<p>是的，你可以这样做，但最大的坏处是：<br>file I/O会变双倍，在command执行的整个过程中，file I/O是最常见的最大效能杀手。<br>凡是有经验的shell操作者，都会尽量避免或降低file I/O的频度。<br>那上面问题还有更好的方法吗？<br>有的，那就是<code>tee</code>命令了。<br>所谓的<code>tee</code>命令是在不影响原本I/O的情况下，将stdout赋值到一个文件中去。<br>因此，上面的命令行，可以如此执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd1 | cmd2 | tee file | cmd3</span><br></pre></td></tr></table></figure></p>
<p>在预设上，<code>tee</code>会改写目标文件，若你要改为追加内容的话，那可用-a参数选项。<br>基本上，pipe line的应用在shell操作上是非常广泛的。<br>尤其是在text filtering方面，如，cat, more, head, tail, wc, expand, tr, grep, sed, awk…等等文字处理工具。<br>搭配起pipe line 来使用，你会觉得 command line原来活得如此精彩的。<br>常让人有“众里寻他千百度，蓦然回首，那人却在灯火阑珊处”之感。</p>
<p>好了，关于I/O Redirection的介绍就到此告一段落。<br>若日后，有空的话，在为大家介绍其他在shell上好玩的东西。</p>
<h2 id="shell十五问之12：你要if还是case呢？"><a href="#shell十五问之12：你要if还是case呢？" class="headerlink" title="shell十五问之12：你要if还是case呢？"></a>shell十五问之12：你要if还是case呢？</h2><hr>
<p>还记得我们在第10章所介绍的<code>return value</code>吗？</p>
<p>是的，接下来的介绍的内容与之有关，若你的记忆也被假期所抵消的话，那建议您还是回去温习温习再回来。</p>
<p>若你记得<code>return value</code>，我想你也应该记得了<code>&amp;&amp;</code> 与 <code>||</code> 什么意思吧?<br>用这两个符号再搭配 command group的话，我们可让shell script变得更加聪明哦。<br>比方说：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmd1 <span class="meta">&amp;&amp; &#123;</span></span><br><span class="line">    cmd2</span><br><span class="line">        cmd3</span><br><span class="line">        ;</span><br><span class="line">&#125; <span class="string">|| &#123;</span></span><br><span class="line">        cmd4</span><br><span class="line">        cmd5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>意思是说：<br>若 cmd1的<code>return value</code>为true的话，然后执行cmd2与cmd3，否则执行cmd4与cmd5。</p>
<p>事实上， 我们在写shell script的时候，经常需要用到这样、那样的条件以作出不同的处理动作。<br>用<code>&amp;&amp;</code>与<code>||</code>的确可以达成条件执行的结果，然而，从“人类语言”上来理解，却不是那么直观。<br>更多时候，我们还是喜欢用<code>if...then...else...</code>这样的的keyword来表达条件执行。</p>
<p>在bash shell中，我们可以如此修改上一段代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cmd1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        cmd2                                                                                                                               </span><br><span class="line">        cmd3                                                                                                                               </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        cmd4                                                                                                                               </span><br><span class="line">        cmd5                                                                                                                               </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>这也是我们在shell script中最常用的<code>if</code>判断式：</p>
<blockquote>
<p>只要<code>if</code>后面的command line返回true的return value<br>(我们常用<code>test</code>命令返回的return value)，然则就执行<code>then</code>后面的命令，否则，执行<code>else</code>之后的命令， <code>fi</code>则是用来结束判断式的keyword。</p>
</blockquote>
<blockquote>
<p>在<code>if</code>的判断式中，<code>else</code>部分可以不用，但<code>then</code>是必需的。<br>(若<code>then</code>后不想跑任何command，可用<code>:</code>这个<code>null command</code>代替)。<br>当然，then或else后面，也可以再使用更进一层的条件判断式，这在shell script的设计上很常见。<br>若有多项条件需要”依序”进行判断的话，那我们则可使用<code>elif</code>这样的keyword：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cmd1; <span class="keyword">then</span>                                                                                                                              </span><br><span class="line">    cmd2;</span><br><span class="line"><span class="keyword">elif</span> cmd3; <span class="keyword">then</span>                                                                                                                            </span><br><span class="line">        cmd4                                                                                                                               </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        cmd5                                                                                                                               </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>意思是说：</p>
<blockquote>
<pre><code>若cmd1为true，然则执行cmd2；
否则在测试cmd3，若为true则执行cmd4；
倘若cmd1与cmd3均不成立，那就执行cmd5。
</code></pre></blockquote>
<p><code>if</code>判断式的例子很常见，你可从很多shell script中看得到，我这里不再举例子了。</p>
<p>接下来为要为大家介绍的是<code>case</code>判断式。<br>虽然<code>if</code>判断式已可应付大部分的条件执行了，然而，在某些场合中，却不够灵活，尤其是在string式样的判断上，<br>比方如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">QQ</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"Do you want to continue? (Yes/No): "</span>                                                                                          </span><br><span class="line">        <span class="built_in">read</span> YN                                                                                                                            </span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$YN</span>"</span> = Y -o <span class="string">"<span class="variable">$YN</span>"</span> = y -o <span class="string">"<span class="variable">$YN</span>"</span> = <span class="string">"Yes"</span> -o <span class="string">"<span class="variable">$YN</span>"</span> = <span class="string">"yes"</span> -o <span class="string">"<span class="variable">$YN</span>"</span> = YES]                                                      </span><br><span class="line">        <span class="keyword">then</span>                                                                                                                               </span><br><span class="line">                QQ                                                                                                                         </span><br><span class="line">        <span class="keyword">else</span>                                                                                                                               </span><br><span class="line">                <span class="built_in">exit</span> 0                                                                                                                     </span><br><span class="line">        <span class="keyword">fi</span>                                                                                                                                 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QQ</span><br></pre></td></tr></table></figure></p>
<p>从例中，我们看得出来，最麻烦的部分是在判断YN的值可能有好几种样式。</p>
<p>聪明的你或许会如此修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="title">QQ</span></span>() &#123;</span><br><span class="line">        <span class="built_in">echo</span> -n <span class="string">"Do you want to continue? (Yes/No): "</span>                                                                                      </span><br><span class="line">        <span class="built_in">read</span> YN                                                                                                                            </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">"<span class="variable">$YN</span>"</span> | grep -q <span class="string">'^[Yy]\([Ee][Ss]\)*$'</span>                                                                                      </span><br><span class="line">        <span class="keyword">then</span>                                                                                                                               </span><br><span class="line">                QQ                                                                                                                         </span><br><span class="line">        <span class="keyword">else</span>                                                                                                                               </span><br><span class="line">                <span class="built_in">exit</span> 0                                                                                                                     </span><br><span class="line">        <span class="keyword">fi</span>                                                                                                                                 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QQ</span><br></pre></td></tr></table></figure></p>
<p>也就是用<code>Regular Expression</code>来简化代码。<br>(我们有机会，再来介绍<code>RE</code>)<br>只是…是否有其他更方便的方法呢？有的，就是用<code>case</code>判断式即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="title">QQ</span></span>() &#123;                                                                                                                                    </span><br><span class="line">        <span class="built_in">echo</span> -n <span class="string">"Do you want to continue? (Yes/No): "</span>                                                                                      </span><br><span class="line">        <span class="built_in">read</span> YN                                                                                                                            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">"<span class="variable">$YN</span>"</span> <span class="keyword">in</span>                                                                                                                      </span><br><span class="line">                [Yy]|[Yy][Ee][Ss])                                                                                                         </span><br><span class="line">                        QQ                                                                                                                 </span><br><span class="line">                        ;;                                                                                                                 </span><br><span class="line">                *)                                                                                                                         </span><br><span class="line">                        <span class="built_in">exit</span> 0                                                                                                             </span><br><span class="line">                        ;;                                                                                                                 </span><br><span class="line">        <span class="keyword">esac</span>                                                                                                                               </span><br><span class="line">&#125;                                                                                                                                          </span><br><span class="line">                                                                                                                                           </span><br><span class="line">QQ</span><br></pre></td></tr></table></figure></p>
<p>我们常用的<code>case</code>的判断式来判断某一变量在不同的值(通常是string)时，作出不同的处理，比方说，判断script参数，以执行不同的命令。<br>若你有兴趣，且用linux系统的话，不妨挖一挖<code>/etc/init.d/*</code>中的那堆script中的<code>case</code>用法。<br>如下就是一例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span>                                                                                                                               </span><br><span class="line">        start)                                                                                                                             </span><br><span class="line">                start                                                                                                                      </span><br><span class="line">                ;;                                                                                                                         </span><br><span class="line">        stop)                                                                                                                              </span><br><span class="line">                stop                                                                                                                       </span><br><span class="line">                ;;                                                                                                                         </span><br><span class="line">        status)                                                                                                                            </span><br><span class="line">                rhstatus                                                                                                                   </span><br><span class="line">                ;;                                                                                                                         </span><br><span class="line">        restart|reload)                                                                                                                    </span><br><span class="line">                restart                                                                                                                    </span><br><span class="line">                ;;                                                                                                                         </span><br><span class="line">        condrestart)                                                                                                                       </span><br><span class="line">                [ -f /var/lock/subsys/syslog ] &amp;&amp; restart || :                                                                             </span><br><span class="line">                ;;                                                                                                                         </span><br><span class="line"></span><br><span class="line">        *)</span><br><span class="line">                <span class="built_in">echo</span> $<span class="string">"Usage: <span class="variable">$0</span> &#123;start|stop|status|restart|condrestart&#125;"</span>                                                                  </span><br><span class="line">                <span class="built_in">exit</span> 1                                                                                                                     </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p>
<p>(若你对 postional parameter的印象已经模糊了，请重看第9章吧。)</p>
<h2 id="shell十五问之13：-for-what？-while与until差在哪？"><a href="#shell十五问之13：-for-what？-while与until差在哪？" class="headerlink" title="shell十五问之13： for what？ while与until差在哪？"></a>shell十五问之13： for what？ while与until差在哪？</h2><hr>
<p>现在要介绍的是shell script设计中常见的<code>循环</code>(<code>loop</code>)，所谓的<code>loop</code>就是script中的一段在一定条件下反复执行的代码。</p>
<p>bash shell中常用的<code>loop</code>有如下三种：</p>
<ul>
<li>for</li>
<li>while</li>
<li>until</li>
</ul>
<h3 id="1-for-loop"><a href="#1-for-loop" class="headerlink" title="1. for loop"></a>1. for loop</h3><hr>
<p><code>for</code> loop 是从一个清单列表中读进变量的值，并依次的循环执行<code>do</code>到<code>done</code>之间的命令行。<br>例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> one two three four five                                                                                                         </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -----------------                                                                                                                 </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'$var is '</span><span class="variable">$var</span>                                                                                                                </span><br><span class="line">        <span class="built_in">echo</span>                                                                                                                               </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>上例的执行结果将会是：</p>
<blockquote>
<ol>
<li>for会定义一个叫var的变量，其值依次是one two three four five。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>因为有5个变量值，因此，<code>do</code>与<code>done</code>之间的命令行会被循环执行5次。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>每次循环均用<code>echo</code>产生3个句子。而第二行中不在hard quote之内的$var会被替换。</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>当最后一个变量值处理完毕，循环结束。</li>
</ol>
</blockquote>
<p>我们不难看出，在<code>for</code> loop中，变量值的多寡，决定循环的次数。<br>然而，变量在循环中是否使用则不一定，得视设计需求而定。<br>倘若<code>for</code> loop没有使用in这个keyword来制变量清单的话，其值将从<code>$@</code>(或<code>$*</code>)中继承：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var; <span class="keyword">do</span></span><br><span class="line">        ......                                                                                                                             </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Tips:</strong></p>
</blockquote>
<blockquote>
<p>若你忘记了`positional parameter, 请温习第9章…</p>
</blockquote>
<p><code>for</code> loop用于处理清单(list)项目非常方便，其清单除了明确指定或从<code>postional parameter</code>取得之外，也可以从<code>变量替换</code>或者<code>命令替换</code>取得。<br>(再一次提醒：别忘了命令行的“重组”特性)<br>然而，对于一些“累计变化”的项目(整数的加减)，for也能处理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i = 1; i &lt;= 10; i++))                                                                                                                </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"num is <span class="variable">$i</span>"</span>                                                                                                                   </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-while-loop"><a href="#2-while-loop" class="headerlink" title="2. while loop"></a>2. while loop</h3><hr>
<p>除了<code>for</code> loop, 上面的例子，我们也可改用<code>while</code> loop来做到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$num</span>"</span> -le 10 ]; <span class="keyword">do</span>                                                                                                                </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"num is <span class="variable">$num</span>"</span>                                                                                                                 </span><br><span class="line">        num=$((<span class="variable">$num</span> + 1))                                                                                                                  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p><code>while</code> loop的原理与<code>for</code> loop稍有不同：<br>它不是逐次处理清单中的变量值，而是取决于<code>while</code> 后面的命令行的return value：</p>
<ul>
<li>若为true， 则执行<code>do</code>与<code>done</code>之间的命令，然后重新判断<code>while</code>后的return value。</li>
<li>若为false，则不再执行<code>do</code>与<code>done</code>之间的命令而结束循环。</li>
</ul>
<p>分析上例：</p>
<blockquote>
<ol>
<li>在<code>while</code>之前，定义变量num=1。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>然后测试(<code>test</code>)$num是否小于或等于10。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>结果为true，于是执行<code>echo</code>并将num的值加1。</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>再作第二轮测试，此时num的值为1+1=2，依然小于或等于10，因此，为true，循环继续。</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>直到num为10+1=11时，测试才会失败…于是结束循环。</li>
</ol>
</blockquote>
<p>我们不难发现：</p>
<blockquote>
<p>若<code>while</code>的测试结果永远为true的话，那循环将一直永久执行下去：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>:; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> looping...                                                                                                                    </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>上面的<code>:</code>是bash的null command，不做任何动作，除了返回true的return value。<br>因此这个循环不会结束，称作死循环。<br>死循环的产生有可能是故意设计的(如跑daemon)，也可能是设计的错误。<br>若要结束死循环，可通过signal来终止(如按下ctrl-c)，<br>(关于process与signal，等日后有机会再补充，十五问略过。)</p>
<h3 id="3-until-loop"><a href="#3-until-loop" class="headerlink" title="3.until loop"></a>3.until loop</h3><hr>
<p>一旦你能够理解<code>while</code> loop的话，那就能理解<code>until</code> loop:<br>与<code>while</code>相反， <code>until</code>是在return value 为false时进入循环，否则，结束。<br>因此，前面的例子，我们也可以轻松的用<code>until</code>来写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line">until [ ! <span class="string">"<span class="variable">$num</span>"</span> -le 10 ]; <span class="keyword">do</span>                                                                                                              </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"num is <span class="variable">$num</span>"</span>                                                                                                                 </span><br><span class="line">        num=$((<span class="variable">$num</span> + 1))                                                                                                                  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line"></span><br><span class="line">until [ <span class="string">"<span class="variable">$num</span>"</span> -gt 10 ]; <span class="keyword">do</span>                                                                                                                </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"num is <span class="variable">$num</span>"</span>                                                                                                                 </span><br><span class="line">        num=$((<span class="variable">$num</span> + 1))                                                                                                                  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>ok, 关于bash的三个常用的loop暂时介绍到这里。</p>
<h3 id="4-shell-loop中的break与continue"><a href="#4-shell-loop中的break与continue" class="headerlink" title="4. shell loop中的break与continue"></a>4. shell loop中的break与continue</h3><hr>
<p>在结束本章之前，再跟大家补充两个loop有关的命令：</p>
<ul>
<li><code>break</code></li>
<li><code>continue</code></li>
</ul>
<p>这两个命令常用在复合式循环里，也就是<code>do ... done</code>之间又有更进一层的loop，当然，用在单一循环中也未尝不可啦… ^_^<br><code>break</code>用来中断循环，也就是强迫结束循环。<br>若<code>break</code>后面指定一个数值n的话，则从里向外中断第n个循环，预设值为 <code>break 1</code>，也就是中断当前循环。<br>在使用break时，需要注意的是，它与<code>return</code>及<code>exit</code>是不同的：</p>
<ul>
<li><code>break</code>是结束loop；</li>
<li><code>return</code>是结束function；</li>
<li><code>exit</code>是结束script/shell;</li>
</ul>
<p>而<code>continue</code>则与<code>break</code>相反：强迫进入下一次循环动作。<br>若你理解不来的话，那你可简单的看成：<br>在<code>continue</code>在<code>done</code>之间的句子略过而返回到循环的顶端。<br>与<code>break</code>相同的是：<code>continue</code>后面也可以指定一个数值n，以决定继续哪一层(从里往外计算)的循环，预设值为 <code>continue 1</code>,也就是继续当前的循环。<br>在shell script设计中，若能善用loop，将能大幅度提高script在复杂条件下的处理能力。<br>请多加练习吧…^_^</p>
<h2 id="shell十五问之14-跟-差在哪？-wildcard-通配符篇。"><a href="#shell十五问之14-跟-差在哪？-wildcard-通配符篇。" class="headerlink" title="shell十五问之14: [^ ] 跟[! ]差在哪？ (wildcard)通配符篇。"></a>shell十五问之14: [^ ] 跟[! ]差在哪？ (wildcard)通配符篇。</h2><hr>
<p>这个题目说穿了，就是要探讨Wildcard（通配符）与Regular Expression（正则表达式）的差别的。<br>这也是很多初学shell的朋友很容易混淆的地方。<br>首先，让我们回到十五问之第2问，再一次将我们提到的command line format 温习一次：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command_name options arguments</span><br></pre></td></tr></table></figure>
<p>同时，也再来理解一下，我在第5章所提到的变量替换的特性：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先替换，再重组 command line!</span><br></pre></td></tr></table></figure></p>
<p>有了这个两个基础后，再让我们来看Wildcard是什么回事吧。</p>
<h3 id="1-Wildcard-（通配符）"><a href="#1-Wildcard-（通配符）" class="headerlink" title="1.Wildcard （通配符）"></a>1.Wildcard （通配符）</h3><hr>
<p>首先<code>Wildcard</code> 也是属于 <code>command line</code> 的处理工序，作用于 <code>arguments</code> 里的 <code>path</code> 之上。<br>没错，它不用在<code>command_name</code>，也不用在<code>options</code>上。<br>而且，若argument不是path的话，那也与wildcard无关。<br>换句更为精确的定义来讲，<code>wildcard</code>是一种命令行的路径扩展(path expansion)功能。<br>提到这个扩展，那就不要忘了command line的重组特性了！<br>是的，这与<code>变量替换</code>(variable subtitution)及<code>命令替换</code>(command substitution)的重组特性是一样的。<br>也就是在<code>wildcard</code>进行扩展后，命令行会先完成重组，才会交给shell来处理。<br>了解了<code>wildcard</code>的扩展与重组特性后，接下来，让我们了解一些常见的wildcard通配符吧。 </p>
<table>
<thead>
<tr>
<th>wildcard</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配0个或多个字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意单一字符</td>
</tr>
<tr>
<td>[list]</td>
<td>匹配list中任意单一字符</td>
</tr>
<tr>
<td>[!list]</td>
<td>匹配不在list中任意单一字符</td>
</tr>
<tr>
<td>{string1,string2,…}</td>
<td>匹配string1或者stsring2或者(…)中其一字符串</td>
</tr>
</tbody>
</table>
<p>Note:</p>
<blockquote>
<p> list 中可以指定单个字符，如abcd, 也可以指定ASCII字符的起止范围，如 a-d。<br> 即[abcd] 与 [a-d] 是等价的，称为一个自定义的字符类。</p>
</blockquote>
<p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a*b     # a 与 b 之间可以有任意个字符（0个或多个），如aabcb, axyzb, a012b,ab等。</span><br><span class="line">a?b     # a 与 b 之间只能有一个字符，但该字符可以任意字符，如 aab, abb, acb, azb等。</span><br><span class="line">a[xyz]b # a 与 b 之间只能有一个字符，但这个字符只能是x或者y或者z，如：axb, ayb, azb这三个。</span><br><span class="line">a[!0-9]b# a 与 b 之间只能有一个字符，但这个字符不能是阿拉伯数字，如aab，ayb，a-b等。</span><br><span class="line">a&#123;abc,xyz,123&#125;b # a 与 b之间只能是abc或者xyz或者123这三个字串之一，扩展后是aabcb，axyzb，a123b。</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p><code>[! ]</code> 中的<code>!</code> 只有放在第一位时，才有取反的功效。<br>举例:<br> <code>[!a]*</code> 表示当前目录下不以<code>a</code>开头的路径名称；<br> <code>/tmp/[a\!]*</code>表示/tmp目录下所有以<code>a</code> 或者 <code>!</code> 开头的路径名称；</p>
<p> 思考：为何<code>!</code>前面要加<code>\</code>呢？</p>
</li>
<li><p><code>[ - ]</code>中<code>-</code>左右两边均有字符时，才表示一个范围，否则,仅作<code>-</code>(减号)字符来处理。<br>举例：<br> <code>/tmp/*[-z]/[a-zA-Z]*</code> 表示/tmp目录下所有以<code>z</code>或者<code>-</code>结尾的子目录中，以英文字母(不分大小写)开头的目录名称。</p>
</li>
<li><p>以*或?开头的wildcard不能匹配隐藏文件(即以.开头的文件名)。<br>举例:<br> <code>*.txt</code>并不能匹配<code>.txt</code>但能匹配1.txt这样的路径名。<br> 但<code>1*txt</code>及<code>1?txt</code>均可匹配1.txt这样的路径名。</p>
</li>
</ol>
<p>基本上，要掌握wildcard并不难，只要多加练习，再勤于思考，就能灵活运用了。</p>
<p><strong>再次提醒：</strong></p>
<blockquote>
<p>别忘了wildcard的”扩展” + “重组” 这个重要特性，而且只作用在 argument的path上。</p>
</blockquote>
<p>比方说，假如当前目录下有：a.txt b.txt c.txt 1.txt 2.txt 3.txt 这几个文件。<br>当我们在命令行中执行<code>ls -l [0-9].txt</code>的命令行时，因为wildcard处于argument的位置上，于是根据匹配的路径，扩展为: 1.txt 2.txt 3.txt，在重组出<code>ls -l 1.txt 2.txt 3.txt</code> 这样的命令行。<br>因此，你在命令行上敲 <code>ls -l [0-9].txt</code> 与 <code>ls -l 1.txt 2.txt 3.txt</code> 输出的结果是一样，原因就是在于此。</p>
<h2 id="shell十五问之15-跟-差在哪？-RE-Regular-Expression）正则表达式篇"><a href="#shell十五问之15-跟-差在哪？-RE-Regular-Expression）正则表达式篇" class="headerlink" title="shell十五问之15: [^ ] 跟[! ]差在哪？ (RE: Regular Expression）正则表达式篇"></a>shell十五问之15: [^ ] 跟[! ]差在哪？ (RE: Regular Expression）正则表达式篇</h2><hr>
<h3 id="2-Regular-Expression-正则表达式"><a href="#2-Regular-Expression-正则表达式" class="headerlink" title="2.Regular Expression (正则表达式)"></a>2.Regular Expression (正则表达式)</h3><hr>
<p>接下来的Regular Expression(RE) 可是个大题目，要讲的很多。<br>我这里当然不可能讲得很全。<br>只希望能带给大家一个基本的入门概念，就很足够了。<br>先来考一下英文好了：What is expression?<br>简单来说，就是<strong>表达</strong>，也就是人们在沟通的时候所要陈述的内容。<br>然而，生活中，表达方要清楚的将意思描述清楚，而让接收方完整无误地领会，可不是件容易的事情。<br>因而才会出现那么多的误会, 真可叹句表达不易啊。<br>同样的情形也发生在计算机的数据处理过程中，尤其是当我们在描述一段文字内容的时候。<br>那么，我们不禁要问：<br>有何方法可以让大家的误会降至最低程度，而让表达的精确度达到最高程度呢？<br>答案就是<strong>标准化</strong>了，也就是我们这里要谈的<code>Regular Expression</code>啦…^_^<br>然而，在进入<code>RE</code>介绍之前，不妨先让我们温习一下shell十五问之第4问，那就是关于quoting的部分。<br><strong>关键是要能够区分 shell command line上的meta与literal的这两种不同的字符类型</strong>。<br>然后，我这里也跟你讲：</p>
<blockquote>
<p>RE 表达式里字符也分meta与literal这两种。</p>
</blockquote>
<p>呵，不知亲爱的读者是否被我搞混乱了呢？… ^_^<br>这也难怪啦，因为这的确是最容易混淆的地方，刚学<code>RE</code>的朋友很多时候，都死在这里！<br>因此，请特别小心理解哦。<br>简单而言，除非你将<code>RE</code>写在特定程序使用的脚本里，否则，我们的<code>RE</code>也是通过 command line输入的。<br>然而，<strong>不少RE所使用的meta字符，跟shell 的meta字符是冲突的</strong>。<br>比方说，<strong><code>*</code>这个字符，在RE里是一个modifier(修饰符);而在command line上，确是wildcard(通配符)</strong>。<br>那么，我们该如何解决这样的冲突呢？<br>关键就是看你对shell十五问的第4问中所提的quoting是否足够理解了！<br>若你明白<strong>shell quoting 就是用来在command line上关闭shell meta这一基本原理</strong>，那你就能很轻松的解决 RE meta与shell meta的冲突问题了：</p>
<blockquote>
<p>用shell quoting 关闭掉shell meta就是了。<br>就这么简单… ^_^<br>再以刚提到<code>*</code>字符为例，若在command line的path中没有quoting处理的话，如abc* 就会被作为wildcard expression来扩充及重组了。<br>若将其置于quoting中，即”abc*“，则可以避免wildcard expand的处理。</p>
</blockquote>
<p>好了，说了大半天，还没有进入正式的RE介绍呢。<br>大家别急，因为我的教学风格就是要先建立基础，循序渐进的… ^_^<br>因此, 我这里还要再啰嗦一个观念，才会到RE的说明啦…(哈…别打我…)</p>
<p>当我们在谈到RE时，千万别跟wildcard搞混在一起！<br>尤其是在command line的位置里，wildcard只作用于argument的path上；<br>而RE却只用于字符串处理的程序中，这与路径名一点关系也没有。</p>
<blockquote>
<p> <strong>Tips:</strong><br> RE 所处理的字符串，通常是指纯文本或通过stdin读进的内容。</p>
</blockquote>
<p>ok，够了够了，我已看到一堆人开始出现不耐烦的样子了… ^<em>^<br>现在，就让我们登堂入室，揭开RE的神秘面纱吧，这样可以放过我了吧？ 哈哈…^</em>^</p>
<p>在RE的表达式里，主要分为两种字符：<code>literal</code>与<code>meta</code>。<br>所谓<code>literal</code>就是在RE里不具有特殊功能的字符，如abc，123等；<br>而<code>meta</code>,在RE里具有特殊的功能。<br>要关闭之，需要在<code>meta</code>之前使用escape(<code>\</code>)转义字符。</p>
<p>然而，在介绍<code>meta</code>之前，先让我们来认识一下字符组合(character set)会更好些。<br>一、所谓的char set就是将多个连续的字符作为一个集合。<br>如 abc|xyz 表示abc或xyz这连个char set之一。<br>其它含义如下：</p>
<table>
<thead>
<tr>
<th>char set</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>abc</td>
<td>表示abc三个连续的字符，但彼此独立而非集合。(可简单视为三个char set)</td>
</tr>
<tr>
<td>(abc)</td>
<td>表示abc这三个连续字符的集合。(可简单视为一个char set)</td>
</tr>
<tr>
<td>[abc]</td>
<td>表示单一字符，可为a或b或c;与wildcard的[abc]原理相同，称之为字符类。</td>
</tr>
<tr>
<td>[^abc]</td>
<td>表示单一字符，不为a或b或c即可。(与wildcard [!abc]原理相同)</td>
</tr>
<tr>
<td>.</td>
<td>表示任意单个字符，(与wildcard的?原理相同)</td>
</tr>
</tbody>
</table>
<p>在认识了RE的char set这个概念之后，然后，在让我们多认识几个RE中常见的meta字符：</p>
<p>二、 锚点(anchor): 用以标识RE在句子中的位置所在。<br>常见的有：  </p>
<table>
<thead>
<tr>
<th>锚点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>表示句首。如，^abc表示以abc开头的句子。</td>
</tr>
<tr>
<td>$</td>
<td>表示句尾。如，abc$表示以abc结尾的句子。</td>
</tr>
<tr>
<td>\&lt;</td>
<td>表示词首。如，\&lt;abc表示以abc开头的词。</td>
</tr>
<tr>
<td>></td>
<td>表示词尾。如，abc>表示以abc结尾的词。</td>
</tr>
</tbody>
</table>
<p>三、 修饰符(modifier)：独立表示时本身不具意义，专门用以修饰前一个char set出现的次数。<br>常见的有：</p>
<table>
<thead>
<tr>
<th>modifier</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>表示前一个char set出现0次或多次，即任意次。如ab*c表示a与c之间可以有0个或多个b。</td>
</tr>
<tr>
<td>?</td>
<td>表示前一个char set出现0次或1次，即至多出现1次。如ab?c 表示a与c之间可以有0个或1个b。</td>
</tr>
<tr>
<td>+</td>
<td>表示前一个char set出现1次或多次，即至少出现1次。如ab+c 表示a与c之间可以有1个或多个b。</td>
</tr>
<tr>
<td>{n}</td>
<td>表示前一个char set出现n次。如ab{n}c 表示a与c之间可以有n个b。</td>
</tr>
<tr>
<td>{n, }</td>
<td>表示前一个char set至少出现n次。如ab{n}c 表示a与c之间至少有n个b。</td>
</tr>
<tr>
<td>{n, m}</td>
<td>表示前一个char set至少出现n次，至多出现m次。如ab{n，m}c 表示a与c之间至少有n个b，至多有m个b。</td>
</tr>
</tbody>
</table>
<p>然而，当我们在识别modifier时，却很容易忽略”边界(boundary)字符”的重要性。</p>
<p>以<code>ab{3,5}c</code>为例，这里的a与c就是边界字符了。<br>若没有边界字符的帮忙，我们很容易做出错误的解读。<br>比方说: 我们用<code>ab{3,5}</code>这个RE（少了c这个边界字符)<br>可以抓到”abbbbbbbbbb”(a后面有10个b)的字符串吗？<br>从刚才的modifier的说明，我们一般认为，我们要的b是3到5个，若超出了此范围，就不是我们所要表达的。<br>因此，我们或许会很轻率地认为这个RE抓不到结果（上述”abbbbbbbbbb”字符串）。</p>
<p>然而，答案却是可以的！为什么呢？<br>让我们重新解读<code>ab{3,5}</code>这个RE看看：<br>我们要表达的是a后接3到5个b即可，但3到5个b后面，我们却没有规定什么，因此，在RE后面可以是任意的字符串，当然包括b也可以啦！(明白了吗？)</p>
<p>同样，我们用<code>b{3,5}c</code>也同样可以抓到”abbbbbbbbbbc”这样的字符串。</p>
<p>但当我们用<code>ab{3,5}c</code>这样的RE时，由于同时有a与c这连个边界字符，就截然不同了！</p>
<p>有空在思考一下，为何我们用下面这些RE都抓到abc这样的字符串呢？<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x*</span><br><span class="line">ax*, abx*, ax<span class="number">*b</span></span><br><span class="line">abcx*, abx<span class="number">*c</span>, ax<span class="number">*bc</span></span><br><span class="line">bx<span class="number">*c</span>, bcx*, x<span class="number">*bc</span></span><br></pre></td></tr></table></figure></p>
<p>但, 若我们在这些RE前后分别加<code>^</code>与<code>$</code>这样的anchor，那又如何呢？</p>
<p>刚学RE时，只要能掌握上面这些基本的meta的大概就可以入门了。<br>一如前述，RE是一种规范化的文字表达式，<br>主要用于某些文字处理工具之间，如：<br><code>grep</code>， <code>perl</code>， <code>vi</code>，<code>awk</code>，<code>sed</code>，等等，常用于表示一段连续的字符串，查找和替换。</p>
<p>然而每种工具对RE表达式的具体解读或有一些细微差别，不过原理还是一致的。<br>只要掌握RE的基本原理，那就一理通百理了，只是在实践时，稍加变通即可。</p>
<p>比方以<code>grep</code>来说，在<code>Linux</code>上，你可以找到<code>grep</code>，<code>egrep</code>，<code>fgrep</code>这些程序，其差异大致如下：</p>
<p>grep： 传统的grep程序，在没有任何选项(options)的情况下，只输出符合RE字串的句子，<br> 其常见的选项如下：</p>
<table>
<thead>
<tr>
<th>选项 (option)</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>反模式，  只输出“不含”RE的字符串的行。</td>
</tr>
<tr>
<td>-r</td>
<td>　递归模式，可同时处理所有层级的子目录里的文件</td>
</tr>
<tr>
<td>-q</td>
<td>静默模式，不输出任何结果(stderr 除外，常用于获取return value，符合为true，否则，为false.</td>
</tr>
<tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>-w</td>
<td>整词匹配，类似 \&lt;RE></td>
</tr>
<tr>
<td>-n</td>
<td>同时输出行号</td>
</tr>
<tr>
<td>-l</td>
<td>输出匹配RE的文件名</td>
</tr>
<tr>
<td>-o</td>
<td>只输出匹配RE的字符串。(gna新版独有，不见得所有版本支持)</td>
</tr>
<tr>
<td>-E</td>
<td>切换为egrep</td>
</tr>
</tbody>
</table>
<p>egrep：为grep的扩充版本，改良了许多传统grep不能或者不便的操作，</p>
<ul>
<li>grep下不支持<code>?</code>与<code>+</code>这两种meta，但egrep支持；</li>
<li>grep 不支持<code>a|b</code>或（<code>abc|xyz</code>）这类“或一”的匹配，但egrep支持；</li>
<li>grep 在处理<code>{n,m}</code>时，需要\{ 与 \}处理，但egrep不需。</li>
</ul>
<p>等诸如此类的。我个人建议能用<code>egrep</code>就不用<code>grep</code>啦…^_^</p>
<p>fgrep: 不作RE处理，表达式仅作一般的字符串处理，所有的meta均市区功能。</p>
<p>好了，关于RE的入门，我们暂时就介绍到这里。<br>虽然有点乱，且有些观念也不恨精确，不过，姑且算是对大家的一个交差吧…^_^<br>若这两天有时间的话，我在举些范例来分析一下，以帮助大家更好的理解。<br>假如更有可能的话，也顺道为大家介绍一下<code>sed</code>这个工具。</p>
<hr>
<h3 id="3-eval"><a href="#3-eval" class="headerlink" title="3.eval"></a>3.eval</h3><hr>
<p>讲到command line的重组特性，真的需要我们好好的加以解释的。</p>
<p>如此便能抽丝剥茧的一层层的将整个command line分析的一清二楚，而不至于含糊。</p>
<p>假如这个重组的特性理解了，那我们介绍一个好玩的命令：<code>eval</code>。</p>
<p>我们在变量替换的过程中，常会碰到所谓的复式变量的问题：<br>如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ a=1</span><br><span class="line">$ A1=abc</span><br></pre></td></tr></table></figure></p>
<p>我们都知道<code>echo $A1</code>就可以得到abc的结果。<br>然而，我们能否用$A$a来取代$A1，而同一样替换为abc呢？</p>
<p>这个问题我们可用很轻松的用<code>eval</code>来解决：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> <span class="built_in">echo</span> \<span class="variable">$A</span><span class="variable">$a</span></span><br></pre></td></tr></table></figure></p>
<p>说穿了，<code>eval</code> 只不过是在命令行完成替换重组后，在来一次替换重组罢了。就是这么简单啦^_^</p>
<hr>
<h2 id="加餐：一个能让系统shell崩溃的shell-片段"><a href="#加餐：一个能让系统shell崩溃的shell-片段" class="headerlink" title="加餐：一个能让系统shell崩溃的shell 片段"></a>加餐：一个能让系统shell崩溃的shell 片段</h2><hr>
<p>一个能让系统shell崩溃的shell 片段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:() &#123; :|:&amp; &#125;; :      <span class="comment"># &lt;--- 这个别乱跑！好奇会死人的！</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'十人|日一|十十o'</span> | sed <span class="string">'s/.../&amp;\n/g'</span>   <span class="comment"># &lt;--- 跟你讲就不听，再跑这个就好了。</span></span><br></pre></td></tr></table></figure>
<p>原来是一个bash的fork炸弹：ref：<a href="http://en.wikipedia.org/wiki/Fork_bomb" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Fork_bomb</a></p>
<p>整理后的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:() &#123;</span><br><span class="line">  </span><br><span class="line">  :|:&amp;</span><br><span class="line">&#125;</span><br><span class="line">:</span><br></pre></td></tr></table></figure></p>
<p>代码分析：</p>
<blockquote>
<p>定义了一个 shell 函数，函数名是<code>:</code>，而这个函数体执行一个后台命令<code>:|:</code> 即冒号命令(或函数，下文会解释)的输出通过管道再传给冒号命令做输入。<br>最后一行执行“:”命令在各种shell中运行结果分析：<br>这个代码只有在 <strong>bash</strong> 中执行才会出现不断创建进程而耗尽系统资源的严重后果;<br>在 ksh (Korn shell), sh (Bourne shell)中并不会出现，在 ksh88 和传统 unix Bourne shell 中冒号不能做函数名，即便是在 unix-center freebsd 系统中的 sh 和 pdksh（ksh93 手边没有，没试）中冒号可以做函数名，但还是不会出现那个效果。<br>原因是 sh、ksh 中内置命令的优先级高于函数，所以执行“:”，总是执行内置命令“:”而不是刚才定义的那个恐怖函数。<br>但是在 <strong>bash</strong> 中就不一样，bash 中函数的优先级高于内置命令，所以执行“:”结果会导致不断的递归，而其中有管道操作，这就需要创建两个子进程来实现，这样就会不断的创建进程而导致资源耗尽。</p>
</blockquote>
<p>众所周知，bash是一款极其强大的shell，提供了强大的交互与编程功能。<br>这样的一款shell中自然不会缺少“函数”这个元素来帮助程序进行模块化的高效开发与管理。<br>于是产生了由于其特殊的特性，bash拥有了fork炸弹。<br>fork炸弹的概念：进程递归式派生（fork，亦即自我复制），以使系统拒绝服务甚至崩溃。</p>
<p>Jaromil在2002年设计了最为精简的一个fork炸弹的实现。</p>
<p><img src="https://linux7788.com/images/posts/fork_bomb.png" alt="image"></p>
<blockquote>
<p>所谓fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环。</p>
</blockquote>
<blockquote>
<p>fork炸弹并不需要有特别的权限即可对系统造成破坏。</p>
</blockquote>
<blockquote>
<p>fork炸弹实质是一个简单的递归程序。</p>
</blockquote>
<blockquote>
<p>由于程序是递归的，如果没有任何限制，这会导致这个简单的程序迅速耗尽系统里面的所有资源。</p>
</blockquote>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/weixin.jpg" alt="赵光建 wechat" style="width: 200px; max-width: 100%;"/>
    <div>技术交流，可扫二维码加微信！</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="赵光建 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/linux/" <i class="fa fa-tag"></i> linux</a>
          
            <a href="/tags/ops/" <i class="fa fa-tag"></i> ops</a>
          
            <a href="/tags/shell/" <i class="fa fa-tag"></i> shell</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/docker/Docker_Container_Limit/" rel="next" title="Docker容器资源限制测试">
                <i class="fa fa-chevron-left"></i> Docker容器资源限制测试
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/docker/Docker_lnmp/" rel="prev" title="Docker 多容器间协作互连范例">
                Docker 多容器间协作互连范例 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

    
    <div id="gitalk-container">
	</div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="赵光建" />
            
              <p class="site-author-name" itemprop="name">赵光建</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/zhaogj1987" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:374251609@qq.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://cn.linkedin.com/in/%E5%85%89%E5%BB%BA-%E8%B5%B5-435a03131" target="_blank" title="Linkedin">
                    
                      <i class="fa fa-fw fa-linkedin"></i>Linkedin</a>
                </span>
              
            
          </div>

          
          

          
          

    <div class="links-of-blogroll motion-element links-of-blogroll-block">
      <div class="links-of-blogroll-title">
        <!-- modify icon to fire by szw -->
        <i class="fa fa-history fa-" aria-hidden="true"></i>
        近期文章
      </div>
      <ul class="links-of-blogroll-list">
        
        
          <li>
            <a href="/linux_ops/linux_base/" title="Linux系统基础知识" target="_blank">Linux系统基础知识</a>
          </li>
        
          <li>
            <a href="/linux_ops/networks/" title="计算机网络基础知识" target="_blank">计算机网络基础知识</a>
          </li>
        
          <li>
            <a href="/linux_ops/computer-operating-system/" title="计算机操作系统基础知识" target="_blank">计算机操作系统基础知识</a>
          </li>
        
          <li>
            <a href="/linux_ops/http/" title="HTTP协议基础知识" target="_blank">HTTP协议基础知识</a>
          </li>
        
          <li>
            <a href="/linux_ops/regexr/" title="正则表达式" target="_blank">正则表达式</a>
          </li>
        
          <li>
            <a href="/docker/docker_python-api/" title="Docker Python Api 操作" target="_blank">Docker Python Api 操作</a>
          </li>
        
          <li>
            <a href="/docker/Docker_question/" title="关于Docker的50个问与答" target="_blank">关于Docker的50个问与答</a>
          </li>
        
          <li>
            <a href="/docker/Docker_lnmp/" title="Docker 多容器间协作互连范例" target="_blank">Docker 多容器间协作互连范例</a>
          </li>
        
          <li>
            <a href="/linux_ops/13_questions_of_shell/" title="shell十五问--shell教程" target="_blank">shell十五问--shell教程</a>
          </li>
        
          <li>
            <a href="/docker/Docker_Container_Limit/" title="Docker容器资源限制测试" target="_blank">Docker容器资源限制测试</a>
          </li>
        
      </ul>
    </div>

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之1-何为shell？"><span class="nav-number">1.</span> <span class="nav-text">shell十五问之1: 何为shell？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之2：shell-prompt-PS1-与Carriage-Return-CR-关系"><span class="nav-number">2.</span> <span class="nav-text">shell十五问之2：shell prompt(PS1)与Carriage Return(CR)关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之3：别人echo、你也echo，是问echo知多少？"><span class="nav-number">3.</span> <span class="nav-text">shell十五问之3：别人echo、你也echo，是问echo知多少？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之4：””-双引号-与’’-单引号-差在哪？"><span class="nav-number">4.</span> <span class="nav-text">shell十五问之4：””(双引号)与’’(单引号)差在哪？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之5-问var-value-在export前后的差在哪"><span class="nav-number">5.</span> <span class="nav-text">shell十五问之5:问var=value 在export前后的差在哪?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-变量设定-set"><span class="nav-number">5.1.</span> <span class="nav-text">1. 变量设定(set)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-变量替换-substitution"><span class="nav-number">5.2.</span> <span class="nav-text">2. 变量替换(substitution)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-export-变量"><span class="nav-number">5.3.</span> <span class="nav-text">3. export 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-取消变量-unset"><span class="nav-number">5.3.1.</span> <span class="nav-text">4. 取消变量(unset)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之6：exec跟source差在哪？"><span class="nav-number">6.</span> <span class="nav-text">shell十五问之6：exec跟source差在哪？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之7：-与-差在哪？"><span class="nav-number">7.</span> <span class="nav-text">shell十五问之7：()与{}差在哪？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之8-与-还有-差在哪？"><span class="nav-number">8.</span> <span class="nav-text">shell十五问之8: $(())与$()还有${}差在哪？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-shell字符串的非贪婪-最小匹配-左删除"><span class="nav-number">8.1.</span> <span class="nav-text">1. shell字符串的非贪婪(最小匹配)左删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-shell字符串的贪婪-最大匹配-左删除："><span class="nav-number">8.2.</span> <span class="nav-text">2. shell字符串的贪婪(最大匹配)左删除：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-shell字符串的非贪婪-最小匹配-右删除："><span class="nav-number">8.3.</span> <span class="nav-text">3. shell字符串的非贪婪(最小匹配)右删除：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-shell字符串的贪婪-最大匹配-右删除："><span class="nav-number">8.4.</span> <span class="nav-text">4. shell字符串的贪婪(最大匹配)右删除：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-shell字符串取子串："><span class="nav-number">8.5.</span> <span class="nav-text">5. shell字符串取子串：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-shell字符串变量值的替换："><span class="nav-number">8.6.</span> <span class="nav-text">6. shell字符串变量值的替换：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-还可针对变量的不同状态-没设定、空值、非空值-进行赋值："><span class="nav-number">8.7.</span> <span class="nav-text">7. ${}还可针对变量的不同状态(没设定、空值、非空值)进行赋值：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-计算shell字符串变量的长度："><span class="nav-number">8.8.</span> <span class="nav-text">8. 计算shell字符串变量的长度：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-bash数组-array-的处理方法"><span class="nav-number">8.9.</span> <span class="nav-text">9. bash数组(array)的处理方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数组替换方法可参考如下方法："><span class="nav-number">8.9.1.</span> <span class="nav-text">1). 数组替换方法可参考如下方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-访问数组的成员"><span class="nav-number">8.9.2.</span> <span class="nav-text">2). 访问数组的成员:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-数组的长度："><span class="nav-number">8.9.3.</span> <span class="nav-text">3). 数组的长度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-数组元素的重新赋值："><span class="nav-number">8.9.4.</span> <span class="nav-text">4). 数组元素的重新赋值：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-作用"><span class="nav-number">8.10.</span> <span class="nav-text">10. $(())作用:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之9：-与-差在哪？"><span class="nav-number">9.</span> <span class="nav-text">shell十五问之9：$@与$*差在哪？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-shell-script的positional-parameter"><span class="nav-number">9.1.</span> <span class="nav-text">1. shell script的positional parameter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-shell-script的positional-parameter的number"><span class="nav-number">9.2.</span> <span class="nav-text">2. shell script的positional parameter的number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-shell-script中的-与"><span class="nav-number">9.3.</span> <span class="nav-text">3. shell script中的$@与$*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之10：-amp-amp-与-差在哪？"><span class="nav-number">10.</span> <span class="nav-text">shell十五问之10：&amp;&amp; 与 || 差在哪？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之11：-gt-与-lt-差在哪？"><span class="nav-number">11.</span> <span class="nav-text">shell十五问之11：&gt;与&lt; 差在哪？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-文件描述符-fd-File-Descriptor"><span class="nav-number">11.1.</span> <span class="nav-text">1. 文件描述符(fd, File Descriptor)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-I-O-重定向-I-O-Redirection"><span class="nav-number">11.2.</span> <span class="nav-text">2. I/O 重定向(I/O Redirection)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-输入重定向-n-lt-input-redirection"><span class="nav-number">11.2.1.</span> <span class="nav-text">2.1 输入重定向 n &lt; (input redirection)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-重定向输出-gt-n-output-redirection"><span class="nav-number">11.2.2.</span> <span class="nav-text">2.2 重定向输出 &gt; n (output redirection)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-I-O重定向与linux中的-dev-null"><span class="nav-number">11.2.3.</span> <span class="nav-text">2.3 I/O重定向与linux中的 /dev/null</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-重定向输出append-gt-gt"><span class="nav-number">11.2.4.</span> <span class="nav-text">2.4 重定向输出append (&gt;&gt;)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-I-O-Redirection的优先级"><span class="nav-number">11.2.5.</span> <span class="nav-text">2.5 I/O Redirection的优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-管道-pipe-line"><span class="nav-number">11.2.6.</span> <span class="nav-text">2.6 管道(pipe line)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之12：你要if还是case呢？"><span class="nav-number">12.</span> <span class="nav-text">shell十五问之12：你要if还是case呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之13：-for-what？-while与until差在哪？"><span class="nav-number">13.</span> <span class="nav-text">shell十五问之13： for what？ while与until差在哪？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-for-loop"><span class="nav-number">13.1.</span> <span class="nav-text">1. for loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-while-loop"><span class="nav-number">13.2.</span> <span class="nav-text">2. while loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-until-loop"><span class="nav-number">13.3.</span> <span class="nav-text">3.until loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-shell-loop中的break与continue"><span class="nav-number">13.4.</span> <span class="nav-text">4. shell loop中的break与continue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之14-跟-差在哪？-wildcard-通配符篇。"><span class="nav-number">14.</span> <span class="nav-text">shell十五问之14: [^ ] 跟[! ]差在哪？ (wildcard)通配符篇。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Wildcard-（通配符）"><span class="nav-number">14.1.</span> <span class="nav-text">1.Wildcard （通配符）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell十五问之15-跟-差在哪？-RE-Regular-Expression）正则表达式篇"><span class="nav-number">15.</span> <span class="nav-text">shell十五问之15: [^ ] 跟[! ]差在哪？ (RE: Regular Expression）正则表达式篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Regular-Expression-正则表达式"><span class="nav-number">15.1.</span> <span class="nav-text">2.Regular Expression (正则表达式)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-eval"><span class="nav-number">15.2.</span> <span class="nav-text">3.eval</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加餐：一个能让系统shell崩溃的shell-片段"><span class="nav-number">16.</span> <span class="nav-text">加餐：一个能让系统shell崩溃的shell 片段</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >

&copy; 
<span itemprop="copyrightYear">2018</span>
<span class="with-love">
<i class="fa fa-"></i>
</span>
<span class="author" itemprop="copyrightHolder">赵光建</span>

</div>


        




  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=65739675";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  
  

          
      <link rel='stylesheet' href="https://yiyeti.cc/usr/themes/veryse/css/gitalk.css">
      <script src="https://yiyeti.cc/usr/themes/veryse/css/gitalk.min.js"></script>
      <script type="text/javascript">
          var gitalk = new Gitalk({
            clientID:  '4088ef6619f645cb3647', 
            clientSecret: 'c2d0a030f1b99a3efd7e6df3d32485ca3ac1af37',
            id: window.location.pathname,
            repo: 'gitalk', 
            owner: 'zhaogj1987', 
            admin: 'zhaogj1987', 
            distractionFreeMode: 'true',
          })
          gitalk.render('gitalk-container')
      </script>
    

  


  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
